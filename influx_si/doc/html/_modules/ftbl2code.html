<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ftbl2code &#8212; influx_si 7.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/classic.css?v=514cf933" />
    
    <script src="../_static/documentation_options.js?v=a9520c2f"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">influx_si 7.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">ftbl2code</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for ftbl2code</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>

<span class="sd">&quot;&quot;&quot;Module for translation of .ftbl file to R code&quot;&quot;&quot;</span>

<span class="c1"># 2012-02-21 sokol@insa-toulouse.fr : cumomer matrices and rhs from sparse matrices</span>
<span class="c1">#                                     (without fortran code)</span>
<span class="c1"># 2009-09-14 sokol@insa-toulouse.fr : flux.[net|xch] -&gt; [dfcg].[nx].flux</span>
<span class="c1">#                                     flux.[fwd|rev] -&gt; [fwd|rev].flux</span>
<span class="c1"># 2008-12-08 sokol@insa-toulouse.fr : added netan2Rinit()</span>
<span class="c1"># 2008-11-25 sokol@insa-toulouse.fr : adapted for reduced cumomer list</span>
<span class="c1"># 2008-09-19 sokol@insa-toulouse.fr : initial release</span>
<span class="c1"># Copyright 2011-2023, INRAE/INSA/CNRS</span>

<span class="c1">#import pdb</span>

<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">itemgetter</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">groupby</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="n">me</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)</span>
<span class="n">dirx</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">me</span><span class="p">)</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dirx</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="n">dirx</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;py3&quot;</span><span class="p">)):</span>
    <span class="n">dirx</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">dirx</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

<span class="kn">import</span> <span class="nn">influx_si</span>
<span class="n">dirr</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">realpath</span><span class="p">(</span><span class="n">influx_si</span><span class="o">.</span><span class="vm">__file__</span><span class="p">)),</span> <span class="s2">&quot;R&quot;</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">tools_ssg</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">C13_ftbl</span>

<div class="viewcode-block" id="netan2Abcumo_spr">
<a class="viewcode-back" href="../progdoc.html#ftbl2code.netan2Abcumo_spr">[docs]</a>
<span class="k">def</span> <span class="nf">netan2Abcumo_spr</span><span class="p">(</span><span class="n">varname</span><span class="p">,</span> <span class="n">Al</span><span class="p">,</span> <span class="n">bl</span><span class="p">,</span> <span class="n">vcumol</span><span class="p">,</span> <span class="n">minput</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">fwrv2i</span><span class="p">,</span> <span class="n">incu2i_b1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transform cumomer linear sytems collection (from ftbl file)</span>
<span class="sd">    to a R code calculating sparse matrix A and vector b</span>
<span class="sd">    in A*x+b=0 for a given weight of fragment iw (index in resulting list)</span>
<span class="sd">    Flux vector fl of all fwd. and rev. fluxes are known at R runtime.</span>
<span class="sd">    </span>
<span class="sd">    Resulting code is a list sprAb indexed by cumomer weight</span>
<span class="sd">    (cf. generated R comments for details on sprAb)</span>
<span class="sd">    cumomer vector incu=c(1, xi, xl), xi - input cumomers, xl - lighter cumomers.</span>
<span class="sd">    </span>
<span class="sd">    incu2i_b1 gives i in incu from cumomer name. i=1 corresponds to the constant 1.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#2012-02-08 sokol</span>
    <span class="c1">#2016-09-23 sokol: any number of fused fragments in b (not limited to 2 as before)</span>
    
    <span class="n">nb_cumu</span><span class="o">=</span><span class="n">cumsum</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">vcumol</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd"># sparse matrix static parts</span>
<span class="sd"># $varname fields:</span>
<span class="sd">#  ind_fa - flux index in a_pre$vfwrv[ind_fa]</span>
<span class="sd">#  a_pre - sparse matrix whose colsum() gives the a$v vector</span>
<span class="sd">#  prodx - dense matrix whose colprod() will give x[ind_x1]*x[ind_x2]*...</span>
<span class="sd">#  ind_fb - flux index in b_pre$v=fwrv[ind_fb1]*colprod(prodx)</span>
<span class="sd">#  ind_b - dense matrix of indexes for  b_pre$v=f[ind_b[,&quot;indf&quot;]*x[ind_b[,2+1]]*x[ind_b[,2+2]], ...]</span>
<span class="sd">#  b_pre - sparse matrix whose colsum gives b@x</span>

<span class="sd">#  a - unsigned sparse cumomer A matrix (off-diagonal part)</span>
<span class="sd">#  b - unsigned sparse vector of right hand side</span>

<span class="sd">if (TIMEIT) {</span>
<span class="sd">   cat(&quot;%(var)-8s: &quot;, format(Sys.time()), &quot; cpu=&quot;, proc.time()[1], &quot;\\n&quot;, sep=&quot;&quot;, file=fclog)</span>
<span class="sd">}</span>

<span class="sd">nb_fwrv=%(n)d</span>
<span class="sd">nb_w=%(nb_w)d</span>
<span class="sd">%(var)s=list()</span>
<span class="sd">    &quot;&quot;&quot;</span><span class="o">%</span><span class="p">{</span>
    <span class="s2">&quot;var&quot;</span><span class="p">:</span> <span class="n">varname</span><span class="p">,</span>
    <span class="s2">&quot;n&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">fwrv2i</span><span class="p">),</span>
    <span class="s2">&quot;nb_w&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">Al</span><span class="p">),</span>
    <span class="p">})</span>
    <span class="c1"># base of cumomers in composed vector incu=c(1, input, xcumo)</span>
    <span class="c1"># +1 for c(1,...)</span>
    <span class="n">ba_x</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">incu2i_b1</span><span class="p">)</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">vcumol</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
    <span class="n">ba_xw</span><span class="o">=</span><span class="n">ba_x</span><span class="p">;</span> <span class="c1"># base for current weigth cumomer in incu</span>
    <span class="n">ncucumo</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">iwl</span><span class="p">,</span><span class="n">A</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">Al</span><span class="p">):</span>
        <span class="n">w</span><span class="o">=</span><span class="n">iwl</span><span class="o">+</span><span class="mi">1</span>
        <span class="n">b</span><span class="o">=</span><span class="n">bl</span><span class="p">[</span><span class="n">iwl</span><span class="p">]</span>
        <span class="n">cumos</span><span class="o">=</span><span class="n">vcumol</span><span class="p">[</span><span class="n">iwl</span><span class="p">]</span>
        <span class="n">ncumo</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">cumos</span><span class="p">)</span>
        <span class="n">c2i</span><span class="o">=</span><span class="nb">dict</span><span class="p">((</span><span class="n">c</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cumos</span><span class="p">))</span>
        <span class="c1">#d=[c for c in netan[&#39;cumo_sys&#39;][&#39;A&#39;][w-1] if not c in cumos]</span>
        <span class="k">if</span> <span class="n">ncumo</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;wrongCumomerNumber: ncumo=</span><span class="si">%d</span><span class="s2">, nrow(A)=</span><span class="si">%d</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">ncumo</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)))</span>
        <span class="n">l_ia</span><span class="o">=</span><span class="p">[];</span> <span class="c1"># list of non zero off-diagonal elements in A / row</span>
        <span class="n">l_ib</span><span class="o">=</span><span class="p">[];</span> <span class="c1"># list of non zero elements in b / row</span>
        <span class="n">nb_maxfa</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="c1"># how many fluxes in an off-diagonal term in a</span>
        <span class="k">if</span> <span class="n">ncumo</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ftbl2code: netan2Abcumo_spr: at the label weight N° </span><span class="si">{</span><span class="n">iwl</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">, the right-hand-sides are all 0 which cannot be as the corresponding </span><span class="si">{</span><span class="n">ncumo</span><span class="si">}</span><span class="s2"> cumomers will be 0 too. The cumomer list is:</span><span class="se">\n\t</span><span class="s2">&quot;</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cumos</span><span class="p">))</span>
        <span class="n">nb_maxprod</span><span class="o">=</span><span class="mi">0</span> <span class="k">if</span> <span class="n">ncumo</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">li</span><span class="p">)</span> <span class="k">for</span> <span class="n">cu</span><span class="p">,</span><span class="n">rdi</span> <span class="ow">in</span> <span class="n">b</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">for</span> <span class="n">fl</span><span class="p">,</span><span class="n">d</span> <span class="ow">in</span> <span class="n">rdi</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">li</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">());</span> <span class="c1"># how many cumomer fragments are fused in b</span>
        <span class="k">for</span> <span class="n">irow</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ncumo</span><span class="p">):</span>
            <span class="n">cr</span><span class="o">=</span><span class="n">cumos</span><span class="p">[</span><span class="n">irow</span><span class="p">]</span>
            <span class="n">row</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="n">cr</span><span class="p">]</span>
            <span class="c1"># atuple is list of (icumo, list(fluxes))</span>
            <span class="n">atuple</span><span class="o">=</span><span class="p">[(</span><span class="n">c2i</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="p">[</span><span class="n">fwrv2i</span><span class="p">[</span><span class="n">fl</span><span class="p">]</span> <span class="k">for</span> <span class="n">fl</span> <span class="ow">in</span> <span class="n">row</span><span class="p">[</span><span class="n">c</span><span class="p">]])</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">row</span><span class="p">]</span> <span class="c1">#cumos if c in row and c!=cr]</span>
            <span class="c1">#if atuple:</span>
            <span class="c1">#    nb_maxfa=max(nb_maxfa, max(len(lf) for (ic, lf) in atuple))</span>
            <span class="c1">#elif cr not in b:</span>
            <span class="c1">#    raise Exception(&quot;Empty row in cumomer matrix, weight=%d (base 1), cumo=%s&quot;%(w, cr))</span>
            <span class="c1"># btuple is list of [iflux, [icumo1, icumo2, icumo_i,...]]</span>
            <span class="k">if</span> <span class="n">cr</span> <span class="ow">in</span> <span class="n">b</span><span class="p">:</span>
                <span class="n">btuple</span><span class="o">=</span><span class="p">[[</span><span class="n">fwrv2i</span><span class="p">[</span><span class="n">fl</span><span class="p">],</span> <span class="p">[</span><span class="n">incu2i_b1</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">l</span><span class="p">]</span><span class="o">+</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">nb_maxprod</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">))]</span>
                    <span class="k">for</span> <span class="p">(</span><span class="n">fl</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="ow">in</span> <span class="n">b</span><span class="p">[</span><span class="n">cr</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">l</span><span class="p">)</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
                <span class="c1">#nb_maxfb=max(nb_maxfb, len(btuple))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">btuple</span><span class="o">=</span><span class="p">[]</span>
            <span class="c1"># one list per row</span>
            <span class="n">l_ia</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atuple</span><span class="p">)</span>
            <span class="c1">#nb_ax+=len(atuple)</span>
            <span class="n">l_ib</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">btuple</span><span class="p">)</span>
        <span class="c1">#print(&quot;w=&quot;, w, &quot;A=&quot;, A, &quot;l_ia=&quot;, l_ia, &quot;\n&quot;)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">if (TIMEIT) {</span>
<span class="sd">   cat(&quot;weight %(w)2d: &quot;, format(Sys.time()), &quot; cpu=&quot;, proc.time()[1], &quot;\\n&quot;, sep=&quot;&quot;, file=fclog)</span>
<span class="sd">}</span>
<span class="sd">w=%(w)d</span>
<span class="sd">nb_c=%(nbc)d</span>
<span class="sd">ba_x=%(ba_x)d; # base of cumomer indexes in incu vector</span>
<span class="sd">l=new.env()</span>
<span class="sd">l$w=w</span>
<span class="sd">l$nb_c=nb_c</span>
<span class="sd">l$nb_fwrv=nb_fwrv</span>
<span class="sd">l$nb_cl=%(ncucumo)d # number of lighter cumomers</span>
<span class="sd">maxprod=%(maxprod)d</span>
<span class="sd">if (nb_c &gt; 0) {</span>
<span class="sd">   # matrix a</span>
<span class="sd">   ind_a=matrix(as.integer(c(%(ind_a)s)), ncol=3, byrow=TRUE)</span>
<span class="sd">   colnames(ind_a)=c(&quot;indf&quot;, &quot;ir0&quot;, &quot;ic0&quot;)</span>
<span class="sd">   l$ind_a=ind_a</span>
<span class="sd">   </span>
<span class="sd">   # vector b</span>
<span class="sd">   ind_b=matrix(as.integer(c(%(ind_b)s)), ncol=2+%(maxprod)d, byrow=TRUE)</span>
<span class="sd">   colnames(ind_b)=c(&quot;indf&quot;, &quot;irow&quot;, paste(&quot;indx&quot;, seq_len(%(maxprod)d), sep=&quot;&quot;))</span>
<span class="sd">   l$ind_b=ind_b</span>
<span class="sd">   </span>
<span class="sd">   # jacobian b_x</span>
<span class="sd">   imaxprod=seq_len(maxprod)</span>
<span class="sd">   ind_bx=c()</span>
<span class="sd">   for (ix in imaxprod) {</span>
<span class="sd">      i=ind_b[,2+ix]&gt;ba_x # exclude from differentiation plain input entries</span>
<span class="sd">      tmp=ind_b[i,,drop=FALSE]</span>
<span class="sd">      ind_bx=rbind(ind_bx, tmp[,c(1,2,ix+2,2+imaxprod[-ix])]) # move diff var to ic1 place</span>
<span class="sd">   }</span>
<span class="sd">   if (length(ind_bx)) {</span>
<span class="sd">      colnames(ind_bx)=c(&quot;indf&quot;, &quot;irow&quot;, &quot;ic1&quot;, sprintf(&quot;indx%%d&quot;, seq_len(maxprod-1)))</span>
<span class="sd">      ind_bx[,&quot;ic1&quot;]=ind_bx[,&quot;ic1&quot;]-ba_x</span>
<span class="sd">   }</span>
<span class="sd">   l$ind_bx=ind_bx</span>
<span class="sd">}</span>
<span class="sd">%(var)s[[w]]=l</span>
<span class="sd">&quot;&quot;&quot;</span><span class="o">%</span><span class="p">{</span>
   <span class="s2">&quot;var&quot;</span><span class="p">:</span> <span class="n">varname</span><span class="p">,</span>
   <span class="s2">&quot;w&quot;</span><span class="p">:</span> <span class="n">w</span><span class="p">,</span>
   <span class="s2">&quot;nbc&quot;</span><span class="p">:</span> <span class="n">ncumo</span><span class="p">,</span>
   <span class="s2">&quot;ncucumo&quot;</span><span class="p">:</span> <span class="n">ncucumo</span><span class="p">,</span>
   <span class="s2">&quot;ba_x&quot;</span><span class="p">:</span> <span class="n">ba_x</span><span class="p">,</span>
   <span class="s2">&quot;maxprod&quot;</span><span class="p">:</span> <span class="n">nb_maxprod</span><span class="p">,</span>
   <span class="s2">&quot;ind_a&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="n">valval</span><span class="p">((</span><span class="n">ifl</span><span class="p">,</span> <span class="n">ir</span><span class="p">,</span> <span class="n">ic</span><span class="p">)</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">ir</span><span class="p">,</span> <span class="n">lt</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">l_ia</span><span class="p">)</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">ic</span><span class="p">,</span> <span class="n">lf</span><span class="p">)</span> <span class="ow">in</span> <span class="n">lt</span>
      <span class="k">for</span> <span class="n">ifl</span> <span class="ow">in</span> <span class="n">lf</span><span class="p">),</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">),</span>
   <span class="s2">&quot;ind_b&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="n">valval</span><span class="p">((</span><span class="n">ifl</span><span class="p">,</span> <span class="n">ir</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ii</span><span class="p">))</span>
       <span class="k">for</span> <span class="p">(</span><span class="n">ir</span><span class="p">,</span> <span class="n">lt</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">l_ib</span><span class="p">)</span>
       <span class="k">for</span> <span class="p">(</span><span class="n">ifl</span><span class="p">,</span> <span class="n">ii</span><span class="p">)</span> <span class="ow">in</span> <span class="n">lt</span>
   <span class="p">),</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">),</span>
<span class="p">})</span>
        <span class="n">ba_xw</span><span class="o">+=</span><span class="n">ncumo</span>
        <span class="n">ncucumo</span><span class="o">+=</span><span class="n">ncumo</span></div>


<div class="viewcode-block" id="netan2Rinit">
<a class="viewcode-back" href="../progdoc.html#ftbl2code.netan2Rinit">[docs]</a>
<span class="k">def</span> <span class="nf">netan2Rinit</span><span class="p">(</span><span class="n">netan</span><span class="p">,</span> <span class="n">org</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">fullsys</span><span class="p">,</span> <span class="n">emu</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ropts</span><span class="o">=</span><span class="p">[],</span> <span class="n">dirres</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Write R code for initialization of all variables before</span>
<span class="sd">cumomer system resolution by chi2 minimization.</span>
<span class="sd">:param netan: a collection of parsed ftbl information</span>
<span class="sd">:param f: R code output pointer</span>
<span class="sd">:param fullsys (logical): write a code for the full or only reduced cumomer system</span>
<span class="sd">:param emu (logical): write equations in EMU framework or cumomer (default)</span>
<span class="sd">:param ropts: list of items &quot;param=value&quot; to be written as is in R file.</span>

<span class="sd">:returns: a dictionnary with some python variables:</span>
<span class="sd">    * &quot;measures&quot;: measures,</span>
<span class="sd">    * &quot;o_mcumos&quot;: o_mcumos,</span>
<span class="sd">    * &quot;cumo2i&quot;: cumo2i,</span>
<span class="sd">    * ...</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Important python variables:</span>
    <span class="c1"># Collections:</span>
    <span class="c1">#    netan - (dict) ftbl structured content</span>
    <span class="c1">#    tfallnx - (3-tuple[reac,[&quot;d&quot;|&quot;f&quot;|&quot;c&quot;|&quot;g&quot;], [&quot;n&quot;|&quot;x&quot;]] list)- total flux</span>
    <span class="c1">#    collection</span>
    <span class="c1">#    measures - (dict) exp data</span>
    <span class="c1">#    rAb - (list) reduced linear systems A*x_cumo=b by weight</span>
    <span class="c1">#    scale - unique scale names</span>
    <span class="c1">#    nrow - counts scale names</span>
    <span class="c1">#    o_sc - ordered scale names</span>
    <span class="c1">#    o_meas - ordered measure types</span>
    <span class="c1"># org - (str) prefix of .ftbl  file like &quot;PPP&quot;</span>
    <span class="c1"># File names (str):</span>
    <span class="c1">#    n_ftbl (descriptor f_ftbl)</span>
    <span class="c1">#    n_opt (R code) (f)</span>
    <span class="c1">#    n_fort (fortran code) (ff)</span>
    <span class="c1"># Counts: nb_fln, nb_flx, nb_fl (dependent fluxes: net, xch, total),</span>
    <span class="c1">#         nb_ffn, nb_ffx (free fluxes)</span>
    <span class="c1"># Index translators:</span>
    <span class="c1">#    fwrv2i - flux names to index in fwrv 1-based</span>
    <span class="c1">#    cumo2i - cumomer names to index in R:x</span>
    <span class="c1">#    ir2isc - mapping measure rows indexes on scale index isc[meas]=ir2isc[meas][ir]</span>
    <span class="c1"># Vector names:</span>
    <span class="c1">#    cumos (list) - names of R:x</span>
    <span class="c1">#    o_mcumos - cumomers involved in measures</span>

    <span class="c1"># Important R variables:</span>
    <span class="c1"># Scalars:</span>
    <span class="c1">#    nb_w, nb_cumos, nb_fln, nb_flx, nb_fl (dependent or unknown fluxes),</span>
    <span class="c1">#    nb_ffn, nb_ffx, nb_ff (free fluxes),</span>
    <span class="c1">#    nb_fcn, nb_fcx, nb_fc (constrained fluxes),</span>
    <span class="c1">#    nb_ineq, nb_param, nb_fmn</span>
    <span class="c1"># Name vectors:</span>
    <span class="c1">#    nm_cumo, nm_fwrv, nm_fallnx, nm_fln, nm_flx, nm_fl, nm_par,</span>
    <span class="c1">#    nm_ffn, nm_ffx,</span>
    <span class="c1">#    nm_fcn, nm_fcx,</span>
    <span class="c1">#    nm_mcumo, nm_fmn</span>
    <span class="c1"># Numeric vectors:</span>
    <span class="c1">#    fwrv - all fluxes (fwd+rev)</span>
    <span class="c1">#    x - all cumomers (weight1+weight2+...)</span>
    <span class="c1">#    param - free flux net, free flux xch, scale label, scale mass, scale peak</span>
    <span class="c1">#    fcn, fcx, fc,</span>
    <span class="c1">#    bp - helps to construct the rhs of flux system</span>
    <span class="c1">#    fallnx - complete flux vector (dep, free, constr, growth:net+xch)</span>
    <span class="c1">#    bc - helps to construct fallnx</span>
    <span class="c1">#    li - inequality vector (mi%*%fallnx&gt;=li)</span>
    <span class="c1">#    ir2isc - measur row to scale vector replicator</span>
    <span class="c1">#    ci - inequalities for param use (ui%*%param-ci&gt;=0)</span>
    <span class="c1">#    measvec,</span>
    <span class="c1">#    measdev,</span>
    <span class="c1">#    fmn</span>
    <span class="c1">#    nb_sys - system sizes</span>
    <span class="c1"># Matrices:</span>
    <span class="c1">#    Afl, qrAfl, invAfl,</span>
    <span class="c1">#    p2bfl - helps to construct the rhs of flux system from free fluxes</span>
    <span class="c1">#    c2bfl - helps to construct the rhs of flux system from constr. fluxes</span>
    <span class="c1">#    mf, md, mc, mg - help to construct fallnx</span>
    <span class="c1">#    mi - inequality matrix (ftbl content)</span>
    <span class="c1">#    ui - inequality matrix (ready for param use)</span>
    <span class="c1">#    measmat - measmat*x+memaone=vec of simulated not-yet-pooled and not-yet-scaled measurements</span>
    <span class="c1"># Functions:</span>
    <span class="c1">#    lab_sim - translate param to flux and cumomer vector (initial approximation)</span>
    <span class="c1">#    cumo_cost - cost function (chi2)</span>
    <span class="c1">#    cumo_grad - finite difference gradient</span>
    <span class="c1">#    fallnx2fwrv - produce fw-rv fluxes from fallnx</span>

    <span class="c1"># Main steps:</span>
    <span class="c1">#    python var init</span>
    <span class="c1">#    R init</span>
    <span class="c1">#    R function fallnx2fwrv()</span>
    <span class="c1">#    python measures, cumos, cumo2i</span>
    <span class="c1">#    fortran code for cumomer systems A*x=b</span>
    <span class="c1">#    R var init</span>
    <span class="c1">#    R Afl, qr(Afl), invAfl</span>
    <span class="c1">#    R param (without scale factors)</span>
    <span class="c1">#    R constrained fluxes</span>
    <span class="c1">#    R p2bfl, c2bfl, bp</span>
    <span class="c1">#    R mf, md, mc</span>
    <span class="c1">#    R mi, li</span>
    <span class="c1">#    python measure matrix, vector and vars</span>
    <span class="c1">#    R ui, ci</span>
    <span class="c1">#    R measure matrix, vector, vars</span>
    <span class="c1">#    R flux measurements</span>

    <span class="n">nexp</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;iso_input&quot;</span><span class="p">])</span>
    <span class="n">fp</span><span class="o">=</span><span class="n">Path</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
    <span class="c1"># header</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;# This is an automatically generated R code. Don&#39;t edit.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;# Generated by </span><span class="se">\n</span><span class="s2"># &quot;</span><span class="o">+</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"># at &quot;</span><span class="o">+</span><span class="n">time</span><span class="o">.</span><span class="n">ctime</span><span class="p">()</span><span class="o">+</span><span class="s2">&quot;.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2"># Copyright 2011-</span><span class="si">%d</span><span class="s2">, INRAE/INSA/CNRS, France.</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="o">%</span><span class="n">time</span><span class="o">.</span><span class="n">localtime</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">res</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span>
    <span class="n">ropts</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">ropts</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ropts</span> <span class="ow">and</span> <span class="n">ropts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;&quot;&#39;</span><span class="p">:</span>
        <span class="n">ropts</span><span class="o">=</span><span class="n">ropts</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2"># working dir</span>
<span class="s2">dirw=&quot;</span><span class="si">%(dirw)s</span><span class="s2">&quot;</span>

<span class="s2"># result dir</span>
<span class="s2">dirres=&quot;</span><span class="si">%(dirres)s</span><span class="s2">&quot;</span>
<span class="s2">write_res=nchar(dirres) &gt; 0L</span>

<span class="s2"># installation dir (where influx_si/R/*.R live)</span>
<span class="s2">dirr=&quot;</span><span class="si">%(dirr)s</span><span class="s2">&quot;</span>
<span class="s2"># short base name of the FTBL (withount &#39;.ftbl&#39;)</span>
<span class="s2">baseshort=&quot;</span><span class="si">%(org)s</span><span class="s2">&quot;</span>

<span class="s2">if (nchar(dirres)) {</span>
<span class="s2">    fcerr=file(file.path(dirres, sprintf(&quot;</span><span class="si">%%</span><span class="s2">s.err&quot;, baseshort)), &quot;ab&quot;)</span>
<span class="s2">    fclog=file(file.path(dirres, sprintf(&quot;</span><span class="si">%%</span><span class="s2">s.log&quot;, baseshort)), &quot;ab&quot;)</span>
<span class="s2">} else {</span>
<span class="s2">    fcerr=base::stderr()</span>
<span class="s2">    fclog=base::stdout()</span>
<span class="s2">}</span>
<span class="s2">if (options()$warn == 0)</span>
<span class="s2">    options(warn=1)</span>
<span class="s2">options(digits.secs=2)</span>

<span class="s2">case_i=</span><span class="si">%(case_i)s</span>

<span class="s2">source(file.path(dirr, &quot;libs.R&quot;), echo=FALSE)</span>

<span class="s2"># define matprod for simple_triplet_matrix</span>
<span class="s2">`</span><span class="si">%%</span><span class="s2">stm</span><span class="si">%%</span><span class="s2">` = slam::matprod_simple_triplet_matrix</span>

<span class="s2"># default options</span>
<span class="s2">version=FALSE</span>
<span class="s2">noopt=FALSE</span>
<span class="s2">noscale=FALSE</span>
<span class="s2">meth=&quot;nlsic&quot;</span>
<span class="s2">fullsys=FALSE</span>
<span class="s2">emu=FALSE</span>
<span class="s2">irand=FALSE</span>
<span class="s2">sens=&quot;&quot;</span>
<span class="s2">cupx=0.999</span>
<span class="s2">cupn=1.e3</span>
<span class="s2">cupp=1.e5</span>
<span class="s2">clownr=0</span>
<span class="s2">cinout=0</span>
<span class="s2">clowp=1.e-8</span>
<span class="s2">np=0</span>
<span class="s2">ln=FALSE</span>
<span class="s2">tikhreg=FALSE</span>
<span class="s2">sln=FALSE</span>
<span class="s2">lim=FALSE</span>
<span class="s2">zc=-.Machine$double.xmax</span>
<span class="s2">ffguess=FALSE</span>
<span class="s2">fdfit=FALSE</span>
<span class="s2">addnoise=FALSE</span>
<span class="s2">fseries=&quot;&quot;</span>
<span class="s2">iseries=&quot;&quot;</span>
<span class="s2">seed=-.Machine$integer.max</span>
<span class="s2">excl_outliers=FALSE</span>
<span class="s2">TIMEIT=FALSE</span>
<span class="s2">prof=FALSE</span>
<span class="s2">time_order=&quot;1&quot;</span>
<span class="s2">wkvh=FALSE</span>
<span class="s2">parR=FALSE</span>

<span class="s2"># get runtime arguments</span>
<span class="si">%(ropts)s</span>

<span class="s2"># synonymous</span>
<span class="s2">myver=version</span>
<span class="s2">optimize=!noopt</span>
<span class="s2">methods=trimws(strsplit(meth, &quot;,&quot;)[[1L]])</span>
<span class="s2">sensitive=sens</span>
<span class="s2">least_norm=ln</span>
<span class="s2">initrand=irand</span>

<span class="s2">vernum=&quot;</span><span class="si">%(vernum)s</span><span class="s2">&quot;</span>

<span class="s2"># sanity check for command line parameters</span>
<span class="s2">if (substring(sensitive, 1, 3)==&quot;mc=&quot;) {</span>
<span class="s2">   # read the mc iteration number</span>
<span class="s2">   nmc=as.integer(substring(sensitive, 4))</span>
<span class="s2">   sensitive=&quot;mc&quot;</span>
<span class="s2">} else if (sensitive==&quot;mc&quot;) {</span>
<span class="s2">   nmc=10</span>
<span class="s2">} else if (nchar(sensitive) &gt; 0L) {</span>
<span class="s2">   stop_mes(&quot;Option &#39;--sens SENS&#39; got unknown argument SENS &#39;&quot;, sensitive,&quot;&#39;</span><span class="se">\\</span><span class="s2">n&quot;,</span>
<span class="s2">      &quot;Expected &#39;mc[=N]&#39; where optional N is a number of Monter-Carlo iterations&quot;, file=fcerr)</span>
<span class="s2">}</span>
<span class="s2"># cupx==0 means no upper limit =&gt; cupx=1</span>
<span class="s2">cupx=ifelse(cupx, cupx, 1)</span>
<span class="s2">if (cupx &lt; 0 || cupx &gt; 1) {</span>
<span class="s2">   stop_mes(&quot;Option &#39;--cupx N&#39; must have N in the interval [0,1]</span><span class="se">\\</span><span class="s2">n&quot;,</span>
<span class="s2">      &quot;Instead, the value &quot;, cupx, &quot; is given.&quot;, file=fcerr)</span>
<span class="s2">}</span>
<span class="s2">if (cinout &lt; 0) {</span>
<span class="s2">   stop_mes(&quot;Option &#39;--cinout N&#39; must have N non negative</span><span class="se">\\</span><span class="s2">n&quot;,</span>
<span class="s2">      &quot;Instead, the value &quot;, cinout, &quot; is given.&quot;, file=fcerr)</span>
<span class="s2">}</span>
<span class="s2"># minimization method</span>
<span class="s2">validmethods=c(&quot;BFGS&quot;, &quot;Nelder-Mead&quot;, &quot;SANN&quot;, &quot;ipopt&quot;, &quot;nlsic&quot;, &quot;pso&quot;)</span>
<span class="s2">if (! all(igood &lt;- (methods </span><span class="si">%%</span><span class="s2">in</span><span class="si">%%</span><span class="s2"> validmethods))) {</span>
<span class="s2">   cat(paste(&quot;***Warning: optimization methods &quot;, paste0(methods[!igood], collapse=&quot;, &quot;), &quot; are not implemented. &#39;nlsic&#39; is used instead.&quot;), &quot;</span><span class="se">\\</span><span class="s2">n&quot;, sep=&quot;&quot;, file=fclog)</span>
<span class="s2">   methods[!igood]=&quot;nlsic&quot;</span>
<span class="s2">}</span>
<span class="s2">if (&quot;ipopt&quot; </span><span class="si">%%</span><span class="s2">in</span><span class="si">%%</span><span class="s2"> methods) {</span>
<span class="s2">   installed=suppressPackageStartupMessages(library(ipoptr, logical.return=TRUE))</span>
<span class="s2">   if (!installed) {</span>
<span class="s2">      stop_mes(&quot;An optimization method ipopt is requested but not available in this R installation&quot;, file=fcerr)</span>
<span class="s2">   }</span>
<span class="s2">}</span>
<span class="s2">if (least_norm &amp;&amp; sln) {</span>
<span class="s2">   stop_mes(&quot;Options --ln and --sln cannot be activated simultaniously.&quot;, file=fcerr)</span>
<span class="s2">}</span>

<span class="s2">avaco=try(detectCores(), silent=TRUE)</span>
<span class="s2">if (inherits(avaco, &quot;try-error&quot;)) {</span>
<span class="s2">   avaco=NULL</span>
<span class="s2">}</span>
<span class="s2">if (np &gt; 0L &amp;&amp; np &lt; 1L) {</span>
<span class="s2">   np=round(avaco*np)</span>
<span class="s2">} else if (np &gt;= 1L) {</span>
<span class="s2">   np=round(np)</span>
<span class="s2">} else {</span>
<span class="s2">   np=avaco</span>
<span class="s2">}</span>
<span class="s2">if (is.null(np) || np &lt;= 0L) {</span>
<span class="s2">   np=1L</span>
<span class="s2">}</span>
<span class="s2">if (sensitive==&quot;mc&quot;) {</span>
<span class="s2">   np=min(np, nmc)</span>
<span class="s2">}</span>
<span class="s2">options(mc.cores=np)</span>

<span class="s2">if (least_norm+tikhreg+lim &gt; 1) {</span>
<span class="s2">   stop_mes(&quot;Options --ln, --lim and --tikhreg cannot be activated simultaneously. Use only one of them at a time.&quot;, file=fcerr)</span>
<span class="s2">}</span>
<span class="s2">lsi_fun=lsi</span>
<span class="s2">if (least_norm || sln) {</span>
<span class="s2">   lsi_fun=lsi_ln</span>
<span class="s2">} else if (tikhreg) {</span>
<span class="s2">   lsi_fun=lsi_reg</span>
<span class="s2">} else if (lim) {</span>
<span class="s2">   suppressPackageStartupMessages(library(limSolve));</span>
<span class="s2">   lsi_fun=lsi_lim</span>
<span class="s2">}</span>
<span class="s2">if (zc==-.Machine$double.xmax) {</span>
<span class="s2">   # no zero scrossing to apply</span>
<span class="s2">   zerocross=F</span>
<span class="s2">} else {</span>
<span class="s2">   if (zc &lt; 0.) {</span>
<span class="s2">      stop_mes(&quot;Zero crossing value ZC must be non negative, instead &quot;, zc, &quot; is given.&quot;, file=fcerr)</span>
<span class="s2">   }</span>
<span class="s2">   zerocross=T</span>
<span class="s2">}</span>
<span class="s2">if (seed==-.Machine$integer.max) {</span>
<span class="s2">   # no seed to apply</span>
<span class="s2">   set_seed=F</span>
<span class="s2">} else {</span>
<span class="s2">   set_seed=T</span>
<span class="s2">   set.seed(seed)</span>
<span class="s2">}</span>
<span class="s2">time_order=gsub(&quot;</span><span class="se">\\\\</span><span class="s2">s&quot;, &quot;&quot;, time_order) # remove spaces if any</span>
<span class="s2">if (!(time_order </span><span class="si">%%</span><span class="s2">in</span><span class="si">%%</span><span class="s2"> c(&quot;1&quot;, &quot;2&quot;, &quot;1,2&quot;))) {</span>
<span class="s2">   stop_mes(&quot;time_order must be &#39;1&#39;, &#39;2&#39; or &#39;1,2&#39;. Instead got &#39;&quot;, time_order, &quot;&#39;&quot;, file=fcerr)</span>
<span class="s2">}</span>
<span class="s2">opts=commandArgs()</span>
<span class="s2"># end command line argument proceeding</span>

<span class="s2"># get some cumomer tools</span>
<span class="s2">source(file.path(dirr, &quot;opt_cumo_tools.R&quot;))</span>
<span class="s2">#loadcmp(file.path(dirr, &quot;opt_cumo_tools.Rc&quot;))</span>

<span class="s2">lab_resid=cumo_resid</span>
<span class="s2">lab_sim=param2fl_x</span>
<span class="s2">jx_f=new.env()</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="o">%</span><span class="p">{</span>
        <span class="s2">&quot;dirw&quot;</span><span class="p">:</span> <span class="n">escape</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">fp</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">resolve</span><span class="p">()),</span> <span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&quot;&#39;</span><span class="p">),</span>
        <span class="s2">&quot;dirres&quot;</span><span class="p">:</span> <span class="n">escape</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">Path</span><span class="p">(</span><span class="n">dirres</span><span class="p">)</span><span class="o">.</span><span class="n">resolve</span><span class="p">())</span> <span class="k">if</span> <span class="n">dirres</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&quot;&#39;</span><span class="p">),</span>
        <span class="s2">&quot;dirr&quot;</span><span class="p">:</span> <span class="n">escape</span><span class="p">(</span><span class="n">dirr</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&quot;&#39;</span><span class="p">),</span>
        <span class="s2">&quot;case_i&quot;</span><span class="p">:</span> <span class="s2">&quot;TRUE&quot;</span> <span class="k">if</span> <span class="n">case_i</span> <span class="k">else</span> <span class="s2">&quot;FALSE&quot;</span><span class="p">,</span>
        <span class="s2">&quot;vernum&quot;</span><span class="p">:</span> <span class="n">influx_si</span><span class="o">.</span><span class="n">__version__</span><span class="p">,</span>
        <span class="s2">&quot;org&quot;</span><span class="p">:</span> <span class="n">escape</span><span class="p">(</span><span class="n">fp</span><span class="o">.</span><span class="n">stem</span><span class="p">,</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">),</span>
        <span class="s2">&quot;ropts&quot;</span><span class="p">:</span> <span class="n">ropts</span><span class="p">,</span>
        <span class="p">})</span>

    <span class="c1"># parse optctrl in netan[&quot;opt&quot;]</span>
    <span class="c1"># optctrl_maxit=100 goes to list(default=list(maxit=100))</span>
    <span class="c1"># optctrl:bfgs:maxit=1000 goes to list(bfgs=list(maxit=1000))</span>
    <span class="n">dctrl</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;default&quot;</span><span class="p">:</span> <span class="nb">dict</span><span class="p">()}</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;opt&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;optctrl&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="mi">7</span><span class="p">:]</span> <span class="c1"># strip &quot;optctrl&quot; part</span>
        <span class="k">if</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;_&quot;</span><span class="p">:</span>
            <span class="n">dctrl</span><span class="p">[</span><span class="s2">&quot;default&quot;</span><span class="p">][</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;:&quot;</span><span class="p">:</span>
            <span class="n">li</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)</span>
            <span class="n">dctrl</span><span class="p">[</span><span class="n">li</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">=</span><span class="n">dctrl</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">li</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">dict</span><span class="p">())</span>
            <span class="n">dctrl</span><span class="p">[</span><span class="n">li</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">,</span> <span class="n">li</span><span class="p">[</span><span class="mi">1</span><span class="p">:])]</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="c1">#print(dctrl)</span>
    <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;,</span><span class="se">\n\t</span><span class="s2">&quot;</span>
    <span class="n">tmp</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;list(</span><span class="si">{</span><span class="n">sep</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;`&#39;</span><span class="o">+</span><span class="n">m</span><span class="o">+</span><span class="s1">&#39;`=list(&#39;</span><span class="o">+</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;`&#39;</span><span class="o">+</span><span class="n">kk</span><span class="o">+</span><span class="s1">&#39;`=&#39;</span><span class="o">+</span><span class="n">vv</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">kk</span><span class="p">,</span><span class="n">vv</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">dd</span><span class="o">.</span><span class="n">items</span><span class="p">())</span><span class="o">+</span><span class="s1">&#39;)&#39;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="n">dd</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">dctrl</span><span class="o">.</span><span class="n">items</span><span class="p">())</span><span class="si">}</span><span class="s2">)&quot;</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;control_ftbl=</span><span class="si">{</span><span class="n">tmp</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">case_i</span><span class="p">:</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">source(file.path(dirr, &quot;opt_icumo_tools.R&quot;))</span>
<span class="s2">#loadcmp(file.path(dirr, &quot;opt_icumo_tools.Rc&quot;))</span>

<span class="s2">lab_resid=icumo_resid</span>
<span class="s2">lab_sim=param2fl_usm_rich</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">if (TIMEIT) {</span>
<span class="s2">   cat(&quot;rinit   : &quot;, format(Sys.time()), &quot; cpu=&quot;, proc.time()[1], &quot;</span><span class="se">\\</span><span class="s2">n&quot;, sep=&quot;&quot;, file=fclog)</span>
<span class="s2">}</span>

<span class="s2"># R profiling</span>
<span class="s2">if (prof)</span>
<span class="s2">   Rprof(file.path(dirw, sprintf(&quot;</span><span class="si">%s</span><span class="s2">.Rprof&quot;, baseshort)))</span>

<span class="s2">nm_list=list()</span>
<span class="s2">nb_f=list()</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>
    <span class="n">netan2R_fl</span><span class="p">(</span><span class="n">netan</span><span class="p">,</span> <span class="n">org</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
    <span class="n">d</span><span class="o">=</span><span class="n">netan2R_rcumo</span><span class="p">(</span><span class="n">netan</span><span class="p">,</span> <span class="n">org</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">emu</span><span class="p">)</span>
    <span class="n">res</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="n">rc_keys_all</span><span class="o">=</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;rcumo_input&quot;</span><span class="p">]]</span>
    <span class="n">emu_keys_all</span><span class="o">=</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;emu_input&quot;</span><span class="p">]]</span> <span class="k">if</span> <span class="n">emu</span> <span class="k">else</span> <span class="p">[]</span>
    <span class="c1">#import pdb; pdb.set_trace()</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">nb_exp=</span><span class="si">%(nb_exp)d</span>
<span class="s2">nm_exp=c(</span><span class="si">%(nm_exp)s</span><span class="s2">)</span>
<span class="s2">nm_list$nm_exp=nm_exp</span>
<span class="s2"># input cumomer vectors, list of vectors for case_s and matrices (nb_inp x nb_time) for case_i</span>
<span class="s2">xi=list(</span><span class="si">%(xi)s</span><span class="s2">)</span>
<span class="s2">if (any(lengths(xi) == 0))</span>
<span class="s2">   stop_mes(&quot;No reduced label entry is defined (may be because no measurement provided). Cannot continue.&quot;, file=fcerr)</span>
<span class="s2">nm_xi=c(</span><span class="si">%(nm_xi)s</span><span class="s2">) # same for all parallel exps</span>
<span class="s2">for (i in seq_along(xi)) {</span>
<span class="s2">   names(xi[[i]])=nm_xi</span>
<span class="s2">}</span>
<span class="s2">nm_list$xi=nm_xi</span>
<span class="s2">nb_xi=length(nm_xi)</span>
<span class="s2">nb_f$xi=nb_xi</span>
<span class="s2">nb_cumoi=nb_xi</span>
<span class="s2">nm_inp=nm_xi</span>
<span class="s2">nm_incu=c(&quot;one&quot;, nm_xi, nm_rcumo)</span>
<span class="s2">nm_inlab=nm_incu</span>
<span class="s2">spa=spAbr</span>
<span class="s2">nm_x=nm_rcumo</span>
<span class="s2">nb_x=nb_rcumos</span>
<span class="s2">nb_f$rcumos=nb_rcumos</span>
<span class="s2">nb_f$cumoi=nb_cumoi</span>
<span class="s2">if (emu) {</span>
<span class="s2">   nm_emu=c(</span><span class="si">%(nm_emu)s</span><span class="s2">)</span>
<span class="s2">   nb_emus=nb_rcumos*(seq_len(nb_rw)+1)</span>
<span class="s2">   nb_f$emus=nb_emus</span>
<span class="s2">   nm_list$emu=nm_emu</span>
<span class="s2">   nm_x=nm_emu</span>
<span class="s2">   nb_x=nb_emus</span>
<span class="s2">   xiemu=list(</span><span class="si">%(xiemu)s</span><span class="s2">)</span>
<span class="s2">   nm_xiemu=c(</span><span class="si">%(nm_xiemu)s</span><span class="s2">)</span>
<span class="s2">   nm_list$xiemu=nm_xiemu</span>
<span class="s2">   for (i in seq_along(xiemu)) {</span>
<span class="s2">       names(xiemu[[i]])=nm_xiemu</span>
<span class="s2">   }</span>
<span class="s2">   nb_xiemu=length(nm_xiemu)</span>
<span class="s2">   nb_f$xiemu=nb_xiemu</span>
<span class="s2">   nb_f$xi=nb_xiemu</span>
<span class="s2">   nb_xi=nb_xiemu</span>
<span class="s2">   nm_inp=nm_xiemu</span>
<span class="s2">   xi=xiemu</span>
<span class="s2">   nm_inemu=c(&quot;one&quot;, nm_xiemu, nm_emu)</span>
<span class="s2">   nm_inlab=nm_inemu</span>
<span class="s2">   spa=spr2emu(spAbr, nm_incu, nm_inemu, nb_f)</span>
<span class="s2">}</span>
<span class="s2"># reorder indexes to accelerate sparse matrix construction</span>
<span class="s2">spa=sparse2spa(spa)</span>
<span class="s2">#browser()</span>
<span class="s2"># composite labeling vector incu c(1, xi, xc) names</span>
<span class="s2">nm_inlab=c(&quot;one&quot;, nm_inp, nm_x); # the constant 1 has name &quot;one&quot;</span>
<span class="s2">nm_list$x=nm_x</span>
<span class="s2">nm_list$inp=nm_inp</span>
<span class="s2">nb_f$x=nb_x</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="o">%</span><span class="p">{</span>
        <span class="s2">&quot;nb_exp&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;iso_input&quot;</span><span class="p">]),</span>
        <span class="s2">&quot;nm_exp&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;exp_names&quot;</span><span class="p">],</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">),</span>
        <span class="s2">&quot;xi&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;,</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">li</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">if</span> <span class="n">li</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">==</span><span class="n">li</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">else</span> <span class="s2">&quot;NA&quot;</span>  <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">rc_keys_all</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">li</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;rcumo_input&quot;</span><span class="p">])),</span> <span class="s2">&quot;c(&quot;</span><span class="p">,</span> <span class="s2">&quot;)&quot;</span><span class="p">),</span>
        <span class="s2">&quot;nm_xi&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="n">rc_keys_all</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">),</span>
        <span class="s2">&quot;xiemu&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;,</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">li</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">if</span> <span class="n">li</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">==</span><span class="n">li</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">else</span> <span class="s2">&quot;NA&quot;</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">emu_keys_all</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">li</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;emu_input&quot;</span><span class="p">])),</span> <span class="s2">&quot;c(&quot;</span><span class="p">,</span> <span class="s2">&quot;)&quot;</span><span class="p">),</span>
        <span class="s2">&quot;nm_xiemu&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="n">emu_keys_all</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">emu</span> <span class="k">else</span> <span class="p">[],</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">),</span>
        <span class="s2">&quot;nm_emu&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="n">valval</span><span class="p">(</span><span class="n">netan</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;vemu&#39;</span><span class="p">,</span> <span class="p">[])),</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">),</span>
        <span class="p">})</span>
    <span class="k">if</span> <span class="n">fullsys</span><span class="p">:</span>
        <span class="n">d</span><span class="o">=</span><span class="n">netan2R_cumo</span><span class="p">(</span><span class="n">netan</span><span class="p">,</span> <span class="n">org</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">spaf=sparse2spa(spAbr_f)</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">nm_cumo=NULL</span>
<span class="s2">spaf=NULL</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>
    <span class="n">d</span><span class="o">=</span><span class="n">netan2R_meas</span><span class="p">(</span><span class="n">netan</span><span class="p">,</span> <span class="n">org</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">emu</span><span class="p">)</span>
    <span class="n">res</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="n">netan2R_ineq</span><span class="p">(</span><span class="n">netan</span><span class="p">,</span> <span class="n">org</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">nb_sys=list(</span>
<span class="s2">   reactions=list(</span>
<span class="s2">      reversible=</span><span class="si">%(rrev)s</span><span class="s2">,</span>
<span class="s2">      non_reversible=</span><span class="si">%(rnonrev)s</span>
<span class="s2">   ),</span>
<span class="s2">   fluxes=list(</span>
<span class="s2">      free=</span><span class="si">%(ff)s</span><span class="s2">,</span>
<span class="s2">      dependent=</span><span class="si">%(fd)s</span><span class="s2">,</span>
<span class="s2">      constrained=</span><span class="si">%(fc)s</span>
<span class="s2">   ),</span>
<span class="s2">   metabolites=list(</span>
<span class="s2">      input=</span><span class="si">%(minp)s</span><span class="s2">,</span>
<span class="s2">      output=</span><span class="si">%(moutp)s</span><span class="s2">,</span>
<span class="s2">      intra=</span><span class="si">%(mintra)s</span>
<span class="s2">   ),</span>
<span class="s2">   measurements=list(</span>
<span class="s2">      flux=</span><span class="si">%(meas_f)s</span><span class="s2">,</span>
<span class="s2">      mass=</span><span class="si">%(meas_m)s</span><span class="s2">,</span>
<span class="s2">      peak=</span><span class="si">%(meas_p)s</span><span class="s2">,</span>
<span class="s2">      label=</span><span class="si">%(meas_l)s</span><span class="s2">,</span>
<span class="s2">      metab=</span><span class="si">%(meas_pool)s</span>
<span class="s2">   ),</span>
<span class="s2">   equations=list(</span>
<span class="s2">      equalities=</span><span class="si">%(eqe)s</span><span class="s2">,</span>
<span class="s2">      inequalities=</span><span class="si">%(eqi)s</span>
<span class="s2">   ),</span>
<span class="s2">   label_variables=list(</span>
<span class="s2">      full=c(</span><span class="si">%(lncumo)s</span><span class="s2">),</span>
<span class="s2">      reduced_cumomers=c(</span><span class="si">%(lnrcumo)s</span><span class="s2">)</span>
<span class="s2">   ),</span>
<span class="s2">   parallel_experiments=</span><span class="si">%(nb_exp)d</span>
<span class="s2">)</span>
<span class="s2">if (sum(nb_sys$label_variables$full)==0) {</span>
<span class="s2">   nb_sys$label_variables$full=NULL</span>
<span class="s2">}</span>
<span class="s2">if (emu) {</span>
<span class="s2">   x=nb_sys$label_variables$reduced_cumomers</span>
<span class="s2">   nb_sys$label_variables$reduced_cumomers=NULL</span>
<span class="s2">   nb_sys$label_variables$emu=paste(x, &quot;*&quot;, seq_len(length(x)), &quot;=&quot;, x*seq_len(length(x)))</span>
<span class="s2">}</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="o">%</span><span class="p">{</span>
        <span class="s2">&quot;rrev&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;reac&quot;</span><span class="p">])</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;notrev&quot;</span><span class="p">]),</span>
        <span class="s2">&quot;rnonrev&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;notrev&quot;</span><span class="p">]),</span>
        <span class="s2">&quot;ff&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_free&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">])</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_free&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">]),</span>
        <span class="s2">&quot;fd&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">])</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">]),</span>
        <span class="s2">&quot;fc&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_constr&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">])</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_constr&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">]),</span>
        <span class="s2">&quot;minp&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">]),</span>
        <span class="s2">&quot;moutp&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;output&quot;</span><span class="p">]),</span>
        <span class="s2">&quot;mintra&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;metabs&quot;</span><span class="p">])</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">])</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;output&quot;</span><span class="p">]),</span>
        <span class="s2">&quot;meas_f&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_meas&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">]),</span>
        <span class="s2">&quot;meas_m&quot;</span><span class="p">:</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;measures&quot;</span><span class="p">][</span><span class="s2">&quot;mass&quot;</span><span class="p">][</span><span class="n">ili</span><span class="p">][</span><span class="s2">&quot;vec&quot;</span><span class="p">])</span> <span class="k">for</span> <span class="n">ili</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nexp</span><span class="p">)),</span>
        <span class="s2">&quot;meas_p&quot;</span><span class="p">:</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;measures&quot;</span><span class="p">][</span><span class="s2">&quot;peak&quot;</span><span class="p">][</span><span class="n">ili</span><span class="p">][</span><span class="s2">&quot;vec&quot;</span><span class="p">])</span> <span class="k">for</span> <span class="n">ili</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nexp</span><span class="p">)),</span>
        <span class="s2">&quot;meas_l&quot;</span><span class="p">:</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;measures&quot;</span><span class="p">][</span><span class="s2">&quot;label&quot;</span><span class="p">][</span><span class="n">ili</span><span class="p">][</span><span class="s2">&quot;vec&quot;</span><span class="p">])</span> <span class="k">for</span> <span class="n">ili</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nexp</span><span class="p">)),</span>
        <span class="s2">&quot;meas_pool&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;metab_measured&quot;</span><span class="p">]),</span>
        <span class="s2">&quot;eqe&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_equal&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">])</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_equal&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">]),</span>
        <span class="s2">&quot;eqi&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_inequal&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">])</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_inequal&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">]),</span>
        <span class="s2">&quot;lncumo&quot;</span><span class="p">:</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;cumo_sys&quot;</span><span class="p">][</span><span class="s2">&quot;A&quot;</span><span class="p">]),</span>
        <span class="s2">&quot;lnrcumo&quot;</span><span class="p">:</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;rcumo_sys&quot;</span><span class="p">][</span><span class="s2">&quot;A&quot;</span><span class="p">]),</span>
        <span class="s2">&quot;nb_exp&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;iso_input&quot;</span><span class="p">])</span>
        <span class="p">})</span>
    <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="netan2R_fl">
<a class="viewcode-back" href="../progdoc.html#ftbl2code.netan2R_fl">[docs]</a>
<span class="k">def</span> <span class="nf">netan2R_fl</span><span class="p">(</span><span class="n">netan</span><span class="p">,</span> <span class="n">org</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;netan2R_fl(netan, org, f)</span>
<span class="sd">    generate R code for flux and pool part</span>
<span class="sd">    for more details cf. netan2Rinit()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># dependent flux counts</span>
    <span class="n">nb_fln</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s1">&#39;vflux&#39;</span><span class="p">][</span><span class="s1">&#39;net&#39;</span><span class="p">])</span>
    <span class="n">nb_flx</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s1">&#39;vflux&#39;</span><span class="p">][</span><span class="s1">&#39;xch&#39;</span><span class="p">])</span>
    <span class="n">nb_fl</span><span class="o">=</span><span class="n">nb_fln</span><span class="o">+</span><span class="n">nb_flx</span>

    <span class="c1"># prepare index translator for free fluxes</span>
    <span class="c1"># it will be used in bfl expressions where names like flx.net must</span>
    <span class="c1"># be mapped on respecting parameter index</span>
    <span class="n">nb_ffn</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s1">&#39;flux_free&#39;</span><span class="p">][</span><span class="s1">&#39;net&#39;</span><span class="p">])</span>
    <span class="n">nb_ffx</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s1">&#39;flux_free&#39;</span><span class="p">][</span><span class="s1">&#39;xch&#39;</span><span class="p">])</span>
    <span class="n">nb_fcn</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s1">&#39;flux_constr&#39;</span><span class="p">][</span><span class="s1">&#39;net&#39;</span><span class="p">])</span>
    <span class="n">nb_fcx</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s1">&#39;flux_constr&#39;</span><span class="p">][</span><span class="s1">&#39;xch&#39;</span><span class="p">])</span>
    <span class="n">ffn2iprm</span><span class="o">=</span><span class="nb">dict</span><span class="p">((</span><span class="s2">&quot;f.n.&quot;</span><span class="o">+</span><span class="n">f</span><span class="p">,(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s1">&#39;vflux_free&#39;</span><span class="p">][</span><span class="s1">&#39;net2i&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
    <span class="n">ffx2iprm</span><span class="o">=</span><span class="nb">dict</span><span class="p">((</span><span class="s2">&quot;f.x.&quot;</span><span class="o">+</span><span class="n">f</span><span class="p">,(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="n">nb_ffn</span><span class="p">))</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s1">&#39;vflux_free&#39;</span><span class="p">][</span><span class="s1">&#39;xch2i&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>

    <span class="c1"># prepare fwrv2i</span>
    <span class="n">fwrv2i</span><span class="o">=</span><span class="nb">dict</span><span class="p">((</span><span class="n">f</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_fwrv&quot;</span><span class="p">][</span><span class="s2">&quot;fwrv2i&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
    <span class="n">nb_fwrv</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_fwrv&quot;</span><span class="p">][</span><span class="s2">&quot;fwrv2i&quot;</span><span class="p">])</span>

    <span class="c1"># make tuple for complete flux vector d,f,c</span>
    <span class="c1"># (name,&quot;d|f|c|g&quot;,&quot;n|x&quot;)</span>
    <span class="n">tfallnx</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span>
            <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">]</span><span class="o">+</span>
            <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_free&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">]</span><span class="o">+</span>
            <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_constr&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">]</span><span class="o">+</span>
            <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_growth&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">]</span><span class="o">+</span>
            <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">]</span><span class="o">+</span>
            <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_free&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">]</span><span class="o">+</span>
            <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_constr&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">]</span><span class="o">+</span>
            <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_growth&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">],</span>

            <span class="p">[</span><span class="s2">&quot;d&quot;</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">])</span><span class="o">+</span>
            <span class="p">[</span><span class="s2">&quot;f&quot;</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_free&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">])</span><span class="o">+</span>
            <span class="p">[</span><span class="s2">&quot;c&quot;</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_constr&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">])</span><span class="o">+</span>
            <span class="p">[</span><span class="s2">&quot;g&quot;</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_growth&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">])</span><span class="o">+</span>
            <span class="p">[</span><span class="s2">&quot;d&quot;</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">])</span><span class="o">+</span>
            <span class="p">[</span><span class="s2">&quot;f&quot;</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_free&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">])</span><span class="o">+</span>
            <span class="p">[</span><span class="s2">&quot;c&quot;</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_constr&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">])</span><span class="o">+</span>
            <span class="p">[</span><span class="s2">&quot;g&quot;</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_growth&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">]),</span>

            <span class="p">[</span><span class="s2">&quot;n&quot;</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">])</span><span class="o">+</span>
            <span class="p">[</span><span class="s2">&quot;n&quot;</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_free&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">])</span><span class="o">+</span>
            <span class="p">[</span><span class="s2">&quot;n&quot;</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_constr&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">])</span><span class="o">+</span>
            <span class="p">[</span><span class="s2">&quot;n&quot;</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_growth&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">])</span><span class="o">+</span>
            <span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">])</span><span class="o">+</span>
            <span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_free&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">])</span><span class="o">+</span>
            <span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_constr&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">])</span><span class="o">+</span>
            <span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_growth&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">]),</span>
            <span class="p">))</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;f2dfcg_nx_f&quot;</span><span class="p">]</span><span class="o">=</span><span class="p">{</span>
       <span class="s2">&quot;net&quot;</span><span class="p">:</span> <span class="nb">dict</span><span class="p">((</span><span class="n">fl</span><span class="p">,</span> <span class="n">t</span><span class="o">+</span><span class="s2">&quot;.n.&quot;</span><span class="o">+</span><span class="n">fl</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">fl</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">nx</span><span class="p">)</span> <span class="ow">in</span> <span class="n">tfallnx</span> <span class="k">if</span> <span class="n">nx</span><span class="o">==</span><span class="s2">&quot;n&quot;</span><span class="p">),</span>
       <span class="s2">&quot;xch&quot;</span><span class="p">:</span> <span class="nb">dict</span><span class="p">((</span><span class="n">fl</span><span class="p">,</span> <span class="n">t</span><span class="o">+</span><span class="s2">&quot;.x.&quot;</span><span class="o">+</span><span class="n">fl</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">fl</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">nx</span><span class="p">)</span> <span class="ow">in</span> <span class="n">tfallnx</span> <span class="k">if</span> <span class="n">nx</span><span class="o">==</span><span class="s2">&quot;x&quot;</span><span class="p">),</span>
    <span class="p">}</span>

    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">if (TIMEIT) {</span>
<span class="s2">   cat(&quot;r_flux  : &quot;, format(Sys.time()), &quot; cpu=&quot;, proc.time()[1], &quot;</span><span class="se">\\</span><span class="s2">n&quot;, sep=&quot;&quot;, file=fclog)</span>
<span class="s2">}</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>
    <span class="c1"># auxiliary dict for edge-flux coupling</span>
    <span class="n">f2edge</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">fl</span><span class="p">,</span><span class="n">lr</span><span class="p">)</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;sto_r_m&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lr</span><span class="p">[</span><span class="s2">&quot;left&quot;</span><span class="p">])</span><span class="o">==</span><span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">lr</span><span class="p">[</span><span class="s2">&quot;right&quot;</span><span class="p">])</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
           <span class="n">f2edge</span><span class="p">[</span><span class="n">fl</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="n">lr</span><span class="p">[</span><span class="s2">&quot;left&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="s2">&quot; (&quot;</span><span class="o">+</span><span class="n">fl</span><span class="o">+</span><span class="s2">&quot;) &quot;</span><span class="o">+</span><span class="n">lr</span><span class="p">[</span><span class="s2">&quot;right&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
           <span class="n">f2edge</span><span class="p">[</span><span class="n">fl</span><span class="p">]</span><span class="o">=</span><span class="p">[]</span>
           <span class="n">subs</span><span class="o">=</span><span class="p">[</span><span class="n">m</span> <span class="k">for</span> <span class="n">m</span><span class="p">,</span><span class="n">_</span> <span class="ow">in</span> <span class="n">lr</span><span class="p">[</span><span class="s2">&quot;left&quot;</span><span class="p">]]</span> <span class="c1"># substrates</span>
           <span class="n">prods</span><span class="o">=</span><span class="p">[</span><span class="n">m</span> <span class="k">for</span> <span class="n">m</span><span class="p">,</span><span class="n">_</span> <span class="ow">in</span> <span class="n">lr</span><span class="p">[</span><span class="s2">&quot;right&quot;</span><span class="p">]]</span> <span class="c1"># products</span>
           <span class="n">same_subs</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">subs</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">subs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="n">subs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
           <span class="n">same_prods</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">prods</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">prods</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="n">prods</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
           <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">subs</span><span class="p">):</span>
               <span class="n">f2edge</span><span class="p">[</span><span class="n">fl</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="s2">&quot; (&quot;</span><span class="o">+</span><span class="n">fl</span><span class="o">+</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">same_subs</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;) &quot;</span><span class="o">+</span><span class="n">fl</span><span class="p">)</span>
           <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">prods</span><span class="p">):</span>
               <span class="n">f2edge</span><span class="p">[</span><span class="n">fl</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fl</span><span class="o">+</span><span class="s2">&quot; (&quot;</span><span class="o">+</span><span class="n">fl</span><span class="o">+</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">same_prods</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;) &quot;</span><span class="o">+</span><span class="n">m</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2"># fwd-rev flux names</span>
<span class="s2">nm_fwrv=c(</span><span class="si">%(nm_fwrv)s</span><span class="s2">)</span>

<span class="s2"># edge to netflux name translator</span>
<span class="s2">edge2fl=c(</span><span class="si">%(edge2fl)s</span><span class="s2">)</span>
<span class="s2">names(edge2fl)=c(</span><span class="si">%(nedge2fl)s</span><span class="s2">)</span>

<span class="s2"># initialize the linear system Afl*flnx=bfl (0-weight cumomers)</span>
<span class="s2"># unknown net flux names</span>
<span class="s2">nm_fln=c(</span><span class="si">%(nm_fln)s</span><span class="s2">)</span>
<span class="s2">nb_fln=length(nm_fln)</span>
<span class="s2">fln=c(</span><span class="si">%(fln)s</span><span class="s2">)</span>
<span class="s2">names(fln)=nm_fln</span>
<span class="s2"># unknown xch flux names</span>
<span class="s2">nm_flx=c(</span><span class="si">%(nm_flx)s</span><span class="s2">)</span>
<span class="s2">nb_flx=length(nm_flx)</span>
<span class="s2">flx=c(</span><span class="si">%(flx)s</span><span class="s2">)</span>
<span class="s2">names(flx)=nm_flx</span>
<span class="s2">nm_fl=c(nm_fln, nm_flx)</span>
<span class="s2">nb_fl=nb_fln+nb_flx</span>
<span class="s2">fl=c(fln, flx)</span>
<span class="s2"># gather flux names in a list</span>
<span class="s2">nm_list$flnx=nm_fl</span>
<span class="s2">nm_list$fwrv=nm_fwrv</span>

<span class="s2"># carbon length of metabolites</span>
<span class="s2">clen=c(</span><span class="si">%(clen)s</span><span class="s2">)</span>
<span class="s2">names(clen)=c(</span><span class="si">%(nm_metab)s</span><span class="s2">)</span>

<span class="s2"># metabolite pools are : all (poolall) which is divided in free (poolf) and</span>
<span class="s2"># constrained (poolc)</span>

<span class="s2"># constrained pool</span>
<span class="s2">poolc=c(</span><span class="si">%(poolc)s</span><span class="s2">)</span>
<span class="s2">nm_poolc=c(</span><span class="si">%(nm_poolc)s</span><span class="s2">)</span>
<span class="s2">if (length(nm_poolc)) {</span>
<span class="s2">   names(nm_poolc)=substring(nm_poolc, 4)</span>
<span class="s2">}</span>
<span class="s2">names(poolc)=nm_poolc</span>

<span class="s2"># starting values for free pool (the same number and the same alphabetic order than free growth fluxes, if present)</span>
<span class="s2">poolf=c(</span><span class="si">%(poolf)s</span><span class="s2">)</span>
<span class="s2">nm_poolf=c(</span><span class="si">%(nm_poolf)s</span><span class="s2">)</span>
<span class="s2">if (length(nm_poolf)) {</span>
<span class="s2">   names(nm_poolf)=substring(nm_poolf, 4)</span>
<span class="s2">}</span>
<span class="s2">names(poolf)=nm_poolf</span>
<span class="s2">nb_poolf=length(poolf)</span>
<span class="s2">nb_f$nb_poolf=nb_poolf</span>

<span class="s2">nm_poolall=c(nm_poolf, nm_poolc)</span>
<span class="s2">poolall=as.numeric(c(poolf, poolc))</span>
<span class="s2">names(poolall)=nm_poolall</span>
<span class="s2">pool=poolall</span>
<span class="s2">nm_list$poolf=nm_poolf</span>
<span class="s2">nm_list$poolc=nm_poolc</span>
<span class="s2">nm_list$poolall=nm_poolall</span>

<span class="s2"># flux matrix</span>
<span class="s2">nb_flr=</span><span class="si">%(nb_flr)d</span>
<span class="s2">if (nb_fl) {</span>
<span class="s2">   Afl=matrix(0, nrow=nb_flr, ncol=nb_fl)</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="o">%</span><span class="p">{</span>
        <span class="s2">&quot;nb_flr&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;Afl&quot;</span><span class="p">]),</span>
        <span class="s2">&quot;nm_fwrv&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_fwrv&quot;</span><span class="p">][</span><span class="s2">&quot;fwrv&quot;</span><span class="p">],</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">),</span>
        <span class="s2">&quot;nm_fln&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">],</span> <span class="s1">&#39;&quot;d.n.&#39;</span><span class="p">,</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">),</span>
        <span class="s2">&quot;fln&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_dep&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">]),</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">),</span>
        <span class="s2">&quot;nm_flx&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">],</span> <span class="s1">&#39;&quot;d.x.&#39;</span><span class="p">,</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">),</span>
        <span class="s2">&quot;flx&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_dep&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">]),</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">),</span>
        <span class="s2">&quot;edge2fl&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;&quot;&#39;</span><span class="o">+</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;f2dfcg_nx_f&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">][</span><span class="n">fl</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;&quot;&#39;</span> <span class="k">for</span> <span class="p">(</span><span class="n">fl</span><span class="p">,</span><span class="n">l</span><span class="p">)</span> <span class="ow">in</span> <span class="n">f2edge</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">l</span><span class="p">),</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">),</span>
        <span class="s2">&quot;nedge2fl&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;&quot;&#39;</span><span class="o">+</span><span class="n">e</span><span class="o">+</span><span class="s1">&#39;&quot;&#39;</span> <span class="k">for</span> <span class="p">(</span><span class="n">fl</span><span class="p">,</span><span class="n">l</span><span class="p">)</span> <span class="ow">in</span> <span class="n">f2edge</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">l</span><span class="p">),</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">),</span>
        <span class="s2">&quot;clen&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;Clen&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">),</span>
        <span class="s2">&quot;nm_metab&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;Clen&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">),</span>
        <span class="s2">&quot;poolf&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;met_pools&quot;</span><span class="p">][</span><span class="n">m</span><span class="p">]</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vpool&quot;</span><span class="p">][</span><span class="s2">&quot;free&quot;</span><span class="p">]),</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">),</span>
        <span class="s2">&quot;nm_poolf&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vpool&quot;</span><span class="p">][</span><span class="s2">&quot;free&quot;</span><span class="p">],</span> <span class="s1">&#39;&quot;pf:&#39;</span><span class="p">,</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">),</span>
        <span class="s2">&quot;poolc&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;met_pools&quot;</span><span class="p">][</span><span class="n">m</span><span class="p">]</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vpool&quot;</span><span class="p">][</span><span class="s2">&quot;constrained&quot;</span><span class="p">]),</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">),</span>
        <span class="s2">&quot;nm_poolc&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vpool&quot;</span><span class="p">][</span><span class="s2">&quot;constrained&quot;</span><span class="p">],</span> <span class="s1">&#39;&quot;pc:&#39;</span><span class="p">,</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">),</span>
    <span class="p">})</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">row</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;Afl&quot;</span><span class="p">]):</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
<span class="sd">&quot;&quot;&quot;   Afl[%(i)d, c(%(ic)s)]=c(%(v)s)</span>
<span class="sd">        &quot;&quot;&quot;</span><span class="o">%</span><span class="p">{</span>
            <span class="s2">&quot;i&quot;</span><span class="p">:</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
            <span class="s2">&quot;ic&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="k">if</span> <span class="n">v</span><span class="o">!=</span><span class="mf">0.</span><span class="p">),</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">),</span>
            <span class="s2">&quot;v&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">row</span> <span class="k">if</span> <span class="n">v</span><span class="o">!=</span><span class="mf">0.</span><span class="p">),</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">),</span>
        <span class="p">})</span>
    <span class="c1">#pdb.set_trace()</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
<span class="sd">&quot;&quot;&quot;} else {</span>
<span class="sd">   Afl=matrix(0., nb_fl, nb_fl)</span>
<span class="sd">}</span>
<span class="sd">dimnames(Afl)=list(c(%(nm_rows)s), nm_fl)</span>
<span class="sd">#browser()</span>
<span class="sd"># prepare param (Theta) vector</span>
<span class="sd"># order: free flux net, free flux xch, scale label, scale mass, scale peak</span>
<span class="sd">param=numeric(0)</span>
<span class="sd">nm_par=c()</span>
<span class="sd"># free net fluxes</span>
<span class="sd">nb_ffn=%(nb_ffn)d</span>
<span class="sd">nm_ffn=c(%(nm_ffn)s)</span>
<span class="sd"># starting values for iterations</span>
<span class="sd">param=c(param, c(%(ffn)s))</span>
<span class="sd">if (nb_ffn) {</span>
<span class="sd">   nm_par=c(nm_par, nm_ffn)</span>
<span class="sd">}</span>
<span class="sd"># free xch fluxes</span>
<span class="sd">nb_ffx=%(nb_ffx)d</span>
<span class="sd">nm_ffx=c(%(nm_ffx)s)</span>
<span class="sd"># starting values for iterations</span>
<span class="sd">param=c(param, c(%(ffx)s))</span>
<span class="sd">if (nb_ffx) {</span>
<span class="sd">   nm_par=c(nm_par, nm_ffx)</span>
<span class="sd">}</span>
<span class="sd">names(param)=nm_par</span>
<span class="sd">ff=param</span>
<span class="sd">nm_ff=c(nm_ffn, nm_ffx)</span>
<span class="sd">nm_list$ff=nm_ff</span>
<span class="sd">nb_param=length(param)</span>
<span class="sd"># scaling factors are added to param later</span>

<span class="sd">nb_ff=nb_ffn+nb_ffx</span>

<span class="sd"># constrained fluxes</span>
<span class="sd"># net</span>
<span class="sd">nb_fcn=%(nb_fcn)d</span>
<span class="sd">nm_fcn=c(%(nm_fcn)s)</span>
<span class="sd">fcn=c(%(fcn)s)</span>
<span class="sd"># xch</span>
<span class="sd">nb_fcx=%(nb_fcx)d</span>
<span class="sd">nm_fcx=c(%(nm_fcx)s)</span>
<span class="sd">fcx=c(%(fcx)s)</span>
<span class="sd">fc=c(fcn, fcx)</span>
<span class="sd">nm_fc=c(nm_fcn, nm_fcx)</span>
<span class="sd">names(fc)=nm_fc</span>
<span class="sd">nb_fc=nb_fcn+nb_fcx</span>

<span class="sd"># variable growth fluxes (constant are already accounted in constrained fluxes)</span>
<span class="sd">nb_fgr=%(nb_fgr)d</span>
<span class="sd">nm_fgr=c(%(nm_fgr)s)</span>
<span class="sd">fgr=c(%(fgr)s)</span>
<span class="sd">nm_list$fgr=nm_fgr</span>
<span class="sd">nb_f$nb_fgr=nb_fgr</span>

<span class="sd"># total flux vector fallnx dimension</span>
<span class="sd">nb_fallnx=nb_fl+nb_ff+nb_fc+nb_fgr+nb_fgr</span>
<span class="sd">nb_fwrv=nb_fallnx</span>

<span class="sd"># net dependent and free fluxes</span>
<span class="sd">nm_dfn=c(nm_fln, nm_ffn)</span>
<span class="sd">names(nm_dfn)=substring(nm_dfn, 5)</span>

<span class="sd"># all flux cardinals</span>
<span class="sd">nb_f=append(nb_f, list(nb_fln=nb_fln, nb_flx=nb_flx, nb_fl=nb_fl,</span>
<span class="sd">   nb_ffn=nb_ffn, nb_ffx=nb_ffx, nb_ff=nb_ff,</span>
<span class="sd">   nb_fcn=nb_fcn, nb_fcx=nb_fcx, nb_fc=nb_fc,</span>
<span class="sd">   nb_fallnx=nb_fallnx, nb_fwrv=nb_fwrv,</span>
<span class="sd">   nb_fgr=nb_fgr,</span>
<span class="sd">   include_growth_flux=%(inc_gr_f)s,</span>
<span class="sd">   mu=%(mu)s))</span>
<span class="sd">    &quot;&quot;&quot;</span><span class="o">%</span><span class="p">{</span>
        <span class="s2">&quot;nm_rows&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vrowAfl&quot;</span><span class="p">],</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">),</span>
        <span class="s2">&quot;nb_ffn&quot;</span><span class="p">:</span> <span class="n">nb_ffn</span><span class="p">,</span>
        <span class="s2">&quot;nb_ffx&quot;</span><span class="p">:</span> <span class="n">nb_ffx</span><span class="p">,</span>
        <span class="s2">&quot;nm_ffn&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_free&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">],</span> <span class="s1">&#39;&quot;f.n.&#39;</span><span class="p">,</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">),</span>
        <span class="s2">&quot;nm_ffx&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_free&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">],</span> <span class="s1">&#39;&quot;f.x.&#39;</span><span class="p">,</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">),</span>
        <span class="s2">&quot;ffn&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_free&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">][</span><span class="n">fl</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">fl</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_free&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">]],</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">),</span>
        <span class="s2">&quot;ffx&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_free&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">][</span><span class="n">fl</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">fl</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_free&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">]],</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">),</span>
        <span class="s2">&quot;nb_fcn&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_constr&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">]),</span>
        <span class="s2">&quot;nb_fcx&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_constr&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">]),</span>
        <span class="s2">&quot;nm_fcn&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_constr&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">],</span> <span class="s1">&#39;&quot;c.n.&#39;</span><span class="p">,</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">),</span>
        <span class="s2">&quot;nm_fcx&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_constr&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">],</span> <span class="s1">&#39;&quot;c.x.&#39;</span><span class="p">,</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">),</span>
        <span class="s2">&quot;fcn&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_constr&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">][</span><span class="n">fl</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">fl</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_constr&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">]],</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">),</span>
        <span class="s2">&quot;fcx&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_constr&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">][</span><span class="n">fl</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">fl</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_constr&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">]],</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">),</span>
        <span class="s2">&quot;inc_gr_f&quot;</span><span class="p">:</span> <span class="s2">&quot;TRUE&quot;</span> <span class="k">if</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;opt&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;include_growth_flux&quot;</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;FALSE&quot;</span><span class="p">,</span>
        <span class="s2">&quot;mu&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;opt&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;mu&quot;</span><span class="p">,</span> <span class="s2">&quot;NULL&quot;</span><span class="p">)),</span>
        <span class="s2">&quot;nb_fgr&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_growth&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">]),</span>
        <span class="s2">&quot;nm_fgr&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_growth&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">],</span> <span class="s1">&#39;&quot;g.n.&#39;</span><span class="p">,</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">),</span>
        <span class="s2">&quot;fgr&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_vgrowth&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">][</span><span class="n">fl</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">fl</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_growth&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">]],</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">),</span>
    <span class="p">})</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2"># prepare p2bfl, c2bfl, g2bfl, cnst2bfl matrices such that p2bfl</span><span class="si">%*%</span><span class="s2">param[1:nb_ff]+</span>
<span class="s2"># c2bfl</span><span class="si">%*%</span><span class="s2">fc+g2bfl</span><span class="si">%*%</span><span class="s2">fgr+cnst2bfl=bfl</span>
<span class="s2"># replace f.[nx].flx by corresponding param coefficient</span>
<span class="s2">p2bfl=simple_triplet_zero_matrix(nrow=nb_flr, ncol=nb_ff)</span>
<span class="s2"># replace c.[nx].flx by corresponding fc coefficient</span>
<span class="s2">c2bfl=simple_triplet_zero_matrix(nrow=nb_flr, ncol=nb_fc)</span>
<span class="s2"># variable growth fluxes</span>
<span class="s2">g2bfl=simple_triplet_zero_matrix(nrow=nb_flr, ncol=nb_fgr)</span>
<span class="s2">cnst2bfl=numeric(nb_flr); # may be coming from equalities</span>
<span class="s2">colnames(p2bfl)=nm_par</span>
<span class="s2">colnames(c2bfl)=nm_fc</span>
<span class="s2">colnames(g2bfl)=nm_fgr</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>
    <span class="n">row</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;f&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;g&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;cnst&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">item</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;bfl&quot;</span><span class="p">]):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">item</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="c1"># split terms in flux types</span>
        <span class="n">row</span><span class="p">[</span><span class="s2">&quot;cnst&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">item</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">row</span><span class="p">[</span><span class="s2">&quot;f&quot;</span><span class="p">]</span><span class="o">=</span><span class="nb">dict</span><span class="p">((</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">item</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;f.&quot;</span><span class="p">)</span>
        <span class="n">row</span><span class="p">[</span><span class="s2">&quot;c&quot;</span><span class="p">]</span><span class="o">=</span><span class="nb">dict</span><span class="p">((</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">item</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;c.&quot;</span><span class="p">)</span>
        <span class="n">row</span><span class="p">[</span><span class="s2">&quot;g&quot;</span><span class="p">]</span><span class="o">=</span><span class="nb">dict</span><span class="p">((</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">item</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;g.&quot;</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;f&quot;</span><span class="p">]:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;p2bfl[</span><span class="si">%(i)d</span><span class="s2">, pmatch(c(</span><span class="si">%(if)s</span><span class="s2">), nm_par)]=c(</span><span class="si">%(rowf)s</span><span class="s2">);</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">%</span>\
                <span class="p">{</span><span class="s2">&quot;i&quot;</span><span class="p">:</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
                <span class="s2">&quot;if&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;f&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span> <span class="n">p</span><span class="o">=</span><span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">),</span>
                <span class="s2">&quot;rowf&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;f&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">),</span>
                <span class="p">})</span>
        <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;c&quot;</span><span class="p">]:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;c2bfl[</span><span class="si">%(i)d</span><span class="s2">, pmatch(c(</span><span class="si">%(ic)s</span><span class="s2">), nm_fc)]=c(</span><span class="si">%(rowc)s</span><span class="s2">);</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">%</span>\
                <span class="p">{</span><span class="s2">&quot;i&quot;</span><span class="p">:</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
                <span class="s2">&quot;ic&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;c&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span> <span class="n">p</span><span class="o">=</span><span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">),</span>
                <span class="s2">&quot;rowc&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;c&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">),</span>
                <span class="p">})</span>
        <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;g&quot;</span><span class="p">]:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;g2bfl[</span><span class="si">%(i)d</span><span class="s2">, pmatch(c(</span><span class="si">%(ig)s</span><span class="s2">), nm_fgr)]=c(</span><span class="si">%(rowg)s</span><span class="s2">);</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">%</span>\
                <span class="p">{</span><span class="s2">&quot;i&quot;</span><span class="p">:</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
                <span class="s2">&quot;ig&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;g&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span> <span class="n">p</span><span class="o">=</span><span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">),</span>
                <span class="s2">&quot;rowg&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;g&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">),</span>
                <span class="p">})</span>
        <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;cnst&quot;</span><span class="p">]:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;cnst2bfl[</span><span class="si">%(i)d</span><span class="s2">]=</span><span class="si">%(rowcnst)s</span><span class="s2">;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">{</span><span class="s2">&quot;i&quot;</span><span class="p">:</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;rowcnst&quot;</span><span class="p">:</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;cnst&quot;</span><span class="p">],})</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">bp=as.numeric(c2bfl</span><span class="si">%s</span><span class="s2">tm</span><span class="si">%f</span><span class="s2">c+cnst2bfl)</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">if (ffguess) {</span>
<span class="s2">   # make an automatic guess for free/dependent flux partition</span>
<span class="s2">   afd=as.matrix(cbind(Afl, -p2bfl))</span>
<span class="s2">   qafd=qr(afd, LAPACK=TRUE)</span>
<span class="s2">   d=abs(diag(qafd$qr))</span>
<span class="s2">   rank=sum(d &gt; d[1]*1.e-10)</span>
<span class="s2">   qrow=qr(t(afd))</span>
<span class="s2">   rankr=qrow$rank</span>
<span class="s2">   if (rank != rankr)</span>
<span class="s2">      stop_mes(&quot;Weird error: column and row ranks are not equal.&quot;, file=fcerr)</span>
<span class="s2">   </span>
<span class="s2">   irows=qrow$pivot[seq_len(rankr)]</span>
<span class="s2">   if (rank==0) {</span>
<span class="s2">      stop_mes(&quot;Error: No free/dependent flux partition could be made. Stoichiometric matrix has rank=0.&quot;, file=fcerr)</span>
<span class="s2">   }</span>
<span class="s2">   Afl=afd[irows, qafd$pivot[1L:rank], drop=FALSE]</span>
<span class="s2">   ka=kappa(Afl)</span>
<span class="s2">   if (ka &gt; 1.e7) {</span>
<span class="s2">      mes=sprintf(&quot;Error: No working free/dependent flux partition could be proposed. Stoichiometric matrix has condition number </span><span class="si">%g</span><span class="s2">.</span><span class="se">\\</span><span class="s2">n&quot;, ka)</span>
<span class="s2">      stop_mes(mes, file=fcerr)</span>
<span class="s2">   }</span>
<span class="s2">   p2bfl=-as.simple_triplet_matrix(afd[irows, qafd$pivot[-seq_len(rank)], drop=FALSE])</span>
<span class="s2">   c2bfl=c2bfl[irows, , drop=FALSE]</span>
<span class="s2">   g2bfl=g2bfl[irows, , drop=FALSE]</span>
<span class="s2">   cnst2bfl=cnst2bfl[irows]</span>
<span class="s2">   bp=bp[irows]</span>
<span class="s2">   </span>
<span class="s2">   # replace names</span>
<span class="s2">   nm_fl=sub(&quot;f.&quot;, &quot;d.&quot;, colnames(Afl), fixed=TRUE)</span>
<span class="s2">   colnames(Afl)=nm_fl # both net and xch</span>
<span class="s2">   nm_fln=sort(grep(&quot;^d.n.&quot;, nm_fl, v=TRUE))</span>
<span class="s2">   nm_flx=sort(grep(&quot;^d.x.&quot;, nm_fl, v=TRUE))</span>
<span class="s2">   nm_fl=c(nm_fln, nm_flx)</span>
<span class="s2">   Afl=Afl[, nm_fl, drop=FALSE]</span>
<span class="s2">   </span>
<span class="s2">   nm_ff=sub(&quot;d.&quot;, &quot;f.&quot;, colnames(p2bfl), fixed=TRUE) # both net and xch</span>
<span class="s2">   colnames(p2bfl)=nm_ff</span>
<span class="s2">   nm_ffn=sort(grep(&quot;^f.n.&quot;, nm_ff, v=TRUE))</span>
<span class="s2">   nm_ffx=sort(grep(&quot;^f.x.&quot;, nm_ff, v=TRUE))</span>
<span class="s2">   nm_ff=c(nm_ffn, nm_ffx)</span>
<span class="s2">   p2bfl=p2bfl[, nm_ff, drop=FALSE]</span>
<span class="s2">   </span>
<span class="s2">   # re-init param vector</span>
<span class="s2">   if (!fdfit)</span>
<span class="s2">      param=c(runif(length(nm_ff)), if (nb_ff == 0) param else param[-seq_len(nb_ff)])</span>
<span class="s2">   names(param)[seq(along=nm_ff)]=nm_ff</span>
<span class="s2">#browser()</span>
<span class="s2">}</span>
<span class="s2">nm_list$flnx=nm_fl</span>
<span class="s2">nm_fallnx=c(nm_fln, nm_ffn, nm_fcn, nm_fgr, nm_flx, nm_ffx, nm_fcx, sub(&quot;.n.&quot;, &quot;.x.&quot;, nm_fgr, fixed=TRUE))</span>
<span class="s2">nm_list$fallnx=nm_fallnx</span>
<span class="s2">nm_net=c(nm_fln, nm_ffn, nm_fcn)</span>
<span class="s2">names(nm_net)=substring(nm_net, 5)</span>
<span class="s2">nm_xch=c(nm_flx, nm_ffx, nm_fcx)</span>
<span class="s2">names(nm_xch)=substring(nm_xch, 5)</span>
<span class="s2">edge2fl[]=nm_net[substring(edge2fl, 5)]</span>
<span class="s2">nm_list$ff=nm_ff</span>

<span class="s2"># accounting numbers</span>
<span class="s2">nb_flr=nrow(Afl)</span>
<span class="s2">nb_param=length(param)</span>
<span class="s2">nb_ffn=length(nm_ffn)</span>
<span class="s2">nb_ffx=length(nm_ffx)</span>
<span class="s2">nb_ff=nb_ffn+nb_ffx</span>
<span class="s2">nb_fln=length(nm_fln)</span>
<span class="s2">nb_flx=length(nm_flx)</span>
<span class="s2">nb_fl=nb_fln+nb_flx</span>
<span class="s2">nm_par=names(param)</span>

<span class="s2">for (item in c(&quot;nb_fln&quot;, &quot;nb_flx&quot;, &quot;nb_fl&quot;, &quot;nb_ffn&quot;, &quot;nb_ffx&quot;, &quot;nb_ff&quot;)) {</span>
<span class="s2">   nb_f[item]=get(item)</span>
<span class="s2">}</span>
<span class="s2"># translation from n-x to fw-rv</span>
<span class="s2">sh_fwrv=substring(nm_fwrv[1:(nb_fwrv/2)], 5)</span>
<span class="s2">sh_nx=substring(nm_fallnx, 2)</span>
<span class="s2">nb_f$inet2ifwrv=pmatch(paste(&quot;.n.&quot;, sh_fwrv, sep=&quot;&quot;), sh_nx)</span>
<span class="s2">nb_f$ixch2ifwrv=pmatch(paste(&quot;.x.&quot;, sh_fwrv, sep=&quot;&quot;), sh_nx)</span>
<span class="s2">#nb_f$inet2ifwrv=sapply(nm_fwrv[1:(nb_fwrv/2)], function(f) grep(sprintf(&quot;^.</span><span class="se">\\\\</span><span class="s2">.n</span><span class="se">\\\\</span><span class="s2">.</span><span class="si">%s</span><span class="s2">$&quot;, substring(f, 5)), nm_fallnx))</span>
<span class="s2">#nb_f$ixch2ifwrv=sapply(nm_fwrv[1:(nb_fwrv/2)], function(f) grep(sprintf(&quot;^.</span><span class="se">\\\\</span><span class="s2">.x</span><span class="se">\\\\</span><span class="s2">.</span><span class="si">%s</span><span class="s2">$&quot;, substring(f, 5)), nm_fallnx))</span>

<span class="s2">if (TIMEIT) {</span>
<span class="s2">   cat(&quot;Afl qr(): &quot;, format(Sys.time()), &quot; cpu=&quot;, proc.time()[1], &quot;</span><span class="se">\\</span><span class="s2">n&quot;, sep=&quot;&quot;, file=fclog)</span>
<span class="s2">}</span>

<span class="s2">qrAfl=qr(Afl, LAPACK=TRUE)</span>
<span class="s2">d=abs(diag(qrAfl$qr))</span>
<span class="s2">qrAfl$rank=sum(d &gt; d[1]*1.e-10)</span>
<span class="s2">rank=qrAfl$rank</span>
<span class="s2">aful=as.matrix(cbind(Afl, -p2bfl, -c2bfl))</span>
<span class="s2">qrow=qr(t(aful))</span>
<span class="s2">rankr=qrow$rank</span>
<span class="s2">#browser()</span>
<span class="s2"># first check the presence of lindep rows</span>
<span class="s2">if (nrow(Afl) &gt; rankr) {</span>
<span class="s2">   # find list of independent metabs for dependent ones</span>
<span class="s2">   idep=qrow$pivot[(rankr+1):nrow(Afl)]</span>
<span class="s2">   dcoef=qr.solve(t(aful[-idep,,drop=FALSE]), t(aful[idep,,drop=FALSE]))</span>
<span class="s2">   lidep=apply(dcoef, 2, function(v) names(which(abs(v) &gt;= 1.e-10)), simplify=FALSE)</span>
<span class="s2">   prop=sprintf(&quot;***Warning: Among </span><span class="si">%d</span><span class="s2"> equations (rows), </span><span class="si">%d</span><span class="s2"> are redundant.</span><span class="se">\\</span><span class="s2">nThe dependencies are:</span><span class="se">\\</span><span class="s2">n</span><span class="se">\\</span><span class="s2">t&quot;, nrow(Afl), nrow(Afl)-rankr)</span>
<span class="s2">   prop=paste0(prop, paste0(lapply(names(lidep), function(nm) paste0(nm, &quot;: &quot;, paste0(lidep[[nm]], collapse=&quot;, &quot;))), collapse=&quot;</span><span class="se">\\</span><span class="s2">n</span><span class="se">\\</span><span class="s2">t&quot;), &quot;</span><span class="se">\\</span><span class="s2">nThe redundant balances for species &#39;&quot;, paste0(names(lidep), collapse=&quot;&#39;, &#39;&quot;), &quot;&#39; will be ignored.</span><span class="se">\\</span><span class="s2">n&quot;)</span>
<span class="s2">   #browser()</span>
<span class="s2">   cat(prop, file=fclog)</span>
<span class="s2">   Afl=Afl[-idep,,drop=FALSE]</span>
<span class="s2">   rankr=nrow(Afl)</span>
<span class="s2">   qrAfl=qr(Afl, LAPACK=TRUE)</span>
<span class="s2">   d=abs(diag(qrAfl$qr))</span>
<span class="s2">   qrAfl$rank=sum(d &gt; d[1]*1.e-10)</span>
<span class="s2">   rank=qrAfl$rank</span>
<span class="s2">   p2bfl=p2bfl[-idep,,drop=FALSE]</span>
<span class="s2">   c2bfl=c2bfl[-idep,,drop=FALSE]</span>
<span class="s2">   g2bfl=g2bfl[-idep,,drop=FALSE]</span>
<span class="s2">   cnst2bfl=cnst2bfl[-idep]</span>
<span class="s2">   bp=bp[-idep]</span>
<span class="s2">}</span>
<span class="s2">if (nrow(Afl) != rank || nrow(Afl) != ncol(Afl)) {</span>
<span class="s2">   #write.table(Afl)</span>
<span class="s2">   mes=NULL</span>
<span class="s2">   if (nrow(Afl) &lt;= rank) {</span>
<span class="s2">      mes=paste(&quot;Candidate(s) for free or constrained flux(es):</span><span class="se">\\</span><span class="s2">n&quot;,</span>
<span class="s2">         paste(colnames(Afl)[-qrAfl$pivot[1L:nrow(Afl)]], collapse=&quot;</span><span class="se">\\</span><span class="s2">n&quot;),</span>
<span class="s2">         &quot;</span><span class="se">\\</span><span class="s2">nFor this choice, condition number of stoichiometric matrix will be &quot;,</span>
<span class="s2">         kappa(Afl[,qrAfl$pivot[1L:nrow(Afl)],drop=FALSE]), &quot;</span><span class="se">\\</span><span class="s2">n&quot;, sep=&quot;&quot;)</span>
<span class="s2">   } else if (nrow(Afl) &gt; rank) {</span>
<span class="s2">      nextra=nrow(Afl)-rank</span>
<span class="s2">      comb=combn(c(nm_ffn, colnames(Afl)[-qrAfl$pivot[1L:rank]]), nextra)</span>
<span class="s2">      aextra=cbind(Afl[,-qrAfl$pivot[1L:rank],drop=FALSE], -p2bfl)</span>
<span class="s2">      colnames(aextra)=c(colnames(Afl)[-qrAfl$pivot[1L:rank]], colnames(p2bfl))</span>
<span class="s2">      ara=Afl[,qrAfl$pivot[1L:rank],drop=FALSE]</span>
<span class="s2">      i=which.min(apply(comb, 2, function(i) kappa(cbind(ara, aextra[,i]))))[1L]</span>
<span class="s2">      nm_tmp=comb[,i]</span>
<span class="s2">      ka=kappa(cbind(ara, aextra[,nm_tmp]))</span>
<span class="s2">      if (ka &lt; 1.e7) {</span>
<span class="s2">         prop=paste(&quot;Proposal to declare dependent flux(es) is:</span><span class="se">\\</span><span class="s2">n&quot;,</span>
<span class="s2">            paste(nm_tmp, collapse=&quot;</span><span class="se">\\</span><span class="s2">n&quot;), &quot;</span><span class="se">\\</span><span class="s2">n&quot;, sep=&quot;&quot;)</span>
<span class="s2">         if (rank &lt; ncol(Afl)) {</span>
<span class="s2">            prop=prop</span><span class="si">%s</span><span class="s2">+%&quot;While the following dependent flux(es) should be declared free or constrained:</span><span class="se">\\</span><span class="s2">n&quot;</span><span class="si">%s</span><span class="s2">+%join(&quot;</span><span class="se">\\</span><span class="s2">n&quot;, colnames(Afl)[-qrAfl$pivot[1L:rank]])</span><span class="si">%s</span><span class="s2">+%&quot;</span><span class="se">\\</span><span class="s2">n&quot;</span>
<span class="s2">         }</span>
<span class="s2">         prop=paste(prop, &quot;For this choice, condition number of stoichiometric matrix will be &quot;, ka, &quot;</span><span class="se">\\</span><span class="s2">n&quot;, sep=&quot;&quot;)</span>
<span class="s2">      } else {</span>
<span class="s2">         # add constraint fluxes to candidate list</span>
<span class="s2">         if (nb_fcn &gt; 0) {</span>
<span class="s2">            aextra=as.matrix(cbind(Afl[,-qrAfl$pivot[1L:rank],drop=FALSE], -p2bfl, -c2bfl))</span>
<span class="s2">            colnames(aextra)=c(colnames(Afl)[-qrAfl$pivot[1L:rank]], colnames(p2bfl), colnames(c2bfl))</span>
<span class="s2">         }</span>
<span class="s2">         aextended=aful</span>
<span class="s2">         qae=qr(aextended, LAPACK=TRUE)</span>
<span class="s2">         d=abs(diag(qae$qr))</span>
<span class="s2">         ranke=sum(d &gt; d[1L]*1.e-10)</span>
<span class="s2">         if (ranke == nrow(Afl)) {</span>
<span class="s2">            prop=paste(&quot;Proposal to declare dependent flux(es) is:</span><span class="se">\\</span><span class="s2">n&quot;,</span>
<span class="s2">            join(&quot;</span><span class="se">\\</span><span class="s2">n&quot;, colnames(aextended)[qae$pivot[1L:ranke]]), &quot;</span><span class="se">\\</span><span class="s2">n&quot;,</span>
<span class="s2">            &quot;while free and constrained fluxes should be:</span><span class="se">\\</span><span class="s2">n&quot;,</span>
<span class="s2">            join(&quot;</span><span class="se">\\</span><span class="s2">n&quot;, colnames(aextended)[-qae$pivot[1L:ranke]]), &quot;</span><span class="se">\\</span><span class="s2">n&quot;,</span>
<span class="s2">            sep=&quot;&quot;)</span>
<span class="s2">            ka=kappa(aextended[,qae$pivot[1L:ranke]])</span>
<span class="s2">            prop=paste(prop, &quot;For this choice, condition number of stoichiometric matrix will be &quot;, ka, &quot;</span><span class="se">\\</span><span class="s2">n&quot;, sep=&quot;&quot;)</span>
<span class="s2">         } else {</span>
<span class="s2">            prop=&quot;No proposal for partition dependent/free fluxes could be made.</span><span class="se">\\</span><span class="s2">n&quot;</span>
<span class="s2">         }</span>
<span class="s2">      }</span>
<span class="s2">      mes=paste(&quot;There is (are) probably &quot;, nextra,</span>
<span class="s2">         &quot; extra free flux(es) among the following:</span><span class="se">\\</span><span class="s2">n&quot;,</span>
<span class="s2">         paste(nm_ffn, collapse=&quot;</span><span class="se">\\</span><span class="s2">n&quot;), &quot;</span><span class="se">\\</span><span class="s2">n&quot;,</span>
<span class="s2">         prop,</span>
<span class="s2">         sep=&quot;&quot;)</span>
<span class="s2">   }&quot;&quot;&quot;</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">   stop_mes(&quot;Flux matrix is not square or is singular: (&quot;, nrow(Afl), &quot;eq x &quot;, ncol(Afl), &quot;unk)</span><span class="se">\\</span><span class="s2">n&quot;,</span>
<span class="s2">      &quot;You have to change your choice of free fluxes in the &#39;</span><span class="si">%(n_ftbl)s</span><span class="s2">&#39; file.</span><span class="se">\\</span><span class="s2">n&quot;,</span>
<span class="s2">      mes, file=fcerr)</span>
<span class="s2">}</span>

<span class="s2"># make sure that free params choice leads to not singular matrix</span>
<span class="s2">if (qrAfl$rank != nb_fl) {</span>
<span class="s2">   #write.table(Afl)</span>
<span class="s2">   # make a suggestion of new free fluxes</span>
<span class="s2">   A=cbind(Afl, -p2bfl, -c2bfl)</span>
<span class="s2">   colnames(A)=c(colnames(Afl), nm_ff, nm_fc)</span>
<span class="s2">   qa=qr(A, LAPACK=TRUE)</span>
<span class="s2">   d=diag(qa$qr)</span>
<span class="s2">   qa$rank=sum(abs(d)&gt;=abs(d[1]*1.e-10))</span>
<span class="s2">   </span>
<span class="s2">   mes=paste(&quot;Error: Dependent flux matrix is singular.</span><span class="se">\\</span><span class="s2">n&quot;,</span>
<span class="s2">      &quot;Change your partition on free/dependent/constrained fluxes in the &#39;</span><span class="si">%(n_ftbl)s</span><span class="s2">&#39; file.</span><span class="se">\\</span><span class="s2">n&quot;,</span>
<span class="s2">      &quot;Can not resolve dependent fluxe(s):</span><span class="se">\\</span><span class="s2">n&quot;,</span>
<span class="s2">      paste(colnames(Afl)[-qrAfl$pivot[(1:qrAfl$rank)]], collapse=&quot;</span><span class="se">\\</span><span class="s2">n&quot;),</span>
<span class="s2">      sep=&quot;&quot;)</span>
<span class="s2">   if (qa$rank==nb_fl) {</span>
<span class="s2">      mes=paste(mes,</span>
<span class="s2">      &quot;</span><span class="se">\\</span><span class="s2">n</span><span class="se">\\</span><span class="s2">nSuggested dependent fluxes:</span><span class="se">\\</span><span class="s2">n&quot;,</span>
<span class="s2">      paste(colnames(A)[qa$pivot[(1:qa$rank)]], collapse=&quot;</span><span class="se">\\</span><span class="s2">n&quot;),</span>
<span class="s2">      &quot;</span><span class="se">\\</span><span class="s2">n</span><span class="se">\\</span><span class="s2">nWhich would give the following free and constrained fluxes:</span><span class="se">\\</span><span class="s2">n&quot;,</span>
<span class="s2">      paste(colnames(A)[-qa$pivot[(1:qa$rank)]], collapse=&quot;</span><span class="se">\\</span><span class="s2">n&quot;), &quot;</span><span class="se">\\</span><span class="s2">n&quot;,</span>
<span class="s2">      sep=&quot;&quot;)</span>
<span class="s2">   } else {</span>
<span class="s2">      mes=paste(mes, &quot;</span><span class="se">\\</span><span class="s2">nNo suggested free fluxes could be found&quot;, sep=&quot;&quot;)</span>
<span class="s2">   }</span>
<span class="s2">   stop_mes(mes, file=fcerr)</span>
<span class="s2">}</span>

<span class="s2"># inverse flux matrix</span>
<span class="s2">invAfl=solve(qrAfl)</span>
<span class="s2">    &quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">{</span>
        <span class="s2">&quot;n_ftbl&quot;</span><span class="p">:</span> <span class="n">escape</span><span class="p">(</span><span class="n">org</span><span class="o">+</span><span class="s2">&quot;.ftbl&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span><span class="p">),</span>
        <span class="p">})</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">if (fdfit) {</span>
<span class="s2">#browser()</span>
<span class="s2">   # choose free fluxe values such that they fit starting values from ftbl</span>
<span class="s2">   #dep=invAfl</span><span class="si">%*%</span><span class="s2">(p2bfl</span><span class="si">%*%</span><span class="s2">ff+bp)</span>
<span class="s2">   #ff=ff</span>
<span class="s2">   ff=qr.solve(rbind(invAfl</span><span class="si">%s</span><span class="s2">tm%p2bfl, diag(ncol(p2bfl))), c(fl-invAfl</span><span class="si">%*%</span><span class="s2">bp, param))</span>
<span class="s2">}</span>
<span class="s2"># intermediate jacobian</span>
<span class="s2">if (TIMEIT) {</span>
<span class="s2">   cat(&quot;dfl_dffg: &quot;, format(Sys.time()), &quot; cpu=&quot;, proc.time()[1], &quot;</span><span class="se">\\</span><span class="s2">n&quot;, sep=&quot;&quot;, file=fclog)</span>
<span class="s2">}</span>

<span class="s2">dfl_dffg=invAfl</span><span class="si">%s</span><span class="s2">tm%p2bfl</span>
<span class="s2">if (nb_fgr &gt; 0L) {</span>
<span class="s2">   dfl_dffg=cbind(dfl_dffg, invAfl</span><span class="si">%s</span><span class="s2">tm</span><span class="si">%g</span><span class="s2">2bfl)</span>
<span class="s2">}</span>
<span class="s2">dimnames(dfl_dffg)=list(nm_fl, c(nm_ff, nm_fgr))</span>
<span class="s2">dfl_dffg[abs(dfl_dffg) &lt; 1.e-14]=0.</span>
<span class="s2">nb_f$dfl_dffg=as.simple_triplet_matrix(dfl_dffg)</span>

<span class="s2"># prepare mf, md, mc and mg matrices</span>
<span class="s2"># such that mf</span><span class="si">%*%</span><span class="s2">ff+md</span><span class="si">%*%</span><span class="s2">fl+mc</span><span class="si">%*%</span><span class="s2">fc+mg</span><span class="si">%*%</span><span class="s2">fgr gives fallnx</span>
<span class="s2"># here ff free fluxes (param), fl are dependent fluxes, fc are constrained</span>
<span class="s2"># fluxes and fgr are variable growth fluxes</span>
<span class="s2">mf=matrix(0., nb_fallnx, nb_ff)</span>
<span class="s2">dimnames(mf)=list(nm_fallnx, nm_ff)</span>
<span class="s2">md=matrix(0., nb_fallnx, nb_fl)</span>
<span class="s2">dimnames(md)=list(nm_fallnx, nm_fl)</span>
<span class="s2">mc=matrix(0., nb_fallnx, nb_fc)</span>
<span class="s2">dimnames(mc)=list(nm_fallnx, nm_fc)</span>
<span class="s2">mg=matrix(0., nb_fallnx, nb_fgr)</span>
<span class="s2">dimnames(mg)=list(nm_fallnx, nm_fgr)</span>

<span class="s2">if (nb_ff &gt; 0) {</span>
<span class="s2">   mf[nm_ff, nm_ff]=diag(1., nb_ff)</span>
<span class="s2">}</span>
<span class="s2">if (nb_fl &gt; 0) {</span>
<span class="s2">   md[nm_fl, nm_fl]=diag(1., nb_fl)</span>
<span class="s2">}</span>
<span class="s2">if (nb_fc &gt; 0) {</span>
<span class="s2">   mc[nm_fc, nm_fc]=diag(1., nb_fc)</span>
<span class="s2">}</span>
<span class="s2">if (nb_fgr &gt; 0) {</span>
<span class="s2">   mg[nm_fgr, nm_fgr]=diag(1., nb_fgr)</span>
<span class="s2">}</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;fwrv2i&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">fwrv2i</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;tfallnx&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">tfallnx</span></div>


<div class="viewcode-block" id="netan2R_meas">
<a class="viewcode-back" href="../progdoc.html#ftbl2code.netan2R_meas">[docs]</a>
<span class="k">def</span> <span class="nf">netan2R_meas</span><span class="p">(</span><span class="n">netan</span><span class="p">,</span> <span class="n">org</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">emu</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;netan2R_meas(netan, org, f)</span>
<span class="sd">    generate code for measure treatment</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># prepare python measures</span>
    <span class="k">if</span> <span class="s2">&quot;measures&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">:</span>
        <span class="c1">#print(&quot;Calculate measures in netan2R_meas.&quot;)</span>
        <span class="n">measures</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">meas</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;label&quot;</span><span class="p">,</span> <span class="s2">&quot;mass&quot;</span><span class="p">,</span> <span class="s2">&quot;peak&quot;</span><span class="p">):</span>
            <span class="n">measures</span><span class="p">[</span><span class="n">meas</span><span class="p">]</span><span class="o">=</span><span class="nb">eval</span><span class="p">(</span><span class="s2">&quot;C13_ftbl.</span><span class="si">%s</span><span class="s2">_meas2matrix_vec_dev(netan)&quot;</span><span class="o">%</span><span class="n">meas</span><span class="p">)</span>
        <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;measures&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">measures</span>
    <span class="n">measures</span><span class="o">=</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;measures&quot;</span><span class="p">]</span>
    <span class="n">nexp</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;iso_input&quot;</span><span class="p">])</span>
    <span class="c1">#aff(&quot;got measures in netan2R_meas&quot;, measures);##</span>
    <span class="c1"># get scaling factors and their indexes, measure matrices, and measured cumomer value vector</span>
    <span class="n">scale</span><span class="o">=</span><span class="p">[{</span><span class="s2">&quot;label&quot;</span><span class="p">:</span> <span class="p">{},</span> <span class="s2">&quot;mass&quot;</span><span class="p">:</span> <span class="p">{},</span> <span class="s2">&quot;peak&quot;</span><span class="p">:</span> <span class="p">{}}</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nexp</span><span class="p">)]</span> <span class="c1"># for unique scale names</span>
    <span class="n">nrow</span><span class="o">=</span><span class="p">[{</span><span class="s2">&quot;label&quot;</span><span class="p">:</span> <span class="p">{},</span> <span class="s2">&quot;mass&quot;</span><span class="p">:</span> <span class="p">{},</span> <span class="s2">&quot;peak&quot;</span><span class="p">:</span> <span class="p">{}}</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nexp</span><span class="p">)]</span> <span class="c1"># for counting scale names</span>
    <span class="n">o_sc</span><span class="o">=</span><span class="p">[{</span><span class="s2">&quot;label&quot;</span><span class="p">:</span> <span class="p">{},</span> <span class="s2">&quot;mass&quot;</span><span class="p">:</span> <span class="p">{},</span> <span class="s2">&quot;peak&quot;</span><span class="p">:</span> <span class="p">{}}</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nexp</span><span class="p">)]</span> <span class="c1"># for ordered unique scale names</span>
    <span class="n">o_meas</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">measures</span><span class="o">.</span><span class="n">keys</span><span class="p">());</span> <span class="c1"># ordered measure types</span>
    <span class="n">o_meas</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

    <span class="n">ir2isc</span><span class="o">=</span><span class="p">[{</span><span class="s2">&quot;label&quot;</span><span class="p">:</span> <span class="p">[],</span> <span class="s2">&quot;mass&quot;</span><span class="p">:</span> <span class="p">[],</span> <span class="s2">&quot;peak&quot;</span><span class="p">:</span> <span class="p">[]}</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nexp</span><span class="p">)]</span> <span class="c1"># for mapping measure rows indexes on scale index</span>
    <span class="c1"># we want to use it in python like isc[ili][meas]=ir2isc[ili][meas][ir]</span>
    <span class="k">for</span> <span class="n">meas</span> <span class="ow">in</span> <span class="n">o_meas</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">ili</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nexp</span><span class="p">):</span>
            <span class="c1"># get unique scaling factors</span>
            <span class="c1"># and count rows in each group</span>
            <span class="c1"># row[&quot;scale&quot;] is &quot;metab;group&quot; (metab name may be fake here)</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">row</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">measures</span><span class="p">[</span><span class="n">meas</span><span class="p">][</span><span class="n">ili</span><span class="p">][</span><span class="s2">&quot;mat&quot;</span><span class="p">]):</span>
                <span class="n">scale</span><span class="p">[</span><span class="n">ili</span><span class="p">][</span><span class="n">meas</span><span class="p">][</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;scale&quot;</span><span class="p">]]</span><span class="o">=</span><span class="mf">0.</span>
                <span class="n">nrow</span><span class="p">[</span><span class="n">ili</span><span class="p">][</span><span class="n">meas</span><span class="p">][</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;scale&quot;</span><span class="p">]]</span><span class="o">=</span><span class="n">nrow</span><span class="p">[</span><span class="n">ili</span><span class="p">][</span><span class="n">meas</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;scale&quot;</span><span class="p">],</span><span class="mf">0.</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
            <span class="c1"># remove groups having only one measure in them</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">n</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">nrow</span><span class="p">[</span><span class="n">ili</span><span class="p">][</span><span class="n">meas</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                <span class="k">if</span> <span class="n">n</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">:</span>
                    <span class="k">del</span><span class="p">(</span><span class="n">scale</span><span class="p">[</span><span class="n">ili</span><span class="p">][</span><span class="n">meas</span><span class="p">][</span><span class="n">k</span><span class="p">])</span>
            <span class="c1"># order scaling factor</span>
            <span class="n">o_sc</span><span class="p">[</span><span class="n">ili</span><span class="p">][</span><span class="n">meas</span><span class="p">]</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">scale</span><span class="p">[</span><span class="n">ili</span><span class="p">][</span><span class="n">meas</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="n">o_sc</span><span class="p">[</span><span class="n">ili</span><span class="p">][</span><span class="n">meas</span><span class="p">]</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
            <span class="c1"># map a measure rows (card:n) on corresponding scaling factor (card:1)</span>
            <span class="c1"># if a row has not scale factor it is scaled with factor 1</span>
            <span class="c1"># vector having scaling parameters is formed like</span>
            <span class="c1"># c(1,param)</span>
            <span class="n">ir2isc</span><span class="p">[</span><span class="n">ili</span><span class="p">][</span><span class="n">meas</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">measures</span><span class="p">[</span><span class="n">meas</span><span class="p">][</span><span class="n">ili</span><span class="p">][</span><span class="s2">&quot;mat&quot;</span><span class="p">])</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">row</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">measures</span><span class="p">[</span><span class="n">meas</span><span class="p">][</span><span class="n">ili</span><span class="p">][</span><span class="s2">&quot;mat&quot;</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;scale&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">scale</span><span class="p">[</span><span class="n">ili</span><span class="p">][</span><span class="n">meas</span><span class="p">]:</span>
                    <span class="n">ir2isc</span><span class="p">[</span><span class="n">ili</span><span class="p">][</span><span class="n">meas</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">o_sc</span><span class="p">[</span><span class="n">ili</span><span class="p">][</span><span class="n">meas</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;scale&quot;</span><span class="p">])</span>
    
            <span class="c1"># measured value vector is in measures[meas][&quot;vec&quot;]</span>
            <span class="c1"># measured dev vector is in measures[meas][&quot;dev&quot;]</span>

    <span class="c1"># create R equivalent structures with indices for scaling</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">if (TIMEIT) {</span>
<span class="s2">   cat(&quot;measure : &quot;, format(Sys.time()), &quot; cpu=&quot;, proc.time()[1], &quot;</span><span class="se">\\</span><span class="s2">n&quot;, sep=&quot;&quot;, file=fclog)</span>
<span class="s2">}</span>
<span class="s2">if (!noscale) {</span>
<span class="s2">   # make place for scaling factors</span>
<span class="s2">   nb_sc=vector(&quot;integer&quot;, </span><span class="si">%d</span><span class="s2">)</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="o">%</span><span class="n">nexp</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ili</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nexp</span><span class="p">):</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;# experiment: </span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">ili</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">meas</span> <span class="ow">in</span> <span class="n">o_meas</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">o_sc</span><span class="p">[</span><span class="n">ili</span><span class="p">][</span><span class="n">meas</span><span class="p">]:</span>
                <span class="k">continue</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">   # </span><span class="si">%(meas)s</span>
<span class="s2">   # initial values for scales are set later</span>
<span class="s2">   param=c(param,</span><span class="si">%(sc)s</span><span class="s2">)</span>
<span class="s2">   nm_par=c(nm_par,c(</span><span class="si">%(sc_names)s</span><span class="s2">))</span>
<span class="s2">   names(param)=nm_par</span>
<span class="s2">            &quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">{</span>
                <span class="s2">&quot;meas&quot;</span><span class="p">:</span> <span class="n">meas</span><span class="p">,</span>
                <span class="s2">&quot;sc&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;1&quot;</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">o_sc</span><span class="p">[</span><span class="n">ili</span><span class="p">][</span><span class="n">meas</span><span class="p">]),</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">),</span>
                <span class="s2">&quot;sc_names&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="n">o_sc</span><span class="p">[</span><span class="n">ili</span><span class="p">][</span><span class="n">meas</span><span class="p">],</span> <span class="s1">&#39;&quot;&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">ili</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;:&quot;</span><span class="o">+</span><span class="n">meas</span><span class="o">+</span><span class="s1">&#39;;&#39;</span><span class="p">,</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">),</span>
                <span class="p">})</span>

        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">   nb_param=length(param)</span>
<span class="s2">   nb_sc[</span><span class="si">%d</span><span class="s2">]=nb_param-nb_ff # at this moment it is cumulated sum. diff() is taken later</span>
<span class="s2">&quot;&quot;&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">ili</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">   # indices mapping from scaling to measure matrix row</span>
<span class="s2">   # c(1,par)[ir2isc[[iexp]]] replicates scale parameters</span>
<span class="s2">   # for corresponding rows of measure matrix</span>
<span class="s2">   ir2isc=vector(&quot;list&quot;, </span><span class="si">%d</span><span class="s2">)</span>
<span class="s2">&quot;&quot;&quot;</span><span class="o">%</span><span class="n">nexp</span><span class="p">)</span>
    <span class="c1">#base_isc=2+len(netan[&quot;flux_free&quot;][&quot;net&quot;])+len(netan[&quot;flux_free&quot;][&quot;xch&quot;])</span>
    <span class="n">base_isc</span><span class="o">=</span><span class="mi">2</span> <span class="c1"># the shift by nb_ff is made in R because ffguess can make vary nb_ff in runtime</span>
    <span class="c1">#pdb.set_trace()</span>
    <span class="k">for</span> <span class="n">ili</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nexp</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">meas</span> <span class="ow">in</span> <span class="n">o_meas</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">ir2isc</span><span class="p">[</span><span class="n">ili</span><span class="p">][</span><span class="n">meas</span><span class="p">]:</span>
                <span class="k">continue</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">   # </span><span class="si">%(iexp)d</span><span class="s2">:</span><span class="si">%(meas)s</span>
<span class="s2">   ir2isc[[</span><span class="si">%(iexp)d</span><span class="s2">]]=c(ir2isc[[</span><span class="si">%(iexp)d</span><span class="s2">]],c(</span><span class="si">%(ir2isc)s</span><span class="s2">))</span>
<span class="s2">&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">{</span>
        <span class="s2">&quot;iexp&quot;</span><span class="p">:</span> <span class="n">ili</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
        <span class="s2">&quot;meas&quot;</span><span class="p">:</span> <span class="n">meas</span><span class="p">,</span>
        <span class="s2">&quot;ir2isc&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="p">((</span><span class="nb">str</span><span class="p">(</span><span class="n">ir2isc</span><span class="p">[</span><span class="n">ili</span><span class="p">][</span><span class="n">meas</span><span class="p">][</span><span class="n">ir</span><span class="p">]</span><span class="o">+</span><span class="n">base_isc</span><span class="p">)</span> <span class="k">if</span> <span class="n">ir2isc</span><span class="p">[</span><span class="n">ili</span><span class="p">][</span><span class="n">meas</span><span class="p">][</span><span class="n">ir</span><span class="p">]</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">ir</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ir2isc</span><span class="p">[</span><span class="n">ili</span><span class="p">][</span><span class="n">meas</span><span class="p">]))),</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">)</span>
        <span class="p">})</span>
            <span class="n">base_isc</span><span class="o">=</span><span class="n">base_isc</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">scale</span><span class="p">[</span><span class="n">ili</span><span class="p">][</span><span class="n">meas</span><span class="p">])</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">   if (!is.null(ir2isc[[</span><span class="si">%(iexp)d</span><span class="s2">]])) {</span>
<span class="s2">      isc=ir2isc[[</span><span class="si">%(iexp)d</span><span class="s2">]] != 1</span>
<span class="s2">      ir2isc[[</span><span class="si">%(iexp)d</span><span class="s2">]][isc]=ir2isc[[</span><span class="si">%(iexp)d</span><span class="s2">]][isc]+nb_ff</span>
<span class="s2">   }</span>
<span class="s2">&quot;&quot;&quot;</span><span class="o">%</span><span class="p">{</span><span class="s2">&quot;iexp&quot;</span><span class="p">:</span> <span class="n">ili</span><span class="o">+</span><span class="mi">1</span><span class="p">})</span>

    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">   # cumulated base for nb_sc</span>
<span class="s2">   nb_sc_base=c(0, nb_sc[-nb_exp])</span>
<span class="s2">   nb_sc=diff(c(0, nb_sc))</span>
<span class="s2">   nb_sc_tot=sum(nb_sc)</span>
<span class="s2">   nb_f$nb_sc=nb_sc</span>
<span class="s2">   nb_f$nb_sc_tot=nb_sc_tot</span>
<span class="s2">   nb_f$nb_sc_base=nb_sc_base</span>
<span class="s2">#browser()</span>
<span class="s2">} else {</span>
<span class="s2">   # no scaling</span>
<span class="s2">   ir2isc=list()</span>
<span class="s2">   nb_sc=integer(nb_exp)</span>
<span class="s2">   nb_sc_tot=0</span>
<span class="s2">}</span>
<span class="s2">nb_f$nb_sc=nb_sc</span>
<span class="s2">nb_f$nb_sc_tot=nb_sc_tot</span>
<span class="s2">nm_list$par=nm_par</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>
    <span class="c1"># get the full dict of non zero cumomers involved in measures</span>
    <span class="c1"># cumo=metab:icumo where icumo is in [1;2^Clen]</span>
    <span class="c1"># or emu=metab:ifrag+Mi</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2"># make a list of sparse measurement matrices</span>
<span class="s2"># measmat*xr+memaone gives a vector of simulated not-yet-pooled and not-yet-scaled measurements</span>
<span class="s2"># all but 0. Coefficients of 0-cumomers (by defenition equal to 1)</span>
<span class="s2"># are all regrouped in the memaone.</span>
<span class="s2">nm_measmat=nm_meas=nb_meas=nb_measmat=measmat=memaone=measvec=measdev=ipooled=vector(&quot;list&quot;, </span><span class="si">%d</span><span class="s2">)</span>
<span class="s2">&quot;&quot;&quot;</span><span class="o">%</span><span class="n">nexp</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ili</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nexp</span><span class="p">):</span>
        <span class="n">meas_cumos</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">meas</span> <span class="ow">in</span> <span class="n">o_meas</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">measures</span><span class="p">[</span><span class="n">meas</span><span class="p">][</span><span class="n">ili</span><span class="p">][</span><span class="s2">&quot;mat&quot;</span><span class="p">]:</span>
                <span class="n">metab</span><span class="o">=</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;metab&quot;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">emu</span><span class="p">:</span>
                    <span class="n">meas_cumos</span><span class="o">.</span><span class="n">update</span><span class="p">((</span><span class="n">metab</span><span class="o">+</span><span class="s2">&quot;:&quot;</span><span class="o">+</span><span class="n">i</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;emuco&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">meas_cumos</span><span class="o">.</span><span class="n">update</span><span class="p">((</span><span class="n">metab</span><span class="o">+</span><span class="s2">&quot;:&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">icumo</span><span class="p">),</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">icumo</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;coefs&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="k">if</span> <span class="n">icumo</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># order involved cumomers (emu)</span>
        <span class="n">o_mcumos</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">meas_cumos</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">o_mcumos</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">imcumo2i</span><span class="o">=</span><span class="nb">dict</span><span class="p">((</span><span class="n">cumo</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">cumo</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">o_mcumos</span><span class="p">))</span>
        <span class="n">nb_mcumo</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">o_mcumos</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">nm_measmat[[</span><span class="si">%(ili)d</span><span class="s2">]]=c(</span><span class="si">%(idmeasmat)s</span><span class="s2">)</span>
<span class="s2">if (length(nm_measmat[[</span><span class="si">%(ili)d</span><span class="s2">]]) == 0)</span>
<span class="s2">   stop_mes(&quot;At least one labeling measurement must be given in experiment &#39;&quot;, nm_exp[</span><span class="si">%(ili)d</span><span class="s2">], &quot;&#39;&quot;, file=fcerr)</span>
<span class="s2">nm_meas[[</span><span class="si">%(ili)d</span><span class="s2">]]=c(</span><span class="si">%(idmeas)s</span><span class="s2">)</span>
<span class="s2">nb_meas[[</span><span class="si">%(ili)d</span><span class="s2">]]=length(nm_meas[[</span><span class="si">%(ili)d</span><span class="s2">]])</span>
<span class="s2">nb_measmat[[</span><span class="si">%(ili)d</span><span class="s2">]]=length(nm_measmat[[</span><span class="si">%(ili)d</span><span class="s2">]])</span>
<span class="s2">measmat[[</span><span class="si">%(ili)d</span><span class="s2">]]=simple_triplet_zero_matrix(nrow=nb_measmat[[</span><span class="si">%(ili)d</span><span class="s2">]], ncol=</span><span class="si">%(ncol)d</span><span class="s2">)</span>
<span class="s2">dimnames(measmat[[</span><span class="si">%(ili)d</span><span class="s2">]])=list(nm_measmat[[</span><span class="si">%(ili)d</span><span class="s2">]], nm_x)</span>
<span class="s2">memaone[[</span><span class="si">%(ili)d</span><span class="s2">]]=numeric(nb_measmat[[</span><span class="si">%(ili)d</span><span class="s2">]])</span>
<span class="s2">measvec[[</span><span class="si">%(ili)d</span><span class="s2">]]=c(</span><span class="si">%(vmeas)s</span><span class="s2">)</span>
<span class="s2">measdev[[</span><span class="si">%(ili)d</span><span class="s2">]]=c(</span><span class="si">%(dev)s</span><span class="s2">)</span>
<span class="s2">names(measvec[[</span><span class="si">%(ili)d</span><span class="s2">]])=nm_meas[[</span><span class="si">%(ili)d</span><span class="s2">]]</span>
<span class="s2">names(measdev[[</span><span class="si">%(ili)d</span><span class="s2">]])=nm_meas[[</span><span class="si">%(ili)d</span><span class="s2">]]</span>
<span class="s2">ipooled[[</span><span class="si">%(ili)d</span><span class="s2">]]=list(ishort=pmatch(nm_meas[[</span><span class="si">%(ili)d</span><span class="s2">]], nm_measmat[[</span><span class="si">%(ili)d</span><span class="s2">]]))</span>
<span class="s2">&quot;&quot;&quot;</span><span class="o">%</span><span class="p">{</span>
    <span class="s2">&quot;ili&quot;</span><span class="p">:</span> <span class="n">ili</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
    <span class="s2">&quot;nrow&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">([</span><span class="n">measures</span><span class="p">[</span><span class="n">meas</span><span class="p">][</span><span class="n">ili</span><span class="p">][</span><span class="s2">&quot;vec&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">meas</span> <span class="ow">in</span> <span class="n">measures</span><span class="p">]),</span>
    <span class="s2">&quot;ncol&quot;</span><span class="p">:</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vemu&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="n">emu</span> <span class="k">else</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vrcumo&quot;</span><span class="p">])),</span>
    <span class="s2">&quot;idmeasmat&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span>
        <span class="n">valval</span><span class="p">(</span><span class="n">measures</span><span class="p">[</span><span class="n">o</span><span class="p">][</span><span class="n">ili</span><span class="p">][</span><span class="s2">&quot;mat&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">o_meas</span><span class="p">)),</span>
        <span class="n">p</span><span class="o">=</span><span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">),</span>
    <span class="s2">&quot;idmeas&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span>  <span class="n">valval</span><span class="p">([</span><span class="n">v</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">o_meas</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">measures</span><span class="p">[</span><span class="n">o</span><span class="p">][</span><span class="n">ili</span><span class="p">][</span><span class="s2">&quot;ids&quot;</span><span class="p">]]),</span> <span class="n">p</span><span class="o">=</span><span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">),</span>
    <span class="s2">&quot;vmeas&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="n">valval</span><span class="p">(</span><span class="n">measures</span><span class="p">[</span><span class="n">o</span><span class="p">][</span><span class="n">ili</span><span class="p">][</span><span class="s2">&quot;vec&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">o_meas</span><span class="p">),</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;nan&quot;</span><span class="p">,</span> <span class="s2">&quot;NA&quot;</span><span class="p">),</span>
    <span class="s2">&quot;dev&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">sd</span> <span class="k">for</span> <span class="n">sd</span> <span class="ow">in</span> <span class="n">valval</span><span class="p">(</span><span class="n">measures</span><span class="p">[</span><span class="n">o</span><span class="p">][</span><span class="n">ili</span><span class="p">][</span><span class="s2">&quot;dev&quot;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">o_meas</span><span class="p">)),</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">),</span>
    <span class="p">})</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">nm_meas_tot=unlist(nm_meas)</span>
<span class="s2">nb_meas=unlist(nb_meas)</span>
<span class="s2">nb_meas_cumo=c(0., cumsum(nb_meas[-nb_exp]))</span>
<span class="s2">iexp_meas=lapply(seq_len(nb_exp), function(iexp) seq_len(nb_meas[iexp])+nb_meas_cumo[iexp])</span>
<span class="s2">nm_list$meas=nm_meas</span>
<span class="s2">nm_list$measmat=nm_measmat</span>
<span class="s2">nm_list$meas_tot=nm_meas_tot</span>
<span class="s2">nb_f$nb_meas=nb_meas</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="c1"># get coeffs in the order above with their corresponding indices from total cumomer vector</span>
    <span class="k">for</span> <span class="n">ili</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nexp</span><span class="p">):</span>
        <span class="n">base_pooled</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">for</span> <span class="n">meas</span> <span class="ow">in</span> <span class="n">o_meas</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">measures</span><span class="p">[</span><span class="n">meas</span><span class="p">][</span><span class="n">ili</span><span class="p">][</span><span class="s2">&quot;mat&quot;</span><span class="p">]:</span>
                <span class="k">continue</span>
            <span class="c1">#print(&quot;meas=&quot;+meas+&quot;; mat=&quot;+str(measures[meas][&quot;mat&quot;]));##</span>
            <span class="k">for</span> <span class="n">metpool</span> <span class="ow">in</span> <span class="n">measures</span><span class="p">[</span><span class="n">meas</span><span class="p">][</span><span class="n">ili</span><span class="p">][</span><span class="s2">&quot;pooled&quot;</span><span class="p">]:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2"># prepare indices of pooled measurements</span>
<span class="s2">ipooled[[</span><span class="si">%(ili)d</span><span class="s2">]][[&quot;</span><span class="si">%(rowid)s</span><span class="s2">&quot;]]=1+</span><span class="si">%(basep)d</span><span class="s2">+c(</span><span class="si">%(ind)s</span><span class="s2">)</span>
<span class="s2">                &quot;&quot;&quot;</span><span class="o">%</span><span class="p">{</span>
                    <span class="s2">&quot;ili&quot;</span><span class="p">:</span> <span class="n">ili</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
                    <span class="s2">&quot;rowid&quot;</span><span class="p">:</span> <span class="n">metpool</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="s2">&quot;ind&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="n">metpool</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">),</span>
                    <span class="s2">&quot;basep&quot;</span><span class="p">:</span> <span class="n">base_pooled</span><span class="p">,</span>
                    <span class="p">}</span>
                <span class="p">)</span>
            <span class="n">base_pooled</span><span class="o">=</span><span class="n">base_pooled</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">measures</span><span class="p">[</span><span class="n">meas</span><span class="p">][</span><span class="n">ili</span><span class="p">][</span><span class="s2">&quot;vec&quot;</span><span class="p">])</span><span class="o">+</span><span class="nb">sum</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">measures</span><span class="p">[</span><span class="n">meas</span><span class="p">][</span><span class="n">ili</span><span class="p">][</span><span class="s2">&quot;pooled&quot;</span><span class="p">])</span>
    <span class="c1"># preepare measmat indexes and values : ir, ic, val</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">names(measvec)=names(measdev)=nm_exp</span>

<span class="s2">if (!noscale) {</span>
<span class="s2">   for (iexp in seq_len(nb_exp))</span>
<span class="s2">      if (length(ipooled[[iexp]]$ishort))</span>
<span class="s2">         ir2isc[[iexp]]=ir2isc[[iexp]][ipooled[[iexp]]$ishort]</span>

<span class="s2">   # prepare indexes of dispatching scale params in jacobian</span>
<span class="s2">   if (nb_sc_tot &gt; 0) {</span>
<span class="s2">      nb_f$is2m=vector(&quot;list&quot;, nb_exp)</span>
<span class="s2">      for (iexp in seq_len(nb_exp)) {</span>
<span class="s2">         ipaire=matrix(0, nrow=0, ncol=2)</span>
<span class="s2">         tmp=lapply(seq_len(nb_sc[[iexp]]), function(isc) {</span>
<span class="s2">            i=which(ir2isc[[iexp]]==isc+nb_sc_base[iexp]+1+nb_ff)</span>
<span class="s2">            ipaire &lt;&lt;- rbind(ipaire, cbind(i, isc+nb_sc_base[iexp]))</span>
<span class="s2">            return(NULL)</span>
<span class="s2">         })</span>
<span class="s2">         nb_f$is2m[[iexp]]=ipaire</span>
<span class="s2">         # place holder for scale part of jacobian</span>
<span class="s2">         jx_f$dr_dsc[[iexp]]=simple_triplet_zero_matrix(nrow=length(ir2isc[[iexp]]), ncol=nb_sc_tot)</span>
<span class="s2">      }</span>
<span class="s2">   }</span>
<span class="s2">}</span>
<span class="s2"># prepare measmat indexes and values : ir, ic, val</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>
    <span class="n">lab2i0</span><span class="o">=</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;emu2i0&quot;</span> <span class="k">if</span> <span class="n">emu</span> <span class="k">else</span> <span class="s2">&quot;rcumo2i0&quot;</span><span class="p">]</span>
    <span class="n">onelab</span><span class="o">=</span><span class="s2">&quot;0+0&quot;</span> <span class="k">if</span> <span class="n">emu</span> <span class="k">else</span> <span class="mi">0</span>
    <span class="n">fcoef</span><span class="o">=</span><span class="s2">&quot;emuco&quot;</span> <span class="k">if</span> <span class="n">emu</span> <span class="k">else</span> <span class="s2">&quot;coefs&quot;</span>
    <span class="k">for</span> <span class="n">ili</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nexp</span><span class="p">):</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">ind_mema=matrix(c(</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>
        <span class="n">i</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">for</span> <span class="n">meas</span> <span class="ow">in</span> <span class="n">o_meas</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">measures</span><span class="p">[</span><span class="n">meas</span><span class="p">][</span><span class="n">ili</span><span class="p">][</span><span class="s2">&quot;mat&quot;</span><span class="p">]:</span>
                <span class="k">continue</span>
            <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">measures</span><span class="p">[</span><span class="n">meas</span><span class="p">][</span><span class="n">ili</span><span class="p">][</span><span class="s2">&quot;mat&quot;</span><span class="p">]:</span>
                <span class="n">i</span><span class="o">+=</span><span class="mi">1</span>
                <span class="n">metab</span><span class="o">=</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;metab&quot;</span><span class="p">]</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span><span class="si">%(iricval)s</span><span class="s2">,</span>
<span class="s2">                    &quot;&quot;&quot;</span><span class="o">%</span><span class="p">{</span>
                        <span class="s2">&quot;iricval&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="n">valval</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">lab2i0</span><span class="p">[</span><span class="n">metab</span><span class="o">+</span><span class="s2">&quot;:&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                            <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">row</span><span class="p">[</span><span class="n">fcoef</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="n">onelab</span><span class="p">),</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">)</span>
                    <span class="p">})</span>

        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">NULL), ncol=3, byrow=TRUE); # close ind_mema creation</span>
<span class="s2">measmat[[</span><span class="si">%(iexp)d</span><span class="s2">]][ind_mema[,1:2,drop=FALSE]]=ind_mema[,3]</span>
<span class="s2">memaone[[</span><span class="si">%(iexp)d</span><span class="s2">]]=c(</span><span class="si">%(memaone)s</span><span class="s2">)</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="o">%</span><span class="p">{</span>
            <span class="s2">&quot;iexp&quot;</span><span class="p">:</span> <span class="n">ili</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
            <span class="s2">&quot;memaone&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">fcoef</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">onelab</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">meas</span> <span class="ow">in</span> <span class="n">o_meas</span>
                <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">measures</span><span class="p">[</span><span class="n">meas</span><span class="p">][</span><span class="n">ili</span><span class="p">][</span><span class="s2">&quot;mat&quot;</span><span class="p">]),</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">),</span>
        <span class="p">})</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">pwe=ipwe=ip2ipwe=pool_factor=ijpwef=dp_ones=meas2sum=dpw_dpf=ipf_in_ppw=vector(&quot;list&quot;, nb_exp)</span>
<span class="s2">mets_in_res=vector(&quot;list&quot;, nb_exp)</span>
<span class="s2">for (iexp in seq_len(nb_exp)) {</span>
<span class="s2">   names(memaone[[iexp]])=nm_measmat[[iexp]]</span>

<span class="s2">   # prepare weights of label data for pooled metabs</span>
<span class="s2">   # prepare ipwe and ip2ipwe such that pwe[ipwe]=pool[ip2ipwe]</span>
<span class="s2">   # gives a good base for weight sum and normalization</span>
<span class="s2">   pwe[[iexp]]=double(nb_measmat[[iexp]])+1.</span>
<span class="s2">   mets_in_res[[iexp]]=sapply(nm_measmat[[iexp]], function(m) strsplit(m, &quot;:&quot;)[[1L]][2L])</span>
<span class="s2">   for (po in names(ipooled[[iexp]])) {</span>
<span class="s2">      if (po == &quot;ishort&quot;) next</span>
<span class="s2">      nm_sum=strsplit(po, &quot;:&quot;)[[1L]][2L]</span>
<span class="s2">      mets=trimws(strsplit(nm_sum, &quot;\\+&quot;)[[1L]])</span>
<span class="s2">      irpo=ipooled[[iexp]][[po]]</span>
<span class="s2">      ipwe[[iexp]]=c(ipwe[[iexp]], irpo) # where weighting is</span>
<span class="s2">      i=pmatch(mets, names(nm_poolf))</span>
<span class="s2">      if (any(!is.na(i))) {</span>
<span class="s2">         for (ir in i) {</span>
<span class="s2">            if (is.na(ir)) next</span>
<span class="s2">            ijpwef[[iexp]]=rbind(ijpwef[[iexp]], cbind(irpo, ir)) # where free pools matter</span>
<span class="s2">         }</span>
<span class="s2">      }</span>
<span class="s2">      ip2ipwe[[iexp]]=c(ip2ipwe[[iexp]], pmatch(mets, names(nm_poolall)))</span>
<span class="s2">      mets_in_res[[iexp]][irpo]=mets</span>
<span class="s2">   }</span>
<span class="s2">   # order ijpwef for sparse matrix ordering</span>
<span class="s2">   if (!is.null(ijpwef[[iexp]])) {</span>
<span class="s2">      o=order(ijpwef[[iexp]][,2L], ijpwef[[iexp]][,1L])</span>
<span class="s2">      ijpwef[[iexp]]=ijpwef[[iexp]][o,,drop=FALSE]</span>
<span class="s2">   }</span>
<span class="s2">   pool_factor[[iexp]]=as.factor(nm_measmat[[iexp]])</span>
<span class="s2">   # free pool in principal pool weight</span>
<span class="s2">   ipf_in_ppw[[iexp]]=apply(outer(mets_in_res[[iexp]], names(nm_poolf), &quot;==&quot;), 1, function(v) if(length(w &lt;-which(v))) w else NA)</span>
<span class="s2">   ipf_in_ppw[[iexp]][is.na(ipf_in_ppw[[iexp]])]=0L</span>
<span class="s2">   dp_ones[[iexp]]=matrix(0., nb_measmat[[iexp]], nb_poolf)</span>
<span class="s2">   dp_ones[[iexp]][cbind(ipwe[[iexp]], ipf_in_ppw[[iexp]][ipwe[[iexp]]])]=1.</span>
<span class="s2">   </span>
<span class="s2">   # matrix for summing weighted measurements</span>
<span class="s2">   meas2sum[[iexp]]=simple_triplet_zero_matrix(length(ipooled[[iexp]]$ishort), nb_measmat[[iexp]])</span>
<span class="s2">   meas2sum[[iexp]][cbind(pmatch(nm_measmat[[iexp]], nm_measmat[[iexp]][ipooled[[iexp]]$ishort], dup=TRUE),       seq_len(nb_measmat[[iexp]]))]=1.</span>
<span class="s2">   dimnames(meas2sum[[iexp]])=list(nm_meas[[iexp]], nm_measmat[[iexp]])</span>
<span class="s2">   </span>
<span class="s2">   # dpw_dpf - matrix for derivation of pool weights by free pools</span>
<span class="s2">   if (nb_poolf &gt; 0L &amp;&amp; length(ijpwef[[iexp]]) &gt; 0) {</span>
<span class="s2">      # indeed, we&#39;ll have to do weight derivation by free pools</span>
<span class="s2">      dpw_dpf[[iexp]]=simple_triplet_zero_matrix(nb_measmat[[iexp]], nb_poolf)</span>
<span class="s2">      dpw_dpf[[iexp]][ijpwef[[iexp]]]=1.</span>
<span class="s2">   }</span>
<span class="s2">}</span>

<span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2"># prepare flux measurements</span>
<span class="s2">nm_fmn=nm_net[c(</span><span class="si">%(nm_fmn)s</span><span class="s2">)]</span>
<span class="s2">nm_list$fmn=nm_fmn</span>
<span class="s2">nb_fmn=length(nm_fmn)</span>
<span class="s2">nb_f$nb_fmn=nb_fmn</span>

<span class="s2"># measured values</span>
<span class="s2">fmn=c(</span><span class="si">%(fmn)s</span><span class="s2">)</span>

<span class="s2"># SD for flux measurements</span>
<span class="s2">fmndev=c(</span><span class="si">%(fmndev)s</span><span class="s2">)</span>
<span class="s2">if (nb_fmn)</span>
<span class="s2">   names(fmndev)=names(fmn)=nm_fmn</span>

<span class="s2"># indices for measured fluxes</span>
<span class="s2"># fallnx[ifmn]=&gt;fmn, here fallnx is complete net|xch flux vector</span>
<span class="s2"># combining unknown (dependent), free, constrainded and groth fluxes</span>
<span class="s2">ifmn=match(nm_fmn, nm_fallnx)</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="o">%</span><span class="p">{</span>
        <span class="s2">&quot;nm_fmn&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_meas&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">],</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">),</span>
        <span class="s2">&quot;fmn&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_measured&quot;</span><span class="p">][</span><span class="n">fl</span><span class="p">][</span><span class="s2">&quot;val&quot;</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">fl</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_meas&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">]),</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;nan&quot;</span><span class="p">,</span> <span class="s2">&quot;NA&quot;</span><span class="p">),</span>
        <span class="s2">&quot;fmndev&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_measured&quot;</span><span class="p">][</span><span class="n">fl</span><span class="p">][</span><span class="s2">&quot;dev&quot;</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">fl</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_meas&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">]),</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">),</span>
        <span class="p">})</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="s2">&quot;o_meas&quot;</span><span class="p">:</span> <span class="n">o_meas</span><span class="p">,</span>
        <span class="s2">&quot;measures&quot;</span><span class="p">:</span> <span class="n">measures</span><span class="p">,</span>
        <span class="s2">&quot;o_mcumos&quot;</span><span class="p">:</span> <span class="n">o_mcumos</span><span class="p">,</span>
        <span class="s2">&quot;imcumo2i&quot;</span><span class="p">:</span> <span class="n">imcumo2i</span><span class="p">,</span>
    <span class="p">}</span></div>


<div class="viewcode-block" id="netan2R_rcumo">
<a class="viewcode-back" href="../progdoc.html#ftbl2code.netan2R_rcumo">[docs]</a>
<span class="k">def</span> <span class="nf">netan2R_rcumo</span><span class="p">(</span><span class="n">netan</span><span class="p">,</span> <span class="n">org</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">emu</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="c1"># prepare reduced python systems</span>
    <span class="c1">#rAb=C13_ftbl.rcumo_sys(netan, emu)</span>
    <span class="c1">#raise Exception(&quot;iso2emu&quot;)</span>
    <span class="c1">#import pdb; pdb.set_trace()</span>
    <span class="n">rAb</span><span class="o">=</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;rcumo_sys&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="p">(</span><span class="s2">&quot;rcumo_sys&quot;</span> <span class="ow">in</span> <span class="n">netan</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;rcumo_sys&quot;</span><span class="p">][</span><span class="s2">&quot;A&quot;</span><span class="p">]))</span> <span class="k">else</span> <span class="n">C13_ftbl</span><span class="o">.</span><span class="n">rcumo_sys</span><span class="p">(</span><span class="n">netan</span><span class="p">,</span> <span class="n">emu</span><span class="p">)</span>
    <span class="c1"># full matrix is Ab=netan[&quot;cumo_sys&quot;]</span>

    <span class="c1"># prune ordered cumomer list in reverse order</span>
    <span class="c1"># so that deleted item does not change the index</span>
    <span class="c1"># for the rest items to prune</span>
    <span class="k">if</span> <span class="s2">&quot;vrcumo&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">:</span>
        <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vrcumo&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vcumo&quot;</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vrcumo&quot;</span><span class="p">]),</span><span class="nb">len</span><span class="p">(</span><span class="n">rAb</span><span class="p">[</span><span class="s2">&quot;A&quot;</span><span class="p">]),</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="c1"># delete extra weight systems</span>
            <span class="k">del</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vrcumo&quot;</span><span class="p">][</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">iw</span><span class="p">,</span><span class="n">cumol</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vrcumo&quot;</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cumol</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">i</span><span class="o">-=</span><span class="mi">1</span>
                <span class="k">if</span> <span class="n">cumol</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">rAb</span><span class="p">[</span><span class="s2">&quot;A&quot;</span><span class="p">][</span><span class="n">iw</span><span class="p">]:</span>
                    <span class="c1">#print &quot;prune&quot;, i, cumol[i];##</span>
                    <span class="k">del</span><span class="p">(</span><span class="n">cumol</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="c1"># prepare cumo2i</span>
    <span class="c1"># translate cumoname like A:7 to its index in R vector of cumomers</span>
    <span class="n">rcumos</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">valval</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vrcumo&quot;</span><span class="p">]))</span>
    <span class="n">rcumo2i</span><span class="o">=</span><span class="nb">dict</span><span class="p">((</span><span class="n">c</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rcumos</span><span class="p">))</span>
    <span class="n">emus</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">valval</span><span class="p">(</span><span class="n">netan</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;vemu&quot;</span><span class="p">,</span> <span class="p">[])))</span>
    <span class="n">emu2i</span><span class="o">=</span><span class="nb">dict</span><span class="p">((</span><span class="n">c</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">emus</span><span class="p">))</span>
    <span class="c1"># composit cumomer vector incu=c(1,xi,xc)</span>
    <span class="n">incu2i_b1</span><span class="o">=</span><span class="nb">dict</span><span class="p">((</span><span class="n">c</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;rcumo_input&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">+</span><span class="n">rcumos</span><span class="p">))</span>
    <span class="c1"># write code for reduced cumomer systems</span>
    <span class="c1">#netan2Abcumo_f(rAb[&quot;A&quot;], rAb[&quot;b&quot;],</span>
    <span class="c1">#    netan[&quot;vrcumo&quot;], netan[&quot;input&quot;], ff, netan[&quot;fwrv2i&quot;], incu2i_b1, &quot;fwrv2rAbcumo&quot;)</span>
    <span class="c1">#netan2Abcumo_sp(&quot;spAb_old&quot;, rAb[&quot;A&quot;], rAb[&quot;b&quot;],</span>
    <span class="c1">#    netan[&quot;vrcumo&quot;], netan[&quot;input&quot;], f, netan[&quot;fwrv2i&quot;], incu2i_b1)</span>
    <span class="c1">#print(&quot;rab=&quot;, rAb[&quot;A&quot;], &quot;\n&quot;)</span>
    <span class="n">netan2Abcumo_spr</span><span class="p">(</span><span class="s2">&quot;spAbr&quot;</span><span class="p">,</span> <span class="n">rAb</span><span class="p">[</span><span class="s2">&quot;A&quot;</span><span class="p">],</span> <span class="n">rAb</span><span class="p">[</span><span class="s2">&quot;b&quot;</span><span class="p">],</span>
        <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vrcumo&quot;</span><span class="p">],</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">],</span> <span class="n">f</span><span class="p">,</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;fwrv2i&quot;</span><span class="p">],</span> <span class="n">incu2i_b1</span><span class="p">)</span>
    <span class="c1">#netan2j_rhs_f(rAb[&quot;A&quot;], rAb[&quot;b&quot;],</span>
    <span class="c1">#    netan[&quot;vrcumo&quot;], netan[&quot;input&quot;], ff, netan[&quot;fwrv2i&quot;], rcumo2i, incu2i_b1, &quot;frj_rhs&quot;)</span>
    <span class="c1"># write R constants and names</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2"># weight count</span>
<span class="s2">nb_rw=</span><span class="si">%(nb_rw)d</span>
<span class="s2"># cumomer count by weight</span>
<span class="s2">nb_rcumos=c(</span><span class="si">%(nb_rc)s</span><span class="s2">)</span>
<span class="s2">nbc_rcumos=c(0, cumsum(nb_rcumos))</span>
<span class="s2"># cumo names</span>
<span class="s2">nm_rcumo=c(</span><span class="si">%(nm_rcumo)s</span><span class="s2">)</span>
<span class="s2">nm_list$rcumo=nm_rcumo</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="o">%</span><span class="p">{</span>
        <span class="s2">&quot;nb_rw&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">rAb</span><span class="p">[</span><span class="s2">&quot;A&quot;</span><span class="p">]),</span>
        <span class="s2">&quot;nb_rc&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">rAb</span><span class="p">[</span><span class="s2">&quot;A&quot;</span><span class="p">]),</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">),</span>
        <span class="s2">&quot;nm_rcumo&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="n">valval</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s1">&#39;vrcumo&#39;</span><span class="p">]),</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">),</span>
    <span class="p">})</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">if (case_i) {</span>
<span class="s2">   # check the coherence of metabolites/cumomers</span>
<span class="s2">   met_net=unique(matrix(unlist(strsplit(nm_rcumo, &quot;:&quot;, fixed=TRUE)), nrow=2)[1,])</span>
<span class="s2">   net_pool=sort(setdiff(met_net, names(nm_poolall)))</span>
<span class="s2">   if (length(net_pool) &gt; 0) {</span>
<span class="s2">      stop_mes(&quot;The following metabolites are internal in NETWORK section but not in METABOLITE_POOLS one:</span><span class="se">\\</span><span class="s2">n&quot;, paste(net_pool, collapse=&quot;</span><span class="se">\\</span><span class="s2">n&quot;), file=fcerr)</span>
<span class="s2">   }</span>
<span class="s2">}</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;rcumo2i&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">rcumo2i</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;emu2i&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">emu2i</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="s2">&quot;rcumo2i&quot;</span><span class="p">:</span> <span class="n">rcumo2i</span><span class="p">,</span>
        <span class="s2">&quot;emu2i&quot;</span><span class="p">:</span> <span class="n">emu2i</span><span class="p">,</span>
        <span class="s2">&quot;rAb&quot;</span><span class="p">:</span> <span class="n">rAb</span><span class="p">,</span>
    <span class="p">}</span></div>


<div class="viewcode-block" id="netan2R_cumo">
<a class="viewcode-back" href="../progdoc.html#ftbl2code.netan2R_cumo">[docs]</a>
<span class="k">def</span> <span class="nf">netan2R_cumo</span><span class="p">(</span><span class="n">netan</span><span class="p">,</span> <span class="n">org</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;netan2R_cumo(netan, org, f)-&gt;dict</span>
<span class="sd">    generate data structures for full cumomer matrices</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># prepare cumo2i</span>
    <span class="c1"># translate cumoname like A:7 to its index in R vector of cumomers</span>
    <span class="n">cumos</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">valval</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vcumo&quot;</span><span class="p">]))</span>
    <span class="n">cumo2i</span><span class="o">=</span><span class="nb">dict</span><span class="p">((</span><span class="n">c</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cumos</span><span class="p">))</span>
    <span class="c1"># composite cumomer vector</span>
    <span class="n">incu2i_b1</span><span class="o">=</span><span class="nb">dict</span><span class="p">((</span><span class="n">c</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;cumo_input&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">+</span><span class="n">cumos</span><span class="p">))</span>

    <span class="n">netan2Abcumo_spr</span><span class="p">(</span><span class="s2">&quot;spAbr_f&quot;</span><span class="p">,</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;cumo_sys&quot;</span><span class="p">][</span><span class="s2">&quot;A&quot;</span><span class="p">],</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;cumo_sys&quot;</span><span class="p">][</span><span class="s2">&quot;b&quot;</span><span class="p">],</span>
        <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vcumo&quot;</span><span class="p">],</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">],</span> <span class="n">f</span><span class="p">,</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;fwrv2i&quot;</span><span class="p">],</span> <span class="n">incu2i_b1</span><span class="p">)</span>
    <span class="c1"># write R constants and names</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">if (TIMEIT) {</span>
<span class="s2">   cat(&quot;cumo   : &quot;, format(Sys.time()), &quot; cpu=&quot;, proc.time()[1], &quot;</span><span class="se">\\</span><span class="s2">n&quot;, sep=&quot;&quot;, file=fclog)</span>
<span class="s2">}</span>

<span class="s2"># weight count</span>
<span class="s2">nb_wf=</span><span class="si">%(nb_w)d</span>

<span class="s2"># cumomer count by weight</span>
<span class="s2">nb_cumos=c(</span><span class="si">%(nb_c)s</span><span class="s2">)</span>
<span class="s2">nbc_cumos=c(0, cumsum(nb_cumos))</span>
<span class="s2">nb_f$xf=nb_cumos</span>
<span class="s2">nb_f$nbc_xf=nbc_cumos</span>

<span class="s2"># cumo names</span>
<span class="s2">nm_cumo=c(</span><span class="si">%(nm_cumo)s</span><span class="s2">)</span>
<span class="s2">nm_list$cumo=nm_cumo</span>
<span class="s2">nm_list$cumo=nm_cumo</span>
<span class="s2">&quot;&quot;&quot;</span><span class="o">%</span><span class="p">{</span>
        <span class="s2">&quot;nb_w&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;cumo_sys&quot;</span><span class="p">][</span><span class="s2">&quot;A&quot;</span><span class="p">]),</span>
        <span class="s2">&quot;nb_c&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;cumo_sys&quot;</span><span class="p">][</span><span class="s2">&quot;A&quot;</span><span class="p">]),</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">),</span>
        <span class="s2">&quot;nm_cumo&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="n">valval</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s1">&#39;vcumo&#39;</span><span class="p">]),</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">),</span>
    <span class="p">})</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;cumo2i&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">cumo2i</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="s2">&quot;cumo2i&quot;</span><span class="p">:</span> <span class="n">cumo2i</span><span class="p">,</span>
    <span class="p">}</span></div>


<div class="viewcode-block" id="netan2R_ineq">
<a class="viewcode-back" href="../progdoc.html#ftbl2code.netan2R_ineq">[docs]</a>
<span class="k">def</span> <span class="nf">netan2R_ineq</span><span class="p">(</span><span class="n">netan</span><span class="p">,</span> <span class="n">org</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;netan2R_ineq(netan, org, f)</span>
<span class="sd">    generate inequality code</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># ex: netan[&quot;flux_inequal&quot;]</span>
    <span class="c1"># {&#39;net&#39;: [], &#39;xch&#39;: [(&#39;0.85&#39;, &#39;&gt;=&#39;, {&#39;v2&#39;: &#39;+1.&#39;})]}</span>
    <span class="n">tfallnx</span><span class="o">=</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;tfallnx&quot;</span><span class="p">]</span>
    <span class="n">f2dfcg_nx_f</span><span class="o">=</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;f2dfcg_nx_f&quot;</span><span class="p">]</span>
    <span class="n">nb_ineq</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_inequal&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">])</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_inequal&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">])</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">if (TIMEIT) {</span>
<span class="s2">   cat(&quot;ineq    : &quot;, format(Sys.time()), &quot; cpu=&quot;, proc.time()[1], &quot;</span><span class="se">\\</span><span class="s2">n&quot;, sep=&quot;&quot;, file=fclog)</span>
<span class="s2">}</span>
<span class="s2">#browser()</span>
<span class="s2"># prepare mi matrix and li vector</span>
<span class="s2"># such that mi*fallnx&gt;=li corresponds</span>
<span class="s2"># to the inequalities given in ftbl file</span>
<span class="s2">nb_ineq=</span><span class="si">%(nb_ineq)s</span>
<span class="s2">mi=matrix(0., nrow=nb_ineq, ncol=nb_fallnx)</span>
<span class="s2">li=numeric(nb_ineq)</span>
<span class="s2">nm_i=c(c(</span><span class="si">%(nm_in)s</span><span class="s2">), c(</span><span class="si">%(nm_ix)s</span><span class="s2">))</span>
<span class="s2">dimnames(mi)=list(nm_i, nm_fallnx)</span>
<span class="s2">    &quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">{</span>
       <span class="s2">&quot;nb_ineq&quot;</span><span class="p">:</span> <span class="n">nb_ineq</span><span class="p">,</span>
       <span class="s2">&quot;nm_in&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">ineq</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ineq</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;+&quot;</span><span class="p">,</span>
            <span class="p">((</span><span class="nb">str</span><span class="p">(</span><span class="n">fa</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;*&quot;</span> <span class="k">if</span> <span class="n">fa</span> <span class="o">!=</span> <span class="mf">1.</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">+</span><span class="n">fl</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">fl</span><span class="p">,</span><span class="n">fa</span><span class="p">)</span> <span class="ow">in</span> <span class="n">ineq</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()))))</span>
            <span class="k">for</span> <span class="n">ineq</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_inequal&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">]),</span> <span class="n">p</span><span class="o">=</span><span class="s1">&#39;&quot;n:&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">),</span>
       <span class="s2">&quot;nm_ix&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">ineq</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ineq</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;+&quot;</span><span class="p">,</span>
            <span class="p">((</span><span class="nb">str</span><span class="p">(</span><span class="n">fa</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;*&quot;</span> <span class="k">if</span> <span class="n">fa</span> <span class="o">!=</span> <span class="mf">1.</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">+</span><span class="n">fl</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">fl</span><span class="p">,</span><span class="n">fa</span><span class="p">)</span> <span class="ow">in</span> <span class="n">ineq</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()))))</span>
            <span class="k">for</span> <span class="n">ineq</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_inequal&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">]),</span> <span class="n">p</span><span class="o">=</span><span class="s1">&#39;&quot;x:&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">),</span>
    <span class="p">})</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ineq</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_inequal&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">]):</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
<span class="sd">&quot;&quot;&quot;mi[%(i)s, nm_net[c(%(f)s)]]=%(sign)sc(%(coef)s)</span>
<span class="sd">li[%(i)s]=%(sign)s%(li)g</span>
<span class="sd">&quot;&quot;&quot;</span><span class="o">%</span><span class="p">{</span>
    <span class="c1"># as R inequality is always &quot;&gt;=&quot; we have to inverse the sign for &quot;&lt;=&quot; in ftbl</span>
    <span class="s2">&quot;i&quot;</span><span class="p">:</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
    <span class="s2">&quot;sign&quot;</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;&quot;</span> <span class="k">if</span> <span class="n">ineq</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;&lt;=&quot;</span> <span class="ow">or</span> <span class="n">ineq</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;=&lt;&quot;</span> <span class="k">else</span> <span class="s2">&quot;-&quot;</span><span class="p">),</span>
    <span class="s2">&quot;f&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">ineq</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span> <span class="n">p</span><span class="o">=</span><span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">),</span>
    <span class="s2">&quot;coef&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">ineq</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">),</span>
    <span class="s2">&quot;li&quot;</span><span class="p">:</span> <span class="n">ineq</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
    <span class="p">})</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ineq</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_inequal&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">]):</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
<span class="sd">&quot;&quot;&quot;mi[%(i)s, nm_xch[c(%(f)s)]]=%(sign)sc(%(coef)s)</span>
<span class="sd">li[%(i)s]=%(sign)s%(li)g</span>
<span class="sd">&quot;&quot;&quot;</span><span class="o">%</span><span class="p">{</span>
    <span class="c1"># as R inequality is always &quot;&gt;=&quot; we have to inverse the sign for &quot;&lt;=&quot; in ftbl</span>
    <span class="s2">&quot;i&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_inequal&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">])</span><span class="o">+</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
    <span class="s2">&quot;sign&quot;</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;&quot;</span> <span class="k">if</span> <span class="n">ineq</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;&lt;=&quot;</span> <span class="ow">or</span> <span class="n">ineq</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;=&lt;&quot;</span> <span class="k">else</span> <span class="s2">&quot;-&quot;</span><span class="p">),</span>
    <span class="s2">&quot;f&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">ineq</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span> <span class="n">p</span><span class="o">=</span><span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">),</span>
    <span class="s2">&quot;coef&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">ineq</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">),</span>
    <span class="s2">&quot;li&quot;</span><span class="p">:</span> <span class="n">ineq</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
    <span class="p">})</span>

    <span class="n">nb_fdx</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">])</span>
    <span class="n">nb_ffx</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_free&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">])</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2"># add standard limits on [df].xch [0;cupx]</span>
<span class="s2">nb_tmp=nrow(mi)</span>
<span class="s2">nb_fx=nb_flx+nb_ffx</span>
<span class="s2">if (nb_fx) {</span>
<span class="s2">   mi=rbind(mi, matrix(0, nrow=2*nb_fx, ncol=nb_fallnx))</span>
<span class="s2">   if (nb_flx)</span>
<span class="s2">      nm_i=c(nm_i, paste(nm_flx, &quot;&gt;=0&quot;, sep=&quot;&quot;))</span>
<span class="s2">   if (nb_ffx)</span>
<span class="s2">      nm_i=c(nm_i, paste(nm_ffx, &quot;&gt;=0&quot;, sep=&quot;&quot;))</span>
<span class="s2">   if (nb_flx)</span>
<span class="s2">      nm_i=c(nm_i, paste(nm_flx, &quot;&lt;=&quot;, cupx, sep=&quot;&quot;))</span>
<span class="s2">   if (nb_ffx)</span>
<span class="s2">      nm_i=c(nm_i, paste(nm_ffx, &quot;&lt;=&quot;, cupx, sep=&quot;&quot;))</span>
<span class="s2">   li=c(li, rep(0, nb_fx), rep(-cupx, nb_fx))</span>
<span class="s2">   mi[nb_tmp+(1:nb_fx),c(nm_flx, nm_ffx)]=diag(1., nb_fx)</span>
<span class="s2">   mi[nb_tmp+nb_fx+(1:nb_fx),c(nm_flx, nm_ffx)]=diag(-1., nb_fx)</span>
<span class="s2">}</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>
    
    <span class="n">nb_notrev</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;notrev&quot;</span><span class="p">])</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">nm_inout=grep(&quot;^[^c]</span><span class="se">\\\\</span><span class="s2">.&quot;, nm_net[c(</span><span class="si">%(nm_inout)s</span><span class="s2">)], v=TRUE) # strip out constrained fluxes</span>
<span class="s2">nb_inout=length(nm_inout)</span>
<span class="s2">if (nb_inout &gt; 0) {</span>
<span class="s2">   # add cinout low limits on inout net fluxes</span>
<span class="s2">   nb_tmp=nrow(mi)</span>
<span class="s2">   # explicit inequalities take precedence over generic ones</span>
<span class="s2">   # so eliminate inout fluxes which are already in inequalities</span>
<span class="s2">   nm_itmp=paste(&quot;n:.+&lt;=&quot;, substring(nm_inout, 5), sep=&quot;&quot;)</span>
<span class="s2">   i=sapply(1:length(nm_itmp), function(k) {</span>
<span class="s2">      j=grep(nm_itmp[k], nm_i)</span>
<span class="s2">      #cat(nm_itmp[k], &quot;-&gt;&quot;, nm_i[j], &quot;</span><span class="se">\\</span><span class="s2">n&quot;, file=fclog)</span>
<span class="s2">      if (length(j)==0) {</span>
<span class="s2">         return(0)</span>
<span class="s2">      } else {</span>
<span class="s2">         return(k)</span>
<span class="s2">      }</span>
<span class="s2">   })</span>
<span class="s2">   i=i[i!=0]</span>
<span class="s2">   if (length(i) &gt; 0) {</span>
<span class="s2">      nm_tmp=nm_inout[-i]</span>
<span class="s2">   } else {</span>
<span class="s2">      nm_tmp=nm_inout</span>
<span class="s2">   }</span>
<span class="s2">   len_tmp=length(nm_tmp)</span>
<span class="s2">   if (len_tmp &gt; 0) {</span>
<span class="s2">      mi=rbind(mi, matrix(0, nrow=len_tmp, ncol=nb_fallnx))</span>
<span class="s2">      nm_i=c(nm_i, paste(&quot;inout &quot;, nm_tmp, &quot;&gt;=&quot;, cinout, sep=&quot;&quot;))</span>
<span class="s2">      mi[nb_tmp+(1:len_tmp), nm_tmp]=diag(1., len_tmp)</span>
<span class="s2">      li=c(li, rep(cinout, len_tmp))</span>
<span class="s2">   }</span>
<span class="s2">}</span>
<span class="s2">if (clownr!=0.) {</span>
<span class="s2">   # add low limits on net &gt;= clownr for not reversible reactions</span>
<span class="s2">   nb_tmp=nrow(mi)</span>
<span class="s2">   nm_tmp=nm_net[c(</span><span class="si">%(nm_notrev)s</span><span class="s2">)]</span>
<span class="s2">   # explicit inequalities take precedence over generic ones</span>
<span class="s2">   # so eliminate notrev fluxes which are already in inequalities</span>
<span class="s2">   nm_itmp=paste(&quot;n:.+&lt;=&quot;, substring(nm_tmp, 5), sep=&quot;&quot;)</span>
<span class="s2">   i=sapply(1:length(nm_itmp), function(k) {</span>
<span class="s2">      j=grep(nm_itmp[k], nm_i)</span>
<span class="s2">      #cat(nm_itmp[k], &quot;-&gt;&quot;, nm_i[j], &quot;</span><span class="se">\\</span><span class="s2">n&quot;, file=fclog)</span>
<span class="s2">      if (length(j)==0) {</span>
<span class="s2">         return(0)</span>
<span class="s2">      } else {</span>
<span class="s2">         return(k)</span>
<span class="s2">      }</span>
<span class="s2">   })</span>
<span class="s2">   i=i[i!=0]</span>
<span class="s2">   if (length(i) &gt; 0) {</span>
<span class="s2">      nm_tmp=nm_tmp[-i]</span>
<span class="s2">   }</span>
<span class="s2">   # search for inout too</span>
<span class="s2">   nm_itmp=paste(&quot;inout &quot;, nm_tmp, &quot;&gt;=&quot;, sep=&quot;&quot;)</span>
<span class="s2">   i=sapply(1:length(nm_itmp), function(k) {</span>
<span class="s2">      j=grep(nm_itmp[k], nm_i, fix=TRUE)</span>
<span class="s2">      #cat(nm_itmp[k], &quot;-&gt;&quot;, nm_i[j], &quot;</span><span class="se">\\</span><span class="s2">n&quot;, file=fclog)</span>
<span class="s2">      if (length(j)==0) {</span>
<span class="s2">         return(0)</span>
<span class="s2">      } else {</span>
<span class="s2">         return(k)</span>
<span class="s2">      }</span>
<span class="s2">   })</span>
<span class="s2">   i=i[i!=0]</span>
<span class="s2">   if (length(i) &gt; 0) {</span>
<span class="s2">      nm_tmp=nm_tmp[-i]</span>
<span class="s2">   }</span>

<span class="s2">   len_tmp=length(nm_tmp)</span>
<span class="s2">   if (len_tmp &gt; 0) {</span>
<span class="s2">      mi=rbind(mi, matrix(0, nrow=len_tmp, ncol=nb_fallnx))</span>
<span class="s2">      nm_i=c(nm_i, paste(nm_tmp, &quot;&gt;=&quot;, clownr, sep=&quot;&quot;))</span>
<span class="s2">      mi[nb_tmp+(1:len_tmp), nm_tmp]=diag(1., len_tmp)</span>
<span class="s2">      li=c(li, rep(clownr, len_tmp))</span>
<span class="s2">   }</span>
<span class="s2">}</span>
<span class="s2">nb_fn=nb_fln+nb_ffn</span>
<span class="s2">if (cupn != 0 &amp;&amp; nb_fn &gt; 0) {</span>
<span class="s2">   # add absolute upper limits on -cupn &lt;= [df].net &lt;= cupn for net fluxes</span>
<span class="s2">   # explicit inequalities take precedence over generic ones</span>
<span class="s2">   # so eliminate net fluxes which are already in inequalities</span>
<span class="s2">   ## proceed n:smth&gt;=flux</span>
<span class="s2">   nm_tmp=c(nm_ffn, nm_fln) # all not fixed net fluxes</span>
<span class="s2">   nm_itmp=paste(&quot;n:.+&gt;=&quot;, substring(nm_tmp, 5), sep=&quot;&quot;)</span>
<span class="s2">   i=sapply(vgrep(nm_itmp, nm_i), length)</span>
<span class="s2">   i=which(i!=0)</span>
<span class="s2">   if (length(i) &gt; 0) {</span>
<span class="s2">      nm_tmp=nm_tmp[-i]</span>
<span class="s2">   }</span>
<span class="s2">   len_tmp=length(nm_tmp)</span>
<span class="s2">   if (len_tmp &gt; 0) {</span>
<span class="s2">      nb_tmp=nrow(mi)</span>
<span class="s2">      mi=rbind(mi, matrix(0, nrow=len_tmp, ncol=nb_fallnx))</span>
<span class="s2">      nm_i=c(nm_i, paste0(nm_tmp, &quot;&lt;=&quot;, cupn))</span>
<span class="s2">      li=c(li, rep(-cupn, len_tmp))</span>
<span class="s2">      mi[nb_tmp+(1:len_tmp),nm_tmp]=diag(-1., len_tmp)</span>
<span class="s2">   }</span>
<span class="s2">   ## proceed n:smth&lt;=flux</span>
<span class="s2">   nm_tmp=c(nm_ffn, nm_fln) # all not fixed net fluxes</span>
<span class="s2">   nm_itmp=paste(&quot;n:.+&lt;=&quot;, substring(nm_tmp, 5), sep=&quot;&quot;)</span>
<span class="s2">   i=sapply(vgrep(nm_itmp, nm_i), length)</span>
<span class="s2">   i=which(i!=0)</span>
<span class="s2">   if (length(i) &gt; 0) {</span>
<span class="s2">      nm_tmp=nm_tmp[-i]</span>
<span class="s2">   }</span>
<span class="s2">   len_tmp=length(nm_tmp)</span>
<span class="s2">   if (len_tmp &gt; 0) {</span>
<span class="s2">      nb_tmp=nrow(mi)</span>
<span class="s2">      mi=rbind(mi, matrix(0, nrow=len_tmp, ncol=nb_fallnx))</span>
<span class="s2">      nm_i=c(nm_i, paste0(nm_tmp, &quot;&gt;=&quot;, -cupn))</span>
<span class="s2">      li=c(li, rep(-cupn, len_tmp))</span>
<span class="s2">      mi[nb_tmp+(1:len_tmp),nm_tmp]=diag(1., len_tmp)</span>
<span class="s2">   }</span>
<span class="s2">}</span>
<span class="s2">#browser()</span>
<span class="s2">&quot;&quot;&quot;</span><span class="o">%</span><span class="p">{</span>
<span class="c1">#   &quot;nb_notrev&quot;: len([fli for (fli,t,nxi) in tfallnx</span>
<span class="c1">#      if nxi==&quot;n&quot; and t!=&quot;c&quot; and fli in netan[&quot;notrev&quot;]]),</span>
   <span class="s2">&quot;nm_notrev&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;notrev&quot;</span><span class="p">],</span> <span class="n">p</span><span class="o">=</span><span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">),</span>
   <span class="s2">&quot;nm_inout&quot;</span><span class="p">:</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_inout&quot;</span><span class="p">],</span> <span class="n">p</span><span class="o">=</span><span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">120</span><span class="p">),</span>
<span class="p">})</span>

    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;nb_ineq=NROW(li);</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">dimnames(mi)=list(nm_i, nm_fallnx)</span>
<span class="s2">names(li)=nm_i</span>
<span class="s2"># prepare ui matrix and ci vector for optimisation</span>
<span class="s2"># ui</span><span class="si">%*%</span><span class="s2">param-ci&gt;=0</span>
<span class="s2"># it is composed of explicite inequalities from ftbl</span>
<span class="s2"># and permanent inequalities 0&lt;=xch&lt;=0.999 and scale&gt;=0</span>

<span class="s2"># constraints such that ui</span><span class="si">%*%</span><span class="s2">param-ci&gt;=0</span>
<span class="s2"># first flux part</span>
<span class="s2">ui=mi</span><span class="si">%*%</span><span class="s2">(md</span><span class="si">%*%</span><span class="s2">invAfl</span><span class="si">%s</span><span class="s2">tm%p2bfl+mf)</span>
<span class="s2">mic=(md</span><span class="si">%*%</span><span class="s2">invAfl</span><span class="si">%*%</span><span class="s2">(c2bfl</span><span class="si">%s</span><span class="s2">tm</span><span class="si">%f</span><span class="s2">c+cnst2bfl) + mc</span><span class="si">%*%</span><span class="s2">fc)</span>
<span class="s2">ci=as.numeric(li-mi</span><span class="si">%*%</span><span class="s2">mic)</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2"># finaly, metab part</span>
<span class="s2">uip=matrix(0., </span><span class="si">%(nb_ip)d</span><span class="s2">, ncol=nb_poolf)</span>
<span class="s2">colnames(uip)=nm_poolf</span>
<span class="s2">cip=c()</span>
<span class="s2"># ind: irow, metab, coef, rhs, name</span>
<span class="s2">uip_ind=c(</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="o">%</span><span class="p">{</span>
        <span class="s2">&quot;nb_ip&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;metab_inequal&quot;</span><span class="p">]),</span>
    <span class="p">})</span>
    <span class="n">st</span><span class="o">=</span><span class="s2">&quot;&quot;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">comp</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;metab_inequal&quot;</span><span class="p">]):</span>
        <span class="n">si</span><span class="o">=-</span><span class="mf">1.</span> <span class="k">if</span> <span class="n">comp</span> <span class="o">==</span> <span class="s2">&quot;&gt;=&quot;</span> <span class="ow">or</span> <span class="n">comp</span> <span class="o">==</span> <span class="s2">&quot;=&gt;&quot;</span> <span class="k">else</span> <span class="mf">1.</span>
        <span class="n">rhs</span><span class="o">*=</span><span class="n">si</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">coef</span><span class="p">)</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># ind4 (str): irow, metab, coef, rhs, name</span>
            <span class="n">coef</span><span class="o">*=</span><span class="n">si</span>
            <span class="k">if</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;met_pools&quot;</span><span class="p">][</span><span class="n">m</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">rhs</span><span class="o">-=</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;met_pools&quot;</span><span class="p">][</span><span class="n">m</span><span class="p">]</span><span class="o">*</span><span class="n">coef</span>
                <span class="n">m</span><span class="o">=</span><span class="s2">&quot;&quot;</span>
                <span class="n">coef</span><span class="o">=</span><span class="mf">0.</span>
            <span class="n">st</span><span class="o">=</span><span class="n">st</span><span class="o">+</span><span class="s2">&quot;&quot;&quot;   &quot;</span><span class="si">%d</span><span class="s2">&quot;, &quot;</span><span class="si">%s</span><span class="s2">&quot;, &quot;</span><span class="si">%g</span><span class="s2">&quot;, &quot;</span><span class="si">%g</span><span class="s2">&quot;, &quot;</span><span class="si">%s</span><span class="s2">&quot;,</span>
<span class="s2">&quot;&quot;&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">coef</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="n">rhs</span><span class="o">=</span><span class="mf">0.</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span><span class="si">%s</span>
<span class="s2">)</span>
<span class="s2">if (length(uip_ind) &gt; 0) {</span>
<span class="s2">   uip_ind=matrix(uip_ind, byrow=TRUE, ncol=5L)</span>
<span class="s2">} else {</span>
<span class="s2">   uip_ind=matrix(0, 0L, 5L)</span>
<span class="s2">}</span>
<span class="s2">colnames(uip_ind)=c(&quot;irow&quot;, &quot;metab&quot;, &quot;coef&quot;, &quot;rhs&quot;, &quot;name&quot;)</span>
<span class="s2">&quot;&quot;&quot;</span><span class="o">%</span><span class="n">st</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">if (nrow(uip_ind) &gt; 0) {</span>
<span class="s2">   # rhs are summed up for the same irow by aggregate()</span>
<span class="s2">   irow=as.integer(uip_ind[,&quot;irow&quot;])</span>
<span class="s2">   cip=aggregate(as.double(uip_ind[,&quot;rhs&quot;]), by=list(irow), sum)[,&quot;x&quot;]</span>
<span class="s2">   for (i in seq_len(nrow(uip_ind))) {</span>
<span class="s2">      row=uip_ind[i,]</span>
<span class="s2">      if (nchar(row[&quot;metab&quot;])==0) {</span>
<span class="s2">         next</span>
<span class="s2">      }</span>
<span class="s2">      uip[irow[i], nm_poolf[row[&quot;metab&quot;]]]=as.double(row[&quot;coef&quot;])</span>
<span class="s2">   }</span>
<span class="s2">   if (nrow(uip) &gt; 0) {</span>
<span class="s2">      rownames(uip)=paste(&quot;m:&quot;, uip_ind[pmatch(seq_len(nrow(uip)), irow),&quot;name&quot;], sep=&quot;&quot;)</span>
<span class="s2">   }</span>
<span class="s2">}</span>
<span class="s2">names(cip)=rownames(uip)</span>

<span class="s2">#browser() # before null inequality removing</span>
<span class="s2"># remove all zero rows in ui (constrained fluxes with fixed values)</span>
<span class="s2"># find zero indexes</span>
<span class="s2">#print(dim(ui))</span>
<span class="s2">if (ncol(ui)) {</span>
<span class="s2">   zi=apply(ui,1,function(v){return(max(abs(v))&lt;=1.e-14)})</span>
<span class="s2">} else {</span>
<span class="s2">   # remove all flux inequalities as there is no free fluxe</span>
<span class="s2">   zi=rep(TRUE, nrow(ui))</span>
<span class="s2">}</span>

<span class="s2">if (!all(ci[zi]&lt;=1.e-10)) {</span>
<span class="s2">   cat(&quot;The following constant inequalities are not satisfied:</span><span class="se">\\</span><span class="s2">n&quot;, file=fclog)</span>
<span class="s2">   cat(nm_i[zi][ci[zi]&gt;1.e-10], sep=&quot;</span><span class="se">\\</span><span class="s2">n&quot;, file=fclog)</span>
<span class="s2">   cat(&quot;They are simply ignored.</span><span class="se">\\</span><span class="s2">n&quot;, file=fclog)</span>
<span class="s2">   #stop_mes(&quot;&quot;, file=fcerr)</span>
<span class="s2">}</span>
<span class="s2">ui=ui[!zi,,drop=FALSE]</span>
<span class="s2">ci=ci[!zi]</span>
<span class="s2">nm_i=nm_i[!zi]</span>

<span class="s2"># complete ui by zero columns corresponding to scale params</span>
<span class="s2">if (nb_sc_tot) {</span>
<span class="s2">   ui=cbind(as.matrix(ui), matrix(0., NROW(ui), nb_sc_tot))</span>
<span class="s2">   # complete ui by scales &gt;=0</span>
<span class="s2">   ui=rbind(ui, cbind(matrix(0, nb_sc_tot, nb_ff), diag(1, nb_sc_tot)))</span>
<span class="s2">   ci=c(ci,rep(0., nb_sc_tot))</span>
<span class="s2">   nm_i=c(nm_i, paste(nm_par[nb_ff+seq_len(nb_sc_tot)], &quot;&gt;=0&quot;, sep=&quot;&quot;))</span>
<span class="s2">   rownames(ui)=nm_i</span>
<span class="s2">   names(ci)=nm_i</span>
<span class="s2">}</span>

<span class="s2"># remove redundant inequalities</span>
<span class="s2">#browser()</span>
<span class="s2">nb_i=nrow(ui)</span>
<span class="s2">ired=c()</span>
<span class="s2">if (nb_i &gt; 1L) {</span>
<span class="s2">   for (i in 1L:(nb_i-1L)) {</span>
<span class="s2">      nmref=nm_i[i]</span>
<span class="s2">      for (j in setdiff((i+1L):nb_i, ired)) {</span>
<span class="s2">         if (all(ui[j,]==ui[i,]) &amp;&amp; ci[i]==ci[j]) {</span>
<span class="s2">            # redundancy</span>
<span class="s2">            cat(&quot;inequality &#39;&quot;, nm_i[j], &quot;&#39; redundant with &#39;&quot;, nmref, &quot;&#39; is removed.</span><span class="se">\n</span><span class="s2">&quot;, sep=&quot;&quot;, file=fclog)</span>
<span class="s2">            ired=c(ired, j)</span>
<span class="s2">         }</span>
<span class="s2">      }</span>
<span class="s2">   }</span>
<span class="s2">}</span>
<span class="s2">if (!is.null(ired)) {</span>
<span class="s2">   # remove all ired inequalities</span>
<span class="s2">   ui=ui[-ired,,drop=FALSE]</span>
<span class="s2">   ci=ci[-ired]</span>
<span class="s2">   nm_i=nm_i[-ired]</span>
<span class="s2">}</span>

<span class="s2"># metabolite equalities</span>
<span class="s2">ep=matrix(0., </span><span class="si">%(nb_ep)d</span><span class="s2">, ncol=nb_poolf)</span>
<span class="s2">cp=c()</span>
<span class="s2">colnames(ep)=nm_poolf</span>
<span class="s2"># ind: irow, metab, coef, rhs, name</span>
<span class="s2">ep_ind=c(</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="o">%</span><span class="p">{</span>
        <span class="s2">&quot;nb_ep&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;metab_equal&quot;</span><span class="p">]),</span>
    <span class="p">})</span>
    <span class="n">st</span><span class="o">=</span><span class="s2">&quot;&quot;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;metab_equal&quot;</span><span class="p">]):</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">coef</span><span class="p">)</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># ind4 (str): irow, metab, coef, rhs, name</span>
            <span class="k">if</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;met_pools&quot;</span><span class="p">][</span><span class="n">m</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">rhs</span><span class="o">-=</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;met_pools&quot;</span><span class="p">][</span><span class="n">m</span><span class="p">]</span><span class="o">*</span><span class="n">coef</span>
                <span class="n">m</span><span class="o">=</span><span class="s2">&quot;&quot;</span>
                <span class="n">coef</span><span class="o">=</span><span class="mf">0.</span>
            <span class="n">st</span><span class="o">=</span><span class="n">st</span><span class="o">+</span><span class="s2">&quot;&quot;&quot;   &quot;</span><span class="si">%d</span><span class="s2">&quot;, &quot;</span><span class="si">%s</span><span class="s2">&quot;, &quot;</span><span class="si">%g</span><span class="s2">&quot;, &quot;</span><span class="si">%g</span><span class="s2">&quot;, &quot;</span><span class="si">%s</span><span class="s2">&quot;,</span>
<span class="s2">&quot;&quot;&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">coef</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="n">rhs</span><span class="o">=</span><span class="mf">0.</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span><span class="si">%s</span>
<span class="s2">)</span>
<span class="s2">if (length(ep_ind) &gt; 0) {</span>
<span class="s2">   ep_ind=matrix(ep_ind, byrow=TRUE, ncol=5L)</span>
<span class="s2">} else {</span>
<span class="s2">   ep_ind=matrix(0, 0L, 5L)</span>
<span class="s2">}</span>
<span class="s2">colnames(ep_ind)=c(&quot;irow&quot;, &quot;metab&quot;, &quot;coef&quot;, &quot;rhs&quot;, &quot;name&quot;)</span>
<span class="s2">&quot;&quot;&quot;</span><span class="o">%</span><span class="n">st</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">if (nrow(ep_ind) &gt; 0) {</span>
<span class="s2">   # rhs are summed up for the same irow by aggregate</span>
<span class="s2">   irow=as.integer(ep_ind[,&quot;irow&quot;])</span>
<span class="s2">   cp=aggregate(as.double(ep_ind[,&quot;rhs&quot;]), by=list(irow))[,&quot;x&quot;]</span>
<span class="s2">   for (i in seq_len(nrow(ep_ind))) {</span>
<span class="s2">      row=ep_ind[i,]</span>
<span class="s2">      if (nchar(row[&quot;metab&quot;])==0) {</span>
<span class="s2">         next</span>
<span class="s2">      }</span>
<span class="s2">      ep[irow[i], nm_poolf[row[&quot;metab&quot;]]]=as.double(row[&quot;coef&quot;])</span>
<span class="s2">   }</span>
<span class="s2">   if (nrow(ep) &gt; 0) {</span>
<span class="s2">      rownames(ep)=paste(&quot;m:&quot;, ep_ind[pmatch(seq_len(nrow(ep)), irow),&quot;name&quot;], sep=&quot;&quot;)</span>
<span class="s2">   }</span>
<span class="s2">}</span>
<span class="s2">ep=as.matrix(ep)</span>
<span class="s2">names(cp)=rownames(ep)</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">)</span></div>

</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">influx_si 7.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">ftbl2code</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2012-2024, INRAE/INSA/CNRS.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>