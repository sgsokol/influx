<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>C13_ftbl &#8212; influx_si 7.2 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/classic.css?v=514cf933" />
    
    <script src="../_static/documentation_options.js?v=9eaa8645"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">influx_si 7.2 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">C13_ftbl</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for C13_ftbl</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;- Parse .ftbl</span>
<span class="sd">- Analyse ftbl</span>

<span class="sd">Restrictions:</span>
<span class="sd"> - metabolite name cannot have</span>
<span class="sd">   </span>
<span class="sd">   &quot;:&quot;</span>
<span class="sd">     it&#39;s a separator in measure id</span>
<span class="sd">   &quot;+&quot;</span>
<span class="sd">     in measurements it can be metab1+metab2+...</span>
<span class="sd">  </span>
<span class="sd">&quot;&quot;&quot;</span>
            <span class="c1"># # normalize or not?</span>
            <span class="c1"># collab=sorted(v for li in labs for v in li) # will be collapsed labels.</span>
            <span class="c1"># # the group is normalizable if collapsed labs is composed of only &quot;x&quot;</span>
            <span class="c1"># while True:</span>
                <span class="c1"># collab=sorted(collab) # if there are two collapsible labs, they will be neighbors</span>
                <span class="c1"># found=False</span>
                <span class="c1"># for i in range(len(collab)):</span>
                    <span class="c1"># if i == len(collab)-1:</span>
                        <span class="c1"># break</span>
                    <span class="c1"># s=np.array(list(collab[i])) if i == 0 else n # string</span>
                    <span class="c1"># n=np.array(list(collab[i+1])) # next</span>
                    <span class="c1"># cdif=s != n</span>
                    <span class="c1"># if cdif.sum() == 1:</span>
                        <span class="c1"># idif=np.where(cdif)[0][0]</span>
                        <span class="c1"># found=s[idif] == &quot;0&quot; and n[idif] == &quot;1&quot;</span>
                        <span class="c1"># if found:</span>
                            <span class="c1"># s[idif]=&quot;x&quot;</span>
                            <span class="c1"># collab[i]=&quot;&quot;.join(s)</span>
                            <span class="c1"># del(collab[i+1])</span>
                            <span class="c1"># break</span>
                <span class="c1"># if not found or len(collab) == 1:</span>
                    <span class="c1"># break</span>
            <span class="c1"># if len(collab) == 1 and collab[0] == &quot;x&quot;*len(collab) and all(val == val):</span>
                <span class="c1"># s=sum(val)</span>
                <span class="c1"># val=val/s</span>
                <span class="c1"># sdv=sdv/s</span>
                <span class="c1"># norma=True</span>
            <span class="c1"># else:</span>
                <span class="c1"># norma=False</span>

<span class="c1"># 2008-01-22 sokol: ftbl_parse(f)</span>
<span class="c1"># 2008-01-25 sokol: ftbl_netan(ftbl)</span>
<span class="c1"># 2008-01-30 sokol: sto_r_m is added to the result of ftbl_netan()</span>
<span class="c1"># 2008-03-05 sokol: ftbl_parse(): added labeled atoms transitions in &quot;TRANS&quot; key</span>
<span class="c1"># 2008-03-05 sokol: ftbl_netan(): added isotopomers balance equations</span>
<span class="c1"># 2008-03-06 sokol: ftbl_netan(): added fwd-rev flux balance matrix</span>
<span class="c1"># 2008-03-10 sokol: ftbl_netan(): added carbon length</span>
<span class="c1"># 2008-03-?? sokol: ftbl_netan(): added chemical formula (reactions)</span>
<span class="c1"># 2008-03-?? sokol: ftbl_netan(): added cumomer balance pattern (cumo_balance_pattern)</span>
<span class="c1"># 2008-03-19 sokol: enum_metab(): metabolite list enumerated along to chemical pathways</span>
<span class="c1"># 2008-03-20 sokol: ftbl_netan(): added cumomer systems (cumo_sys)</span>
<span class="c1"># 2008-03-21 sokol: ftbl_netan(): added carbon transitions (carbotrans)</span>
<span class="c1"># 2008-03-25 sokol: iw(): added &quot;index in given weight&quot; iterator</span>
<span class="c1"># 2008-03-26 sokol: ftbl_netan(): added Cmax, maximal carbon length</span>
<span class="c1"># 2008-03-26 sokol: cumo_path(): enumerate cumomers of a given weight along pathways</span>
<span class="c1"># 2008-03-26 sokol: ftbl_netan(): removed metab_paths ordering</span>
<span class="c1"># 2008-03-26 sokol: ftbl_netan(): removed cumo_w ordering</span>
<span class="c1"># 2008-03-26 sokol: ftbl_netan(): added set of all metabolites (metabs)</span>
<span class="c1"># 2008-04-14 sokol: ftbl_netan(): added set of free fluxes (flux_free[net|xch])</span>
<span class="c1"># 2008-04-14 sokol: ftbl_netan(): added set of constrained fluxes flux_constr[net|xch])</span>
<span class="c1"># 2008-04-16 sokol: ftbl_netan(): added set of measured fluxes (flux_measured)</span>
<span class="c1"># 2008-04-18 sokol: ftbl_netan(): changed structure of sto_m_r, sto_r_m, flux_m_r, cumo_balance_pattern and matrix A</span>
<span class="c1"># 2008-04-18 sokol: ftbl_netan(): removed cumo_balance_pattern</span>
<span class="c1"># 2008-04-18 sokol: ftbl_netan(): cumomers matrix construction rewritten from scratch</span>
<span class="c1"># 2008-04-21 sokol: ftbl_netan(): added input cumomers to matrix</span>
<span class="c1"># 2008-04-21 sokol: ftbl_netan(): added input cumomers to netan (cumo_input)</span>
<span class="c1"># 2008-04-21 sokol: iso2cumo(): calculate cumo fraction from isotopomer ones</span>
<span class="c1"># 2008-06-12 sokol: ftbl_netan(): added inequality analysis</span>
<span class="c1"># 2008-06-12 sokol: ftbl_netan(): added label measurements analysis</span>
<span class="c1"># 2008-06-23 sokol: ftbl_netan(): added peak measurements analysis</span>
<span class="c1"># 2008-06-23 sokol: ftbl_netan(): added mass measurements analysis</span>
<span class="c1"># 2008-06-26 sokol: ftbl_netan(): added matrices for label (H1) and mass</span>
<span class="c1"># 2008-06-27 sokol: ftbl_netan(): added matrix for peaks (C13)</span>
<span class="c1"># 2008-07-18 sokol: ftbl_netan(): added cumomers ordered lists (one by weight)</span>
<span class="c1"># 2008-07-22 sokol: ftbl_netan(): added net and xch equalities</span>
<span class="c1"># 2008-07-23 sokol: ftbl_netan(): added Afl, bfl</span>
<span class="c1"># 2008-07-23 sokol: ftbl_netan(): added fluxes ordered lists (net and xch)</span>
<span class="c1"># 2008-07-24 sokol: ftbl_netan(): added free fluxes ordered lists</span>
<span class="c1"># 2008-07-24 sokol: ftbl_netan(): added constrained fluxes ordered lists</span>
<span class="c1"># 2008-07-24 sokol: ftbl_netan(): added measured fluxes ordered lists</span>
<span class="c1"># 2008-07-24 sokol: ftbl_netan(): added compleet fluxes ordered lists</span>
<span class="c1"># 2008-07-28 sokol: ftbl_netan(): added Afl row names (vrowAfl)</span>
<span class="c1"># 2008-07-28 sokol: ftbl_netan(): added in-out xch fluxes to constrained flux list</span>
<span class="c1"># 2008-07-30 sokol: ftbl_netan(): added in-out fluxes (flux_in, flux_out)</span>
<span class="c1"># 2008-09-01 sokol: labprods(): get labeled product by a given metabolite in a given reaction</span>
<span class="c1"># 2008-09-03 sokol: allprods(): get all labeled product by a given metabolite with others labeled isotops in a given reaction</span>
<span class="c1"># 2008-09-23 sokol: added mat2graph()</span>
<span class="c1"># 2008-10-10 sokol: added rcumo_sys()</span>
<span class="c1"># 2009-02-02 sokol: added iin_metab to output of cumo_infl()</span>
<span class="c1"># 2009-03-24 sokol: ftbl_netan(): added tmax, dt, metab_scale, met_pools</span>
<span class="c1"># 2009-03-27 sokol: ftbl_parse(): added float_conv field set</span>
<span class="c1"># 2009-05-28 sokol: added t_iso2m(): transition matrix from isotopomer vector to MID vector</span>
<span class="c1"># 2009-05-28 sokol: added t_iso2cumo(): transition matrix from isotopomer vector to cumomer vector</span>
<span class="c1"># 2009-05-28 sokol: added t_iso2pos(): transition matrix from isotopomer vector to positional labelling vector</span>
<span class="c1"># 2009-07-21 sokol: added conv_mid(): convolution of two mass isotopomer distribution</span>
<span class="c1"># 2009-09-14 sokol: Flux names changed flux.[net|xch] -&gt; [dfc].[nx].flux</span>
<span class="c1"># 2009-10-19 sokol: ftbl_netan(): added consistancy check on fluxes, metabs and lengthes</span>
<span class="c1"># 2009-11-26 sokol: added infl(): set of incoming fluxes</span>
<span class="c1"># 2010-02-15 sokol: ftbl_parse(): fixed input/output fluxes with respect to d/f/c characterisation</span>
<span class="c1"># 2010-05-05 sokol: ftbl_parse(): if file name is given, check for .ftbl and add it if needed</span>
<span class="c1"># 2010-05-31 sokol: ftbl_parse(): non blocking errors for not complete ftbl (e.g. for graph plotting)</span>
<span class="c1"># 2010-10-11 sokol: ftbl_parse(): for measurements added row number for later identification</span>
<span class="c1"># 2010-10-11 sokol: ftbl_netan(): added &quot;id&quot; field in measures</span>
<span class="c1"># 2010-11-23 sokol: ftbl_netan(): added &quot;nx2dfc&quot; dictionary</span>
<span class="c1"># 2010-12-02 sokol: ftbl_netan(): added growth flux option</span>
<span class="c1"># 2011-04-20 sokol: cumo_infl(),...: not reversible fluxes are replaced by flux_out in cumomer balance</span>
<span class="c1"># 2011-04-27 sokol: ftbl_neta(): added flux_inout</span>
<span class="c1"># 2011-04-27 sokol: cumo_infl(),...: not reversible fluxes are replaced by flux_inout in cumomer balance</span>
<span class="c1"># 2012-05-04 sokol: added pooled metabs (same carbon length) in measurements</span>
<span class="c1"># 2012-06-25 sokol: added EMU fragment gathering ms_frag_gath()</span>
<span class="c1"># 2012-11-08 sokol: added variable growth fluxes depending on variable</span>
<span class="c1">#                   concentrations (flux_vgrowth, vflux_growth.[net])</span>
<span class="c1"># 2012-11-23 sokol: added concentration measurements</span>
<span class="c1"># 2014-01-22 sokol: added possibility of unknown fluxes in EQUALITY section</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">codecs</span> <span class="kn">import</span> <span class="n">BOM_UTF8</span><span class="p">,</span> <span class="n">BOM_UTF16_BE</span><span class="p">,</span> <span class="n">BOM_UTF16_LE</span><span class="p">,</span> <span class="n">BOM_UTF32_BE</span><span class="p">,</span> <span class="n">BOM_UTF32_LE</span>
<span class="kn">from</span> <span class="nn">asteval</span> <span class="kn">import</span> <span class="n">Interpreter</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="kn">import</span> <span class="nn">io</span>
<span class="n">aeval</span><span class="o">=</span><span class="n">Interpreter</span><span class="p">(</span><span class="n">err_writer</span><span class="o">=</span><span class="n">io</span><span class="o">.</span><span class="n">TextIOWrapper</span><span class="p">(</span><span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">()))</span>

<div class="viewcode-block" id="oset">
<a class="viewcode-back" href="../progdoc.html#C13_ftbl.oset">[docs]</a>
<span class="k">class</span> <span class="nc">oset</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;expected at most 1 arguments, got </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">))</span>
<div class="viewcode-block" id="oset.copy">
<a class="viewcode-back" href="../progdoc.html#C13_ftbl.oset.copy">[docs]</a>
    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">tmp</span><span class="o">=</span><span class="n">oset</span><span class="p">()</span>
        <span class="n">tmp</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span></div>

<div class="viewcode-block" id="oset.add">
<a class="viewcode-back" href="../progdoc.html#C13_ftbl.oset.add">[docs]</a>
    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span></div>

<div class="viewcode-block" id="oset.difference_update">
<a class="viewcode-back" href="../progdoc.html#C13_ftbl.oset.difference_update">[docs]</a>
    <span class="k">def</span> <span class="nf">difference_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">del</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">])</span></div>

<div class="viewcode-block" id="oset.difference">
<a class="viewcode-back" href="../progdoc.html#C13_ftbl.oset.difference">[docs]</a>
    <span class="k">def</span> <span class="nf">difference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span><span class="p">(</span><span class="bp">self</span> <span class="o">-</span> <span class="n">oset</span><span class="p">(</span><span class="n">x</span><span class="p">))</span></div>

<div class="viewcode-block" id="oset.update">
<a class="viewcode-back" href="../progdoc.html#C13_ftbl.oset.update">[docs]</a>
    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">x</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span></div>

<div class="viewcode-block" id="oset.intersection">
<a class="viewcode-back" href="../progdoc.html#C13_ftbl.oset.intersection">[docs]</a>
    <span class="k">def</span> <span class="nf">intersection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">&amp;</span> <span class="n">oset</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">tmp</span><span class="o">=</span><span class="n">oset</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">oset</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tmp</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__and__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">tmp</span><span class="o">=</span><span class="n">oset</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">oset</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tmp</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">tmp</span><span class="o">=</span><span class="n">oset</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">tmp</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tmp</span></div>


<span class="n">BOMS</span> <span class="o">=</span> <span class="p">(</span>
    <span class="p">(</span><span class="n">BOM_UTF8</span><span class="p">,</span> <span class="s2">&quot;UTF-8&quot;</span><span class="p">),</span>
    <span class="p">(</span><span class="n">BOM_UTF32_BE</span><span class="p">,</span> <span class="s2">&quot;UTF-32-BE&quot;</span><span class="p">),</span>
    <span class="p">(</span><span class="n">BOM_UTF32_LE</span><span class="p">,</span> <span class="s2">&quot;UTF-32-LE&quot;</span><span class="p">),</span>
    <span class="p">(</span><span class="n">BOM_UTF16_BE</span><span class="p">,</span> <span class="s2">&quot;UTF-16-BE&quot;</span><span class="p">),</span>
    <span class="p">(</span><span class="n">BOM_UTF16_LE</span><span class="p">,</span> <span class="s2">&quot;UTF-16-LE&quot;</span><span class="p">),</span>
<span class="p">)</span>

<span class="k">try</span><span class="p">:</span> <span class="n">werr</span>
<span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span> <span class="n">werr</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span>
<span class="k">try</span><span class="p">:</span> <span class="n">wout</span>
<span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span> <span class="n">wout</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span>

<span class="n">me</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">realpath</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">dirx</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">me</span><span class="p">)</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dirx</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">tools_ssg</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">NaN</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;nan&quot;</span><span class="p">)</span>
<span class="n">NA</span><span class="o">=</span><span class="n">NaN</span>
<span class="n">tol</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="o">.</span><span class="n">epsilon</span><span class="o">*</span><span class="mi">2</span><span class="o">**</span><span class="mi">7</span>
<span class="n">float_conv</span><span class="o">=</span><span class="n">oset</span><span class="p">((</span>
    <span class="s2">&quot;VALUE&quot;</span><span class="p">,</span>
    <span class="s2">&quot;DEVIATION&quot;</span><span class="p">,</span>
    <span class="s2">&quot;OPT_VALUE&quot;</span><span class="p">,</span>
    <span class="s2">&quot;META_SIZE&quot;</span><span class="p">,</span>
    <span class="s2">&quot;VALUE_S&quot;</span><span class="p">,</span>
    <span class="s2">&quot;VALUE_D-&quot;</span><span class="p">,</span>
    <span class="s2">&quot;VALUE_D+&quot;</span><span class="p">,</span>
    <span class="s2">&quot;VALUE_DD&quot;</span><span class="p">,</span>
    <span class="s2">&quot;VALUE(F/C)&quot;</span><span class="p">,</span>
<span class="p">))</span>
<span class="c1"># define legal sections/subsections</span>
<span class="n">defsec</span><span class="o">=</span><span class="p">{</span>
    <span class="s2">&quot;PROJECT&quot;</span><span class="p">:</span> <span class="n">oset</span><span class="p">(),</span>
    <span class="s2">&quot;NETWORK&quot;</span><span class="p">:</span> <span class="n">oset</span><span class="p">(),</span>
    <span class="s2">&quot;NOTRACER_NETWORK&quot;</span><span class="p">:</span> <span class="n">oset</span><span class="p">((</span><span class="s2">&quot;FLUX_NAME&quot;</span><span class="p">,</span> <span class="s2">&quot;EQUATION&quot;</span><span class="p">)),</span>
    <span class="s2">&quot;FLUXES&quot;</span><span class="p">:</span> <span class="n">oset</span><span class="p">((</span><span class="s2">&quot;NET&quot;</span><span class="p">,</span> <span class="s2">&quot;XCH&quot;</span><span class="p">)),</span>
    <span class="s2">&quot;EQUALITIES&quot;</span><span class="p">:</span> <span class="n">oset</span><span class="p">((</span><span class="s2">&quot;NET&quot;</span><span class="p">,</span> <span class="s2">&quot;XCH&quot;</span><span class="p">,</span> <span class="s2">&quot;METAB&quot;</span><span class="p">)),</span>
    <span class="s2">&quot;INEQUALITIES&quot;</span><span class="p">:</span> <span class="n">oset</span><span class="p">((</span><span class="s2">&quot;NET&quot;</span><span class="p">,</span> <span class="s2">&quot;XCH&quot;</span><span class="p">,</span> <span class="s2">&quot;METAB&quot;</span><span class="p">)),</span>
    <span class="s2">&quot;LABEL_INPUT&quot;</span><span class="p">:</span> <span class="n">oset</span><span class="p">(),</span>
    <span class="s2">&quot;FLUX_MEASUREMENTS&quot;</span><span class="p">:</span> <span class="n">oset</span><span class="p">(),</span>
    <span class="s2">&quot;LABEL_MEASUREMENTS&quot;</span><span class="p">:</span> <span class="n">oset</span><span class="p">(),</span>
    <span class="s2">&quot;PEAK_MEASUREMENTS&quot;</span><span class="p">:</span> <span class="n">oset</span><span class="p">(),</span>
    <span class="s2">&quot;MASS_SPECTROMETRY&quot;</span><span class="p">:</span> <span class="n">oset</span><span class="p">(),</span>
    <span class="s2">&quot;METAB_MEASUREMENTS&quot;</span><span class="p">:</span> <span class="n">oset</span><span class="p">(),</span>
    <span class="s2">&quot;OPTIONS&quot;</span><span class="p">:</span> <span class="n">oset</span><span class="p">(),</span>
    <span class="s2">&quot;METABOLITE_POOLS&quot;</span><span class="p">:</span> <span class="n">oset</span><span class="p">(),</span>
<span class="p">}</span>
<span class="c1"># at least one of these fields required to be in prl_exp ftbls</span>
<span class="n">req_prl</span><span class="o">=</span><span class="p">(</span>
    <span class="s2">&quot;LABEL_INPUT&quot;</span><span class="p">,</span>
    <span class="s2">&quot;LABEL_MEASUREMENTS&quot;</span><span class="p">,</span>
    <span class="s2">&quot;PEAK_MEASUREMENTS&quot;</span><span class="p">,</span>
    <span class="s2">&quot;MASS_SPECTROMETRY&quot;</span>
<span class="p">)</span>
<span class="k">if</span> <span class="s2">&quot;ffguess&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">locals</span><span class="p">():</span>
    <span class="n">ffguess</span><span class="o">=</span><span class="kc">False</span>
<span class="n">aeval</span><span class="o">.</span><span class="n">symtable</span><span class="o">=</span><span class="nb">globals</span><span class="p">()</span>
<div class="viewcode-block" id="eval_expr">
<a class="viewcode-back" href="../progdoc.html#C13_ftbl.eval_expr">[docs]</a>
<span class="k">def</span> <span class="nf">eval_expr</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">werr</span><span class="o">=</span><span class="n">werr</span><span class="p">):</span>
    <span class="n">res</span><span class="o">=</span><span class="n">aeval</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">aeval</span><span class="o">.</span><span class="n">error</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">werr</span><span class="p">:</span>
            <span class="n">werr</span><span class="p">(</span><span class="s2">&quot;In expression &#39;&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;&#39; got errors:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">err</span><span class="o">.</span><span class="n">get_error</span><span class="p">())</span> <span class="k">for</span> <span class="n">err</span> <span class="ow">in</span> <span class="n">aeval</span><span class="o">.</span><span class="n">error</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="ftbl_parse">
<a class="viewcode-back" href="../progdoc.html#C13_ftbl.ftbl_parse">[docs]</a>
<span class="k">def</span> <span class="nf">ftbl_parse</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">wout</span><span class="o">=</span><span class="n">wout</span><span class="p">,</span> <span class="n">werr</span><span class="o">=</span><span class="n">werr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;ftbl_parse(f) -&gt; dict</span>
<span class="sd">    read and parse .ftbl file. The only input parameter f is a stream pointer</span>
<span class="sd">    with read permission or a file name.</span>
<span class="sd">    This function parses the input and returns a dictionnary</span>
<span class="sd">    with items corresponding to sections in .ftbl. One section is added.</span>
<span class="sd">    &quot;TRANS&quot; correponds to carbon transitions.&quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">re</span>
    <span class="kn">import</span> <span class="nn">codecs</span>
    <span class="n">ftbl</span><span class="o">=</span><span class="nb">dict</span><span class="p">();</span>    <span class="c1"># main dictionary to be returned</span>
    
    <span class="c1">#print(&quot;f=&quot;, f)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isstr</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
        <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;parameter &#39;f&#39; must be a string with FTBL file name&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">f</span><span class="p">[</span><span class="o">-</span><span class="mi">5</span><span class="p">:]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">!=</span> <span class="s2">&quot;.ftbl&quot;</span><span class="p">:</span>
        <span class="n">f</span><span class="o">=</span><span class="n">f</span><span class="o">+</span><span class="s2">&quot;.ftbl&quot;</span>
    <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">f</span>
    <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;base_name&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">f</span><span class="p">)[:</span><span class="o">-</span><span class="mi">5</span><span class="p">]</span>
    <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;abs_path&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="n">fc</span><span class="o">=</span><span class="nb">open</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span>
    <span class="n">raw</span><span class="o">=</span><span class="n">fc</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
    <span class="n">fc</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">co</span><span class="o">=</span><span class="p">[</span><span class="n">encoding</span> <span class="k">for</span> <span class="n">bom</span><span class="p">,</span> <span class="n">encoding</span> <span class="ow">in</span> <span class="n">BOMS</span> <span class="k">if</span> <span class="n">raw</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">bom</span><span class="p">)]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">co</span><span class="p">):</span>
        <span class="n">inp</span><span class="o">=</span><span class="n">raw</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">co</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">co</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;utf-8&quot;</span><span class="p">,</span> <span class="s2">&quot;latin9&quot;</span><span class="p">,</span> <span class="s2">&quot;utf-16&quot;</span><span class="p">,</span> <span class="s2">&quot;utf-32&quot;</span><span class="p">]:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">inp</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">raw</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">co</span><span class="p">)</span> <span class="k">if</span> <span class="n">c</span> <span class="o">!=</span> <span class="s1">&#39;</span><span class="se">\x00</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">except</span> <span class="ne">UnicodeDecodeError</span><span class="p">:</span>
                <span class="k">pass</span>
    <span class="c1">#pdb.set_trace()</span>
    <span class="n">inp</span><span class="o">=</span><span class="n">inp</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;utf-8-sig&quot;</span><span class="p">)</span>
    <span class="n">lines</span><span class="o">=</span><span class="n">inp</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
    <span class="c1"># fc=codecs.open(f, &quot;r&quot;, encoding=&quot;utf-32&quot;)</span>
    <span class="c1"># try:</span>
        <span class="c1"># lines=fc.readlines()</span>
        <span class="c1"># fc.close()</span>
    <span class="c1"># except:</span>
        <span class="c1"># fc.close()</span>
        <span class="c1"># try:</span>
            <span class="c1"># fc=codecs.open(f, &quot;r&quot;, encoding=&quot;utf-16&quot;)</span>
            <span class="c1"># lines=fc.readlines()</span>
            <span class="c1"># fc.close()</span>
        <span class="c1"># except:</span>
            <span class="c1"># fc.close()</span>
            <span class="c1"># try:</span>
                <span class="c1"># fc=codecs.open(f, &quot;r&quot;, encoding=&quot;utf-8-sig&quot;)</span>
                <span class="c1"># lines=fc.readlines()</span>
                <span class="c1"># fc.close()</span>
            <span class="c1"># except:</span>
                <span class="c1"># fc.close()</span>
                <span class="c1"># fc=open(f, &quot;r&quot;)</span>
                <span class="c1"># lines=fc.readlines()</span>
                <span class="c1"># fc.close()</span>
    <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;pathway&quot;</span><span class="p">]</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span>
    
    <span class="c1">#print f;##</span>
    <span class="n">reblank</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;^[\t ]*$&quot;</span><span class="p">)</span>
    <span class="n">recomm</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;^[\t ]*//.*$&quot;</span><span class="p">)</span>
    <span class="n">repath</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;^[\t ]*//##[\t ]*(.*)[\t ]*$&quot;</span><span class="p">)</span>
    <span class="n">comm</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;^([^(//)]+|.+)//.*$&quot;</span><span class="p">)</span>
    <span class="n">reading</span><span class="o">=</span><span class="s2">&quot;sec_name&quot;</span>
    <span class="n">col_names</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">sec_name</span><span class="o">=</span><span class="n">subsec_name</span><span class="o">=</span><span class="s2">&quot;&quot;</span>
    <span class="n">irow</span><span class="o">=</span><span class="mi">0</span>
    <span class="n">dic</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span>
    <span class="n">pathway</span><span class="o">=</span><span class="s2">&quot;&quot;</span>
    <span class="c1">#pdb.set_trace()</span>
    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
        <span class="n">irow</span><span class="o">+=</span><span class="mi">1</span>
        <span class="c1">#print &quot;raw l=&quot;+l;##</span>
        <span class="c1"># strip out \r</span>
        <span class="n">l</span><span class="o">=</span><span class="n">l</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="c1">#print &quot;-ctrl-r l=&quot;+l;##</span>
        <span class="c1"># strip out double quots</span>
        <span class="k">if</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">:</span> <span class="n">l</span><span class="o">=</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">:];</span>    <span class="c1"># very begining</span>
        <span class="c1">#print &quot;-fq l=&quot;+l;##</span>
        <span class="k">if</span> <span class="n">l</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">:</span> <span class="n">l</span><span class="o">=</span><span class="n">l</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>    <span class="c1"># very end</span>
        <span class="c1">#print &quot;-lq l=&quot;+l;##</span>
        <span class="n">l</span><span class="o">=</span><span class="n">l</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t\&quot;</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">);</span>    <span class="c1"># at the field begining</span>
        <span class="c1">#print &quot;-ffq l=&quot;+l;##</span>
        <span class="n">l</span><span class="o">=</span><span class="n">l</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\&quot;\t</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">);</span>    <span class="c1"># at the end</span>
        <span class="c1">#print &quot;-lfq l=&quot;+l;##</span>
        
        <span class="c1"># check for pathway name &quot;//## pathname&quot;</span>
        <span class="k">if</span> <span class="n">repath</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
            <span class="n">pathway</span><span class="o">=</span><span class="n">repath</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\1&quot;</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>
        <span class="c1"># skip comments and emty rows</span>
        <span class="k">if</span> <span class="n">recomm</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="ow">or</span> <span class="n">reblank</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">l</span><span class="p">):</span> <span class="k">continue</span>
        
        <span class="c1"># skip the comments at the end of the row</span>
        <span class="n">l</span><span class="o">=</span><span class="n">comm</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\1&quot;</span><span class="p">,</span><span class="n">l</span><span class="p">)</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>
        
        <span class="c1"># split in fields</span>
        <span class="n">flds</span><span class="o">=</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="c1">#print &quot;proceeding:&quot;+l;##</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">flds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># new section starts here</span>
            <span class="n">sec_name</span><span class="o">=</span><span class="n">flds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">subsec_name</span><span class="o">=</span><span class="s2">&quot;&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">sec_name</span> <span class="ow">in</span> <span class="n">defsec</span><span class="p">:</span>
                <span class="c1">#pdb.set_trace()</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;FTBL: Illegal section name &#39;</span><span class="si">%s</span><span class="s2">&#39; (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%d</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">sec_name</span><span class="p">,</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">irow</span><span class="p">))</span>
            <span class="c1"># prepare storage</span>
            <span class="n">ftbl</span><span class="p">[</span><span class="n">sec_name</span><span class="p">]</span><span class="o">=</span><span class="p">[]</span>
            <span class="c1"># prepare storage for carbon transitions</span>
            <span class="k">if</span> <span class="n">sec_name</span><span class="o">==</span><span class="s2">&quot;NETWORK&quot;</span><span class="p">:</span>
               <span class="c1">#print &quot;TRANS prepared&quot;;##</span>
               <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;TRANS&quot;</span><span class="p">]</span><span class="o">=</span><span class="p">[]</span>
            <span class="k">try</span><span class="p">:</span> <span class="k">del</span> <span class="n">stock</span>
            <span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span> <span class="k">pass</span>
            <span class="n">stock</span><span class="o">=</span><span class="n">ftbl</span><span class="p">[</span><span class="n">sec_name</span><span class="p">]</span>
            <span class="n">skiptab</span><span class="o">=</span><span class="mi">1</span>
            <span class="n">data_count</span><span class="o">=</span><span class="mi">0</span>
            <span class="n">reading</span><span class="o">=</span><span class="s2">&quot;col_names&quot;</span>
            <span class="n">col_names</span><span class="o">=</span><span class="p">[]</span>
            <span class="n">subsec_name</span><span class="o">=</span><span class="s2">&quot;&quot;</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">flds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">flds</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># read subsection name or what ?</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sec_name</span><span class="p">)</span> <span class="ow">and</span> <span class="n">sec_name</span> <span class="ow">in</span> <span class="n">defsec</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">defsec</span><span class="p">[</span><span class="n">sec_name</span><span class="p">]):</span>
                <span class="c1"># we are expecting a subsection</span>
                <span class="n">subsec_name</span><span class="o">=</span><span class="n">flds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">subsec_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">defsec</span><span class="p">[</span><span class="n">sec_name</span><span class="p">]:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;A subsection &#39;</span><span class="si">%s</span><span class="s2">&#39; cannot appear in the section &#39;</span><span class="si">%s</span><span class="s2">&#39; (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%d</span><span class="s2">).&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">subsec_name</span><span class="p">,</span> <span class="n">sec_name</span><span class="p">,</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">irow</span><span class="p">))</span>
                <span class="c1"># prepare sub-storage</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">ftbl</span><span class="p">[</span><span class="n">sec_name</span><span class="p">]:</span>
                    <span class="c1"># replace an empty list by an empty dictionary</span>
                    <span class="n">ftbl</span><span class="p">[</span><span class="n">sec_name</span><span class="p">]</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span>
                <span class="c1">#print (irow, reading)##</span>
                <span class="n">ftbl</span><span class="p">[</span><span class="n">sec_name</span><span class="p">][</span><span class="n">subsec_name</span><span class="p">]</span><span class="o">=</span><span class="p">[]</span>
                <span class="k">try</span><span class="p">:</span> <span class="k">del</span> <span class="n">stock</span>
                <span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span> <span class="k">pass</span>
                <span class="n">stock</span><span class="o">=</span><span class="n">ftbl</span><span class="p">[</span><span class="n">sec_name</span><span class="p">][</span><span class="n">subsec_name</span><span class="p">]</span>
                <span class="n">skiptab</span><span class="o">=</span><span class="mi">2</span>
                <span class="n">data_count</span><span class="o">=</span><span class="mi">0</span>
                <span class="n">reading</span><span class="o">=</span><span class="s2">&quot;col_names&quot;</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># just a very short line</span>
                <span class="c1"># it will fall in plain reading data</span>
                <span class="k">pass</span>
        <span class="k">if</span> <span class="n">reading</span><span class="o">==</span><span class="s2">&quot;col_names&quot;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">flds</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># read column names</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">skiptab</span> <span class="ow">or</span> <span class="n">l</span><span class="p">[:</span><span class="n">skiptab</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="o">*</span><span class="n">skiptab</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Expected at least </span><span class="si">%d</span><span class="s2"> tabulation(s) at the row beginning. Got &#39;</span><span class="si">%s</span><span class="s2">&#39; (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%d</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">skiptab</span><span class="p">,</span> <span class="n">l</span><span class="p">[:</span><span class="nb">min</span><span class="p">(</span><span class="n">skiptab</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">))],</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">irow</span><span class="p">))</span>
            <span class="n">col_names</span><span class="o">=</span><span class="n">l</span><span class="p">[</span><span class="n">skiptab</span><span class="p">:]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">([</span> <span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">col_names</span> <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;^\s*$&quot;</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span> <span class="p">]):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;FTBL: row </span><span class="si">%d</span><span class="s2"> has empty column names:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">irow</span><span class="p">,</span><span class="n">l</span><span class="p">))</span>
            <span class="n">reading</span><span class="o">=</span><span class="s2">&quot;data&quot;</span>
            <span class="c1">#print &quot;col_names=&quot;, col_names;##</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">reading</span><span class="o">==</span><span class="s2">&quot;data&quot;</span> <span class="ow">or</span> <span class="n">reading</span><span class="o">==</span><span class="s2">&quot;transitions&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">skiptab</span> <span class="ow">or</span> <span class="n">l</span><span class="p">[:</span><span class="n">skiptab</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="o">*</span><span class="n">skiptab</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Expected at least </span><span class="si">%d</span><span class="s2"> tabulation(s) at the row beginning. Got &#39;</span><span class="si">%s</span><span class="s2">&#39; (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%d</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">skiptab</span><span class="p">,</span> <span class="n">l</span><span class="p">[:</span><span class="nb">min</span><span class="p">(</span><span class="n">skiptab</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">))],</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">irow</span><span class="p">))</span>
            <span class="n">data</span><span class="o">=</span><span class="p">[</span><span class="n">it</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">l</span><span class="p">[</span><span class="n">skiptab</span><span class="p">:]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">)]</span>
            <span class="n">prevdic</span><span class="o">=</span><span class="n">dic</span>
            <span class="n">dic</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;irow&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">irow</span><span class="p">)}</span>
            <span class="k">if</span> <span class="n">reading</span><span class="o">==</span><span class="s2">&quot;data&quot;</span> <span class="ow">and</span> <span class="n">sec_name</span> <span class="o">==</span> <span class="s2">&quot;NETWORK&quot;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">reading</span><span class="o">=</span><span class="s2">&quot;transitions&quot;</span>
            <span class="k">elif</span> <span class="n">reading</span><span class="o">==</span><span class="s2">&quot;transitions&quot;</span><span class="p">:</span>
                <span class="c1"># here, we are at carbon transition line (e.g. #ABC -&gt; #AB +#C)</span>
                <span class="c1">#print &quot;data_count=&quot;+str(data_count), \</span>
                <span class="c1">#    &quot;\ndata=&quot;+str([l for l in enumerate(data)]), \</span>
                <span class="c1">#    &quot;\nstock=&quot;+str(stock);##</span>
                <span class="k">if</span> <span class="n">sec_name</span> <span class="o">==</span> <span class="s2">&quot;NETWORK&quot;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Expected label transitions. Got &#39;</span><span class="si">%s</span><span class="s2">&#39; (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%d</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">irow</span><span class="p">))</span>
                <span class="n">reading</span><span class="o">=</span><span class="s2">&quot;data&quot;</span>
                <span class="n">fl_name</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">stock</span><span class="p">[</span><span class="n">data_count</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">col_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="k">if</span> <span class="n">data_count</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
                <span class="k">if</span> <span class="n">col_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">prevdic</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">prevdic</span><span class="p">[</span><span class="n">col_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Carbon transition row &#39;</span><span class="si">%s</span><span class="s2">&#39; is orphan (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%d</span><span class="s2">).&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="n">skiptab</span><span class="p">:],</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">irow</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">col_names</span><span class="p">)):</span>
                    <span class="n">item</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
                    <span class="n">dic</span><span class="p">[</span><span class="n">col_names</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">=</span><span class="n">item</span>
                    <span class="n">metab</span><span class="o">=</span><span class="n">stock</span><span class="p">[</span><span class="n">data_count</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">col_names</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">metab</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">metab</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">))):</span>
                        <span class="c1">#print &quot;i=%d, co=&#39;%s&#39;, m=&#39;%s&#39;, tr=&#39;%s&#39;;&quot;%(i, col_names[i], metab, item)</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;In the reaction &#39;</span><span class="si">%s</span><span class="s2">&#39;, metabolites are misaligned with carbon transitions (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%d</span><span class="s2">).&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">fl_name</span><span class="p">,</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">irow</span><span class="p">))</span>
                <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;TRANS&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dic</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">col_names</span><span class="p">)):</span>
                <span class="c1"># classic data</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">col_names</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;FTBL: data have more columns (</span><span class="si">%d</span><span class="s2">) than column names (</span><span class="si">%d</span><span class="s2">) (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%d</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">col_names</span><span class="p">),</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">irow</span><span class="p">))</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># decimal point conversion</span>
                    <span class="n">dic</span><span class="p">[</span><span class="n">col_names</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
                    <span class="k">if</span> <span class="n">col_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="n">float_conv</span><span class="p">:</span>
                        <span class="n">oldval</span><span class="o">=</span><span class="n">dic</span><span class="p">[</span><span class="n">col_names</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                        <span class="n">val</span><span class="o">=</span><span class="n">oldval</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="s2">&quot;.&quot;</span><span class="p">)</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">fval</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                            <span class="n">dic</span><span class="p">[</span><span class="n">col_names</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">=</span><span class="n">val</span>
                        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                            <span class="n">dic</span><span class="p">[</span><span class="n">col_names</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">=</span><span class="n">oldval</span>
                <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                    <span class="k">pass</span>
            <span class="c1">#import pdb; pdb.set_trace()</span>
            <span class="k">if</span> <span class="n">sec_name</span> <span class="o">==</span> <span class="s2">&quot;NETWORK&quot;</span> <span class="ow">and</span> <span class="n">pathway</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">pathway</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;pathway&quot;</span><span class="p">]:</span>
                    <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;pathway&quot;</span><span class="p">][</span><span class="n">pathway</span><span class="p">]</span><span class="o">=</span><span class="p">[]</span>
                <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;pathway&quot;</span><span class="p">][</span><span class="n">pathway</span><span class="p">]</span><span class="o">+=</span><span class="p">[</span><span class="n">dic</span><span class="p">[</span><span class="s2">&quot;FLUX_NAME&quot;</span><span class="p">]]</span>
            <span class="k">if</span> <span class="n">sec_name</span> <span class="o">==</span> <span class="s2">&quot;FLUXES&quot;</span> <span class="ow">and</span> <span class="n">subsec_name</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;NET&quot;</span><span class="p">,</span> <span class="s2">&quot;XCH&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">dic</span><span class="p">[</span><span class="s2">&quot;FCD&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;F&quot;</span><span class="p">,</span> <span class="s2">&quot;C&quot;</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">val</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">eval_expr</span><span class="p">(</span><span class="n">dic</span><span class="p">[</span><span class="s2">&quot;VALUE(F/C)&quot;</span><span class="p">]))</span>
                <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;In the field &#39;VALUE(F/C)&#39;, a float value expected (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%d</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">irow</span><span class="p">))</span>
            <span class="n">stock</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dic</span><span class="p">)</span>
            <span class="n">data_count</span><span class="o">+=</span><span class="mi">1</span>
            <span class="c1">#print &quot;sec, subsec=&quot;, sec_name, subsec_name, data_count, dic;##</span>
        <span class="c1">#print &quot;len(flds)=&quot;, len(flds), flds, l, data;##</span>
        <span class="c1">#print &quot;keys&quot;, ftbl.keys(), (ftbl[sec_name].keys() \</span>
        <span class="c1">#        if type(ftbl[sec_name])==type({}) else &quot;&quot;);##</span>
    <span class="k">if</span> <span class="s2">&quot;NETWORK&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ftbl</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ftbl</span>
    <span class="c1"># prepare translator reac -&gt; pathway</span>
    <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;reac2path&quot;</span><span class="p">]</span><span class="o">=</span><span class="nb">dict</span><span class="p">((</span><span class="n">reac</span><span class="p">,</span><span class="n">path</span><span class="p">)</span> <span class="k">for</span> <span class="n">path</span><span class="p">,</span><span class="n">li</span> <span class="ow">in</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;pathway&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">for</span> <span class="n">reac</span> <span class="ow">in</span> <span class="n">li</span><span class="p">)</span>
    <span class="c1"># assemble reactions with the same name in one</span>
    <span class="c1"># long_reac={reac: {&quot;left&quot;: [(minp1, 1), (minp2, 1), ...], &quot;right&quot;: [(mout1, 1), (mout2, 1), ...]}</span>
    <span class="c1"># and carbon transitions</span>
    <span class="c1"># long_trans={reac: {&quot;left&quot;: [minp1, minp2, ...], &quot;right&quot;: [mout1, mout2, ...]}</span>
    <span class="c1"># get unique reaction names</span>
    <span class="n">nw</span><span class="o">=</span><span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;NETWORK&quot;</span><span class="p">]</span>
    <span class="n">tr</span><span class="o">=</span><span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;TRANS&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nw</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tr</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Number of reactions (</span><span class="si">%d</span><span class="s2">) is not equal to label transition number (</span><span class="si">%d</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nw</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">tr</span><span class="p">))</span> <span class="p">)</span>
    <span class="n">ureac</span><span class="o">=</span><span class="n">oset</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;FLUX_NAME&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;NETWORK&quot;</span><span class="p">])</span>
    <span class="n">long_reac</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span>
    <span class="n">long_trans</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">reac</span> <span class="ow">in</span> <span class="n">ureac</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">reac</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">long_reac</span><span class="p">:</span>
            <span class="n">long_reac</span><span class="p">[</span><span class="n">reac</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;left&quot;</span><span class="p">:</span> <span class="p">[],</span> <span class="s2">&quot;right&quot;</span><span class="p">:</span> <span class="p">[]}</span>
            <span class="n">long_trans</span><span class="p">[</span><span class="n">reac</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;left&quot;</span><span class="p">:</span> <span class="p">[],</span> <span class="s2">&quot;right&quot;</span><span class="p">:</span> <span class="p">[]}</span>
        <span class="c1"># get rows</span>
        <span class="n">irows</span><span class="o">=</span><span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">row</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nw</span><span class="p">)</span> <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;FLUX_NAME&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">reac</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">irows</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># check that rows are contiguous</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="n">i</span><span class="o">+</span><span class="n">irows</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">r</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">irows</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Reaction &#39;</span><span class="si">%s</span><span class="s2">&#39; is split on non contiguous rows: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">reac</span><span class="p">,</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">nw</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s2">&quot;irow&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">irows</span><span class="p">)))</span>
        <span class="n">long_reac</span><span class="p">[</span><span class="n">reac</span><span class="p">][</span><span class="s2">&quot;irow&quot;</span><span class="p">]</span><span class="o">=</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">nw</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s2">&quot;irow&quot;</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">irows</span><span class="p">)</span>
        <span class="n">long_reac</span><span class="p">[</span><span class="n">reac</span><span class="p">][</span><span class="s2">&quot;left&quot;</span><span class="p">]</span><span class="o">+=</span><span class="p">[</span><span class="n">mecoparse</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">irows</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="p">(</span><span class="n">nw</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s2">&quot;EDUCT_1&quot;</span><span class="p">],</span> <span class="n">nw</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s2">&quot;EDUCT_2&quot;</span><span class="p">])</span> <span class="k">if</span> <span class="n">m</span><span class="p">]</span>
        <span class="n">long_reac</span><span class="p">[</span><span class="n">reac</span><span class="p">][</span><span class="s2">&quot;right&quot;</span><span class="p">]</span><span class="o">+=</span><span class="p">[</span><span class="n">mecoparse</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">irows</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="p">(</span><span class="n">nw</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s2">&quot;PRODUCT_1&quot;</span><span class="p">],</span> <span class="n">nw</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s2">&quot;PRODUCT_2&quot;</span><span class="p">])</span> <span class="k">if</span> <span class="n">m</span><span class="p">]</span>
        <span class="n">long_trans</span><span class="p">[</span><span class="n">reac</span><span class="p">][</span><span class="s2">&quot;irow&quot;</span><span class="p">]</span><span class="o">=</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">tr</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s2">&quot;irow&quot;</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">irows</span><span class="p">)</span>
        <span class="n">long_trans</span><span class="p">[</span><span class="n">reac</span><span class="p">][</span><span class="s2">&quot;left&quot;</span><span class="p">]</span><span class="o">+=</span><span class="p">[</span><span class="n">m</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">irows</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="p">(</span><span class="n">tr</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s2">&quot;EDUCT_1&quot;</span><span class="p">],</span> <span class="n">tr</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s2">&quot;EDUCT_2&quot;</span><span class="p">])</span> <span class="k">if</span> <span class="n">m</span><span class="p">]</span>
        <span class="n">long_trans</span><span class="p">[</span><span class="n">reac</span><span class="p">][</span><span class="s2">&quot;right&quot;</span><span class="p">]</span><span class="o">+=</span><span class="p">[</span><span class="n">m</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">irows</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="p">(</span><span class="n">tr</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s2">&quot;PRODUCT_1&quot;</span><span class="p">],</span> <span class="n">tr</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s2">&quot;PRODUCT_2&quot;</span><span class="p">])</span> <span class="k">if</span> <span class="n">m</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">lr</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="s2">&quot;right&quot;</span><span class="p">):</span>
            <span class="n">nmet</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">long_reac</span><span class="p">[</span><span class="n">reac</span><span class="p">][</span><span class="n">lr</span><span class="p">])</span>
            <span class="n">ncarb</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">long_trans</span><span class="p">[</span><span class="n">reac</span><span class="p">][</span><span class="n">lr</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">nmet</span> <span class="o">!=</span> <span class="n">ncarb</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Number of metabolites (</span><span class="si">%d</span><span class="s2">) and carbon strings (</span><span class="si">%d</span><span class="s2">) on the </span><span class="si">%s</span><span class="s2"> hand side of reaction &#39;reac&#39; must be equal (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">nmet</span><span class="p">,</span> <span class="n">ncarb</span><span class="p">,</span> <span class="n">lr</span><span class="p">,</span> <span class="n">reac</span><span class="p">,</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">long_reac</span><span class="p">[</span><span class="n">reac</span><span class="p">][</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
    <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;long_reac&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">long_reac</span>
    <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;long_trans&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">long_trans</span>
    <span class="k">return</span> <span class="n">ftbl</span></div>


<div class="viewcode-block" id="ftbl_netan">
<a class="viewcode-back" href="../progdoc.html#C13_ftbl.ftbl_netan">[docs]</a>
<span class="k">def</span> <span class="nf">ftbl_netan</span><span class="p">(</span><span class="n">ftbl</span><span class="p">,</span> <span class="n">netan</span><span class="p">,</span> <span class="n">emu_framework</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fullsys</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">case_i</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">wout</span><span class="o">=</span><span class="n">wout</span><span class="p">,</span> <span class="n">werr</span><span class="o">=</span><span class="n">werr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    analyse ftbl dictionary to find</span>
<span class="sd">     </span>
<span class="sd">     - network inputs (input)</span>
<span class="sd">     - network outputs (output)</span>
<span class="sd">     - substrates (subs)</span>
<span class="sd">     - products (prods)</span>
<span class="sd">     - metabolites (metabs)</span>
<span class="sd">     - reactions (reacs)</span>
<span class="sd">     - not reversible reactions (subset of reacs) (notrev)</span>
<span class="sd">       all above items are in named sets</span>
<span class="sd">     - stocheometric matrix (sto_r_m)</span>
<span class="sd">     - stocheometric matrix (sto_m_r)</span>
<span class="sd">     - fwd-rev flux matrix (flux_m_r)</span>
<span class="sd">     - cumomer balances (cumo_m_r_m)</span>
<span class="sd">     - carbon length (Clen)</span>
<span class="sd">     - reaction formula (formula)</span>
<span class="sd">     - metabolite network (metab_netw)</span>
<span class="sd">     - carbon transitions (carbotrans)</span>
<span class="sd">     - free fluxes (flux_free)</span>
<span class="sd">     - constrained fluxes (flux_constr)</span>
<span class="sd">     - measured fluxes (flux_measured)</span>
<span class="sd">     - variable growth fluxes (flux_vgrowth)</span>
<span class="sd">     - input isotopomers (iso_input)</span>
<span class="sd">     - input isotopomers functions (funlab for case_i=True)</span>
<span class="sd">     - input cumomers (cumo_input)</span>
<span class="sd">     - input reduced cumomers (rcumo_input)</span>
<span class="sd">     - flux inequalities (flux_ineqal)</span>
<span class="sd">     - flux equalities (flux_eqal)</span>
<span class="sd">     - label measurements, H1 (label_meas)</span>
<span class="sd">     - peak measurements, C13 (peak_meas)</span>
<span class="sd">     - mass measurements (mass_meas)</span>
<span class="sd">     - cumomer ordered lists (vcumo)</span>
<span class="sd">     - unknown fluxes ordered lists (vflux)</span>
<span class="sd">     - linear problem on fluxes (Afl, bfl)</span>
<span class="sd">     - free fluxes ordered lists (vflux_free)</span>
<span class="sd">     - fw-rv fluxes ordered lists (vflux_fwrv)</span>
<span class="sd">     - row names ordered lists for Afl (vrowAfl)</span>
<span class="sd">     - in-out fluxes (flux_in, flux_out)</span>
<span class="sd">     - measured concentrations (metab_measured)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">eval_expr</span>
    <span class="n">eval_expr</span><span class="o">=</span><span class="n">partial</span><span class="p">(</span><span class="n">eval_expr</span><span class="p">,</span> <span class="n">werr</span><span class="o">=</span><span class="n">werr</span><span class="p">)</span>
    <span class="c1">#breakpoint()</span>
    <span class="c1"># init named sets</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">netan</span><span class="p">)</span><span class="o">!=</span><span class="nb">type</span><span class="p">(</span><span class="nb">dict</span><span class="p">()):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;netan argument must be a dictionary&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">netan</span><span class="p">:</span>
        <span class="n">netan</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
            <span class="s2">&quot;input&quot;</span><span class="p">:</span><span class="n">oset</span><span class="p">(),</span>
            <span class="s2">&quot;output&quot;</span><span class="p">:</span><span class="n">oset</span><span class="p">(),</span>
            <span class="s2">&quot;deadend&quot;</span><span class="p">:</span><span class="n">oset</span><span class="p">(),</span>
            <span class="s2">&quot;subs&quot;</span><span class="p">:</span><span class="n">oset</span><span class="p">(),</span>
            <span class="s2">&quot;prods&quot;</span><span class="p">:</span><span class="n">oset</span><span class="p">(),</span>
            <span class="s2">&quot;left&quot;</span><span class="p">:</span><span class="n">oset</span><span class="p">(),</span>
            <span class="s2">&quot;right&quot;</span><span class="p">:</span><span class="n">oset</span><span class="p">(),</span>
            <span class="s2">&quot;metabs&quot;</span><span class="p">:</span><span class="n">oset</span><span class="p">(),</span>
            <span class="s2">&quot;reac&quot;</span><span class="p">:</span><span class="n">oset</span><span class="p">(),</span>
            <span class="s2">&quot;notrev&quot;</span><span class="p">:</span><span class="n">oset</span><span class="p">(),</span>
            <span class="s2">&quot;sto_r_m&quot;</span><span class="p">:</span><span class="nb">dict</span><span class="p">(),</span>
            <span class="s2">&quot;sto_m_r&quot;</span><span class="p">:</span><span class="nb">dict</span><span class="p">(),</span>
            <span class="s2">&quot;flux_m_r&quot;</span><span class="p">:</span><span class="nb">dict</span><span class="p">(),</span>
            <span class="s2">&quot;cumo_balance_pattern&quot;</span><span class="p">:</span><span class="nb">dict</span><span class="p">(),</span>
            <span class="s2">&quot;Clen&quot;</span><span class="p">:</span><span class="nb">dict</span><span class="p">(),</span>
            <span class="s2">&quot;formula&quot;</span><span class="p">:</span><span class="nb">dict</span><span class="p">(),</span>
            <span class="s2">&quot;metab_netw&quot;</span><span class="p">:</span><span class="nb">dict</span><span class="p">(),</span>
            <span class="s2">&quot;cumo_sys&quot;</span><span class="p">:</span><span class="nb">dict</span><span class="p">(),</span>
            <span class="s2">&quot;carbotrans&quot;</span><span class="p">:</span><span class="nb">dict</span><span class="p">(),</span>
            <span class="s2">&quot;Cmax&quot;</span><span class="p">:</span><span class="nb">dict</span><span class="p">(),</span>
            <span class="s2">&quot;flux_dep&quot;</span><span class="p">:</span><span class="nb">dict</span><span class="p">(),</span>
            <span class="s2">&quot;flux_free&quot;</span><span class="p">:</span><span class="nb">dict</span><span class="p">(),</span>
            <span class="s2">&quot;flux_constr&quot;</span><span class="p">:</span><span class="nb">dict</span><span class="p">(),</span>
            <span class="s2">&quot;flux_measured&quot;</span><span class="p">:</span><span class="nb">dict</span><span class="p">(),</span>
            <span class="s2">&quot;iso_input&quot;</span><span class="p">:[],</span>
            <span class="s2">&quot;funlab&quot;</span><span class="p">:[],</span>
            <span class="s2">&quot;cumo_input&quot;</span><span class="p">:[],</span>
            <span class="s2">&quot;rcumo_input&quot;</span><span class="p">:[],</span>
            <span class="s2">&quot;emu_input&quot;</span><span class="p">:[],</span>
            <span class="s2">&quot;flux_inequal&quot;</span><span class="p">:{</span><span class="s2">&quot;net&quot;</span><span class="p">:[],</span> <span class="s2">&quot;xch&quot;</span><span class="p">:[]},</span>
            <span class="s2">&quot;flux_equal&quot;</span><span class="p">:{</span><span class="s2">&quot;net&quot;</span><span class="p">:[],</span> <span class="s2">&quot;xch&quot;</span><span class="p">:[]},</span>
            <span class="s2">&quot;label_meas&quot;</span><span class="p">:[],</span>
            <span class="s2">&quot;peak_meas&quot;</span><span class="p">:[],</span>
            <span class="s2">&quot;mass_meas&quot;</span><span class="p">:[],</span>
            <span class="s2">&quot;vcumo&quot;</span><span class="p">:[],</span>
            <span class="s2">&quot;Afl&quot;</span><span class="p">:[],</span>
            <span class="s2">&quot;bfl&quot;</span><span class="p">:[],</span>
            <span class="s2">&quot;vflux&quot;</span><span class="p">:{</span><span class="s2">&quot;net&quot;</span><span class="p">:[],</span> <span class="s2">&quot;xch&quot;</span><span class="p">:[],</span> <span class="s2">&quot;net2i&quot;</span><span class="p">:</span><span class="nb">dict</span><span class="p">(),</span> <span class="s2">&quot;xch2i&quot;</span><span class="p">:</span><span class="nb">dict</span><span class="p">()},</span>
            <span class="s2">&quot;vflux_free&quot;</span><span class="p">:{</span><span class="s2">&quot;net&quot;</span><span class="p">:[],</span> <span class="s2">&quot;xch&quot;</span><span class="p">:[],</span> <span class="s2">&quot;net2i&quot;</span><span class="p">:</span><span class="nb">dict</span><span class="p">(),</span> <span class="s2">&quot;xch2i&quot;</span><span class="p">:</span><span class="nb">dict</span><span class="p">()},</span>
            <span class="s2">&quot;vflux_constr&quot;</span><span class="p">:{</span><span class="s2">&quot;net&quot;</span><span class="p">:[],</span> <span class="s2">&quot;xch&quot;</span><span class="p">:[],</span> <span class="s2">&quot;net2i&quot;</span><span class="p">:</span><span class="nb">dict</span><span class="p">(),</span> <span class="s2">&quot;xch2i&quot;</span><span class="p">:</span><span class="nb">dict</span><span class="p">()},</span>
            <span class="s2">&quot;vflux_meas&quot;</span><span class="p">:{</span><span class="s2">&quot;net&quot;</span><span class="p">:[],</span> <span class="s2">&quot;net2i&quot;</span><span class="p">:</span><span class="nb">dict</span><span class="p">()},</span>
            <span class="s2">&quot;vflux_growth&quot;</span><span class="p">:{</span><span class="s2">&quot;net&quot;</span><span class="p">:[],</span> <span class="s2">&quot;net2i&quot;</span><span class="p">:</span><span class="nb">dict</span><span class="p">()},</span>
            <span class="s2">&quot;vflux_compl&quot;</span><span class="p">:{</span><span class="s2">&quot;net&quot;</span><span class="p">:[],</span> <span class="s2">&quot;xch&quot;</span><span class="p">:[],</span> <span class="s2">&quot;net2i&quot;</span><span class="p">:</span><span class="nb">dict</span><span class="p">(),</span> <span class="s2">&quot;xch2i&quot;</span><span class="p">:</span><span class="nb">dict</span><span class="p">()},</span>
            <span class="s2">&quot;vflux_fwrv&quot;</span><span class="p">:{</span><span class="s2">&quot;fw&quot;</span><span class="p">:[],</span> <span class="s2">&quot;rv&quot;</span><span class="p">:[],</span> <span class="s2">&quot;fw2i&quot;</span><span class="p">:</span><span class="nb">dict</span><span class="p">(),</span> <span class="s2">&quot;rv2i&quot;</span><span class="p">:</span><span class="nb">dict</span><span class="p">()},</span>
            <span class="s2">&quot;vrowAfl&quot;</span><span class="p">:[],</span>
            <span class="s2">&quot;flux_in&quot;</span><span class="p">:</span><span class="n">oset</span><span class="p">(),</span>
            <span class="s2">&quot;flux_out&quot;</span><span class="p">:</span><span class="n">oset</span><span class="p">(),</span>
            <span class="s2">&quot;flux_inout&quot;</span><span class="p">:</span><span class="n">oset</span><span class="p">(),</span>
            <span class="s2">&quot;opt&quot;</span><span class="p">:</span><span class="nb">dict</span><span class="p">(),</span>
            <span class="s2">&quot;met_pools&quot;</span><span class="p">:</span><span class="nb">dict</span><span class="p">(),</span>
            <span class="s2">&quot;nx2dfcg&quot;</span><span class="p">:</span><span class="nb">dict</span><span class="p">(),</span>
            <span class="s2">&quot;metab_measured&quot;</span><span class="p">:</span><span class="nb">dict</span><span class="p">(),</span>
        <span class="p">})</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;emu&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">emu_framework</span>
    <span class="n">res</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">;</span>     <span class="c1"># auxiliary short-cut to current result</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;exp_names&quot;</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;base_name&quot;</span><span class="p">]]</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;fullsys&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">fullsys</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;pathway&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;pathway&quot;</span><span class="p">]</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;reac2path&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;reac2path&quot;</span><span class="p">]</span>

    <span class="c1"># Isotopomer dynamics and other options</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">ftbl</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;OPTIONS&quot;</span><span class="p">,[]):</span>
        <span class="c1">#breakpoint()</span>
        <span class="n">val</span><span class="o">=</span><span class="n">eval_expr</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;OPT_VALUE&quot;</span><span class="p">],</span> <span class="n">werr</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;opt&quot;</span><span class="p">][</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;OPT_NAME&quot;</span><span class="p">]]</span><span class="o">=</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;OPT_VALUE&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">val</span>
    <span class="c1">#pdb.set_trace()</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">ftbl</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;METABOLITE_POOLS&quot;</span><span class="p">,[]):</span>
        <span class="n">metab</span><span class="o">=</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;META_NAME&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">metab</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;met_pools&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Metabolite &#39;</span><span class="si">%s</span><span class="s2">&#39; is present more than once in the</span><span class="se">\n</span><span class="s2">ftbl secion METABOLITE_POOLS (second appearance on row </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">metab</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
        <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;met_pools&quot;</span><span class="p">][</span><span class="n">metab</span><span class="p">]</span><span class="o">=</span><span class="n">eval_expr</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;META_SIZE&quot;</span><span class="p">])</span>

    <span class="c1"># check the presence of fields &quot;NAME&quot;, &quot;FCD&quot; and maybe &quot;VALUE(F/C)&quot;</span>
    <span class="k">for</span> <span class="n">suf</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;NET&quot;</span><span class="p">,</span> <span class="s2">&quot;XCH&quot;</span><span class="p">]:</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">ftbl</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;FLUXES&quot;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">())</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">suf</span><span class="p">,</span> <span class="nb">dict</span><span class="p">()):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="s2">&quot;NAME&quot;</span> <span class="ow">in</span> <span class="n">row</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;No required field NAME in section FLUX/</span><span class="si">%s</span><span class="s2"> (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">suf</span><span class="p">,</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="s2">&quot;FCD&quot;</span> <span class="ow">in</span> <span class="n">row</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;No requied field FCD in section FLUX/</span><span class="si">%s</span><span class="s2"> (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">suf</span><span class="p">,</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;FCD&quot;</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;F&quot;</span> <span class="ow">or</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;FCD&quot;</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;C&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="s2">&quot;VALUE(F/C)&quot;</span> <span class="ow">in</span> <span class="n">row</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;For flux &#39;</span><span class="si">%s</span><span class="s2">&#39; in section FLUX/</span><span class="si">%s</span><span class="s2">, the field &#39;VALUE(F/C)&#39; is requiered but is absent (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;NAME&quot;</span><span class="p">],</span> <span class="n">suf</span><span class="p">,</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
    <span class="c1"># quick consistency check between net and xch fluxes</span>
    <span class="n">fnet</span><span class="o">=</span><span class="n">oset</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;NAME&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">ftbl</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;FLUXES&quot;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">())</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;NET&quot;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">()))</span>
    <span class="n">fxch</span><span class="o">=</span><span class="n">oset</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;NAME&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">ftbl</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;FLUXES&quot;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">())</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;XCH&quot;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">()))</span>
    <span class="n">net_wo_xch</span><span class="o">=</span><span class="n">fnet</span><span class="o">-</span><span class="n">fxch</span>
    <span class="k">if</span> <span class="n">net_wo_xch</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Fluxe(s) &#39;</span><span class="si">%s</span><span class="s2">&#39; are defined in the FLUX/NET section but not in the XCH one.&quot;</span><span class="o">%</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="n">net_wo_xch</span><span class="p">))</span>
    <span class="n">xch_wo_net</span><span class="o">=</span><span class="n">fxch</span><span class="o">-</span><span class="n">fnet</span>
    <span class="k">if</span> <span class="n">xch_wo_net</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Fluxe(s) &#39;</span><span class="si">%s</span><span class="s2">&#39; are defined in the FLUX/XCH section but not in the NET one.&quot;</span><span class="o">%</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="n">xch_wo_net</span><span class="p">))</span>

    <span class="c1"># quick not reversible reactions for complete subs and prods accounting</span>
    <span class="n">revreac</span><span class="o">=</span><span class="n">oset</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;NAME&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">ftbl</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;FLUXES&quot;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">())</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;XCH&quot;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">())</span> <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;FCD&quot;</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;F&quot;</span> <span class="ow">or</span> <span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;FCD&quot;</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;C&quot;</span> <span class="ow">and</span> <span class="p">(</span><span class="n">eval_expr</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;VALUE(F/C)&quot;</span><span class="p">])</span> <span class="o">!=</span> <span class="mf">0.</span><span class="p">)))</span>
    <span class="c1"># analyse networks</span>
    <span class="n">netw</span><span class="o">=</span><span class="n">ftbl</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;long_reac&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">netw</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;No long_reac section in the ftbl parameter&quot;</span><span class="p">)</span>
    <span class="n">row_to_del</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">reac</span><span class="p">,</span> <span class="n">row</span><span class="p">)</span> <span class="ow">in</span> <span class="n">netw</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="c1">#print &quot;reac=&quot;+reac;#</span>
        <span class="c1"># corresponding carbon transition row</span>
        <span class="n">crow</span><span class="o">=</span><span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;long_trans&quot;</span><span class="p">][</span><span class="n">reac</span><span class="p">]</span>
        <span class="c1"># local substrate (es), product (ps) and metabolites (ms) sets</span>
        <span class="n">es</span><span class="o">=</span><span class="n">oset</span><span class="p">(</span><span class="n">m</span> <span class="k">for</span> <span class="n">m</span><span class="p">,</span><span class="n">_</span> <span class="ow">in</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;left&quot;</span><span class="p">])</span>
        <span class="n">ps</span><span class="o">=</span><span class="n">oset</span><span class="p">(</span><span class="n">m</span> <span class="k">for</span> <span class="n">m</span><span class="p">,</span><span class="n">_</span> <span class="ow">in</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;right&quot;</span><span class="p">])</span>
        <span class="n">ms</span><span class="o">=</span><span class="n">es</span><span class="o">|</span><span class="n">ps</span>
        <span class="c1">#if es&amp;ps:</span>
        <span class="c1">#   raise Exception(&quot;The same metabolite(s) &#39;%s&#39; are present in both sides of a reaction &#39;%s&#39; (%s: %s).&quot;%(join(&quot;, &quot;, es&amp;ps), reac, ftbl[&quot;name&quot;], row[&quot;irow&quot;]))</span>
        
        <span class="c1"># all reactions A+B=C or C=A+B or A+B=C+D</span>
        <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;reac&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">reac</span><span class="p">)</span>
        <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;left&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">es</span><span class="p">)</span>
        <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;right&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">ps</span><span class="p">)</span>
        <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;subs&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">es</span><span class="p">)</span>
        <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;prods&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">ps</span><span class="p">)</span>
        <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;metabs&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">ms</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">reac</span> <span class="ow">in</span> <span class="n">revreac</span><span class="p">:</span>
            <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;subs&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">ps</span><span class="p">)</span>
            <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;prods&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">es</span><span class="p">)</span>
        <span class="c1">#aff(&quot;ms for &quot;+reac, ms);##</span>

        <span class="c1"># create chemical formula</span>
        <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;formula&quot;</span><span class="p">][</span><span class="n">reac</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;left&quot;</span><span class="p">:</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;left&quot;</span><span class="p">],</span> <span class="s2">&quot;right&quot;</span><span class="p">:</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;right&quot;</span><span class="p">],</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span><span class="n">ms</span><span class="p">}</span>

        <span class="c1"># Carbon length and transitions</span>
        <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;carbotrans&quot;</span><span class="p">][</span><span class="n">reac</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;left&quot;</span><span class="p">:</span> <span class="p">[],</span> <span class="s2">&quot;right&quot;</span><span class="p">:</span> <span class="p">[]}</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">carb</span><span class="p">,</span> <span class="n">lr</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[(</span><span class="n">row</span><span class="p">[</span><span class="n">lr</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">crow</span><span class="p">[</span><span class="n">lr</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">lr</span><span class="p">)</span> <span class="k">for</span> <span class="n">lr</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="s2">&quot;right&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">lr</span><span class="p">]))]:</span>
                <span class="c1">#print &quot;m=&quot;+str(m), &quot;; carb=&quot;+str(carb);##</span>
            <span class="k">if</span> <span class="n">carb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;#&quot;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;In carbon string &#39;</span><span class="si">%s</span><span class="s2">&#39; for metabolite &#39;</span><span class="si">%s</span><span class="s2">&#39; a starting &#39;#&#39; is missing. (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">carb</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
            <span class="c1"># carbon transitions</span>
            <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;carbotrans&quot;</span><span class="p">][</span><span class="n">reac</span><span class="p">][</span><span class="n">lr</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">m</span><span class="p">,</span><span class="n">carb</span><span class="p">[</span><span class="mi">1</span><span class="p">:]));</span> <span class="c1"># strip &quot;#&quot; character</span>

            <span class="c1"># carbon length</span>
            <span class="k">if</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;Clen&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> \
                    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;Clen&quot;</span><span class="p">][</span><span class="n">m</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">carb</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;CarbonLength&quot;</span><span class="p">,</span> <span class="s2">&quot;Metabolite &quot;</span><span class="o">+</span><span class="n">m</span><span class="o">+</span><span class="s2">&quot; has length &quot;</span><span class="o">+</span>
                        <span class="nb">str</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;Clen&quot;</span><span class="p">][</span><span class="n">m</span><span class="p">])</span><span class="o">+</span><span class="s2">&quot; but in reaction &quot;</span><span class="o">+</span><span class="n">reac</span><span class="o">+</span>
                        <span class="s2">&quot; it has length &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">carb</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
            <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;Clen&quot;</span><span class="p">][</span><span class="n">m</span><span class="p">]</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">carb</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1"># don&#39;t count &#39;#&#39; character</span>
        <span class="c1"># check equal carbon length on left and right sides</span>
        <span class="n">lenl</span><span class="o">=</span><span class="nb">sum</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span><span class="p">,</span><span class="n">l</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;carbotrans&quot;</span><span class="p">][</span><span class="n">reac</span><span class="p">][</span><span class="s2">&quot;left&quot;</span><span class="p">])</span>
        <span class="n">lenr</span><span class="o">=</span><span class="nb">sum</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span><span class="p">,</span><span class="n">l</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;carbotrans&quot;</span><span class="p">][</span><span class="n">reac</span><span class="p">][</span><span class="s2">&quot;right&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">lenl</span><span class="o">!=</span><span class="n">lenr</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Carbon patterns have different lengths on both sides of reaction &#39;</span><span class="si">%s</span><span class="s2">&#39; (</span><span class="si">%d</span><span class="s2"> on left, </span><span class="si">%d</span><span class="s2"> on right, </span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">reac</span><span class="p">,</span> <span class="n">lenl</span><span class="p">,</span> <span class="n">lenr</span><span class="p">,</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
        <span class="c1"># check unique presence of each letter on each side</span>
        <span class="n">lets</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span>
        <span class="n">uni</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">lr</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="s2">&quot;right&quot;</span><span class="p">):</span>
            <span class="n">lets</span><span class="p">[</span><span class="n">lr</span><span class="p">]</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">l</span> <span class="k">for</span> <span class="n">m</span><span class="p">,</span><span class="n">l</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;carbotrans&quot;</span><span class="p">][</span><span class="n">reac</span><span class="p">][</span><span class="n">lr</span><span class="p">])</span>
            <span class="n">uni</span><span class="p">[</span><span class="n">lr</span><span class="p">]</span><span class="o">=</span><span class="n">oset</span><span class="p">(</span><span class="n">lets</span><span class="p">[</span><span class="n">lr</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">uni</span><span class="p">[</span><span class="n">lr</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lets</span><span class="p">[</span><span class="n">lr</span><span class="p">]):</span>
                <span class="c1"># find repeated letters</span>
                <span class="n">di</span><span class="o">=</span><span class="nb">dict</span><span class="p">((</span><span class="n">l</span><span class="p">,</span><span class="n">lets</span><span class="p">[</span><span class="n">lr</span><span class="p">]</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">l</span><span class="p">))</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">uni</span><span class="p">[</span><span class="n">lr</span><span class="p">])</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="n">di</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">c</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Character &#39;</span><span class="si">%s</span><span class="s2">&#39; is present </span><span class="si">%s</span><span class="s2"> on the </span><span class="si">%s</span><span class="s2"> side of carbon transition in reaction &#39;</span><span class="si">%s</span><span class="s2">&#39; (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">ntimes</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">lr</span><span class="p">,</span> <span class="n">reac</span><span class="p">,</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
        <span class="c1"># check for perfect mapping</span>
        <span class="n">lmr</span><span class="o">=</span><span class="n">uni</span><span class="p">[</span><span class="s2">&quot;left&quot;</span><span class="p">]</span><span class="o">-</span><span class="n">uni</span><span class="p">[</span><span class="s2">&quot;right&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">lmr</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Letter(s) &#39;</span><span class="si">%s</span><span class="s2">&#39; are present on the left but not on the right hand side in carbon transitions for reaction &#39;</span><span class="si">%s</span><span class="s2">&#39; (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">lmr</span><span class="p">)),</span> <span class="n">reac</span><span class="p">,</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
        <span class="n">rml</span><span class="o">=</span><span class="n">uni</span><span class="p">[</span><span class="s2">&quot;right&quot;</span><span class="p">]</span><span class="o">-</span><span class="n">uni</span><span class="p">[</span><span class="s2">&quot;left&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">rml</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Letter(s) &#39;</span><span class="si">%s</span><span class="s2">&#39; are present on the right but not on the left hand side in carbon transitions for reaction &#39;</span><span class="si">%s</span><span class="s2">&#39; (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">lmr</span><span class="p">)),</span> <span class="n">reac</span><span class="p">,</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>

        <span class="c1"># stocheometric matrix in dictionnary form</span>
        <span class="c1"># sto_r_m[reac][&#39;left&#39;|&#39;right&#39;]=[(metab, coef)] and</span>
        <span class="c1"># sto_m_r[metab][&#39;left&#39;|&#39;right&#39;]=list((reac, coef))</span>
        <span class="c1"># substrates are in &#39;left&#39; list</span>
        <span class="c1"># and products are in the &#39;right&#39; one.</span>

        <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;sto_r_m&quot;</span><span class="p">][</span><span class="n">reac</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;left&quot;</span><span class="p">:</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;left&quot;</span><span class="p">],</span> <span class="s2">&quot;right&quot;</span><span class="p">:</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;right&quot;</span><span class="p">]}</span>
        
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span><span class="n">c</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;sto_r_m&quot;</span><span class="p">][</span><span class="n">reac</span><span class="p">][</span><span class="s2">&quot;left&quot;</span><span class="p">]:</span>
            <span class="c1">#print &quot;sto_m_r s=&quot;+str(s);##</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;sto_m_r&quot;</span><span class="p">]:</span>
                <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;sto_m_r&quot;</span><span class="p">][</span><span class="n">s</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;left&quot;</span><span class="p">:[],</span> <span class="s2">&quot;right&quot;</span><span class="p">:[]}</span>
            <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;sto_m_r&quot;</span><span class="p">][</span><span class="n">s</span><span class="p">][</span><span class="s2">&quot;left&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">reac</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span><span class="n">c</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;sto_r_m&quot;</span><span class="p">][</span><span class="n">reac</span><span class="p">][</span><span class="s2">&quot;right&quot;</span><span class="p">]:</span>
            <span class="c1">#print &quot;sto_m_r s=&quot;+str(s)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;sto_m_r&quot;</span><span class="p">]:</span>
                <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;sto_m_r&quot;</span><span class="p">][</span><span class="n">s</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;left&quot;</span><span class="p">:[],</span> <span class="s2">&quot;right&quot;</span><span class="p">:[]}</span>
            <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;sto_m_r&quot;</span><span class="p">][</span><span class="n">s</span><span class="p">][</span><span class="s2">&quot;right&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">reac</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span>
        <span class="c1"># end netan[&quot;sto_m_r&quot;]</span>
        <span class="c1">#aff(&quot;sto_m_r&quot;+str(reac), netan[&quot;sto_m_r&quot;]);##</span>

    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">ftbl</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;NOTRACER_NETWORK&quot;</span><span class="p">,</span> <span class="p">[]):</span>
        <span class="n">reac</span><span class="o">=</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;FLUX_NAME&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">reac</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;sto_r_m&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Reaction &#39;</span><span class="si">%s</span><span class="s2">&#39; from NOTRACER_NETWORK section was already introduced in NETWORK section (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">).&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">reac</span><span class="p">,</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
        <span class="n">spl</span><span class="o">=</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;EQUATION&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;=&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spl</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Not found &#39;=&#39; sign in NOTRACER_NETWORK reaction: &#39;</span><span class="si">%s</span><span class="s2">&#39; (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">reac</span><span class="p">,</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">spl</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Too many &#39;=&#39; signs (</span><span class="si">%d</span><span class="s2">) in NOTRACER_NETWORK reaction: &#39;</span><span class="si">%s</span><span class="s2">&#39; (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">reac</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">spl</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
        <span class="n">lr</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="s2">&quot;right&quot;</span><span class="p">)</span>
        <span class="n">di</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">su</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">spl</span><span class="p">):</span>
            <span class="n">terms</span><span class="o">=</span><span class="n">su</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;+&quot;</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">di</span><span class="p">[</span><span class="n">lr</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">=</span><span class="n">mecoparse</span><span class="p">(</span><span class="n">terms</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="n">werr</span><span class="p">(</span><span class="s2">&quot;Error occured in &#39;</span><span class="si">%s</span><span class="s2">&#39;: </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
                <span class="k">raise</span>
        <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;sto_r_m&quot;</span><span class="p">][</span><span class="n">reac</span><span class="p">]</span><span class="o">=</span><span class="n">di</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span><span class="n">c</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;sto_r_m&quot;</span><span class="p">][</span><span class="n">reac</span><span class="p">][</span><span class="s2">&quot;left&quot;</span><span class="p">]:</span>
            <span class="c1">#print &quot;sto_m_r s=&quot;+str(s);##</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;sto_m_r&quot;</span><span class="p">]:</span>
                <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;sto_m_r&quot;</span><span class="p">][</span><span class="n">s</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;left&quot;</span><span class="p">:[],</span> <span class="s2">&quot;right&quot;</span><span class="p">:[]}</span>
            <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;sto_m_r&quot;</span><span class="p">][</span><span class="n">s</span><span class="p">][</span><span class="s2">&quot;left&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">reac</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span><span class="n">c</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;sto_r_m&quot;</span><span class="p">][</span><span class="n">reac</span><span class="p">][</span><span class="s2">&quot;right&quot;</span><span class="p">]:</span>
            <span class="c1">#print &quot;sto_m_r s=&quot;+str(s)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;sto_m_r&quot;</span><span class="p">]:</span>
                <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;sto_m_r&quot;</span><span class="p">][</span><span class="n">s</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;left&quot;</span><span class="p">:[],</span> <span class="s2">&quot;right&quot;</span><span class="p">:[]}</span>
            <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;sto_m_r&quot;</span><span class="p">][</span><span class="n">s</span><span class="p">][</span><span class="s2">&quot;right&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">reac</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span>
        <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;reac&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">reac</span><span class="p">)</span>
        <span class="n">es</span><span class="o">=</span><span class="n">oset</span><span class="p">(</span><span class="n">m</span> <span class="k">for</span> <span class="n">m</span><span class="p">,</span><span class="n">co</span> <span class="ow">in</span> <span class="n">di</span><span class="p">[</span><span class="s2">&quot;left&quot;</span><span class="p">])</span>
        <span class="n">ps</span><span class="o">=</span><span class="n">oset</span><span class="p">(</span><span class="n">m</span> <span class="k">for</span> <span class="n">m</span><span class="p">,</span><span class="n">co</span> <span class="ow">in</span> <span class="n">di</span><span class="p">[</span><span class="s2">&quot;right&quot;</span><span class="p">])</span>
        <span class="n">ms</span><span class="o">=</span><span class="n">es</span><span class="o">|</span><span class="n">ps</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">ms</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">m</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;Clen&quot;</span><span class="p">]:</span>
                <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;Clen&quot;</span><span class="p">][</span><span class="n">m</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
        <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;left&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">es</span><span class="p">)</span>
        <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;right&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">ps</span><span class="p">)</span>
        <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;subs&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">es</span><span class="p">)</span>
        <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;prods&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">ps</span><span class="p">)</span>
        <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;metabs&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">ms</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">reac</span> <span class="ow">in</span> <span class="n">revreac</span><span class="p">:</span>
            <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;subs&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">ps</span><span class="p">)</span>
            <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;prods&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">es</span><span class="p">)</span>
        <span class="c1">#aff(&quot;ms for &quot;+reac, ms);##</span>

        <span class="c1"># create chemical formula</span>
        <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;formula&quot;</span><span class="p">][</span><span class="n">reac</span><span class="p">]</span><span class="o">=</span><span class="n">di</span>
        <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;formula&quot;</span><span class="p">][</span><span class="n">reac</span><span class="p">][</span><span class="s2">&quot;all&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">ms</span>

    <span class="c1"># find input and output metabolites</span>
    <span class="c1">#pdb.set_trace()</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;subs&quot;</span><span class="p">]</span><span class="o">-</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;prods&quot;</span><span class="p">])</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;output&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;prods&quot;</span><span class="p">]</span><span class="o">-</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;subs&quot;</span><span class="p">])</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;deadend&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(((</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;left&quot;</span><span class="p">]</span><span class="o">-</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;right&quot;</span><span class="p">])</span> <span class="o">|</span> <span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;right&quot;</span><span class="p">]</span><span class="o">-</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;left&quot;</span><span class="p">]))</span> <span class="o">-</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">]</span><span class="o">-</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;output&quot;</span><span class="p">])</span>
    <span class="c1"># internal metabs</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;metabint&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;metabs&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;metabint&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">difference_update</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">]</span> <span class="o">|</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;output&quot;</span><span class="p">])</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;metab0len&quot;</span><span class="p">]</span><span class="o">=</span><span class="nb">set</span><span class="p">(</span><span class="n">m</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;metabs&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;Clen&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c1"># all met_pools must be in internal metabolites</span>
    <span class="n">mdif</span><span class="o">=</span><span class="n">oset</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;met_pools&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;metabint&quot;</span><span class="p">])</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mdif</span><span class="p">)</span> <span class="p">:</span>
        <span class="c1"># unknown metabolite</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Unknown metabolite(s). Metabolite(s) &#39;&quot;</span><span class="o">+</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">mdif</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;&#39; defined in section METABOLITE_POOLS are not internal metabolites in NETWORK section.&quot;</span><span class="p">)</span>
    <span class="c1"># all met_pools must carry labeling</span>
    <span class="n">mcom</span><span class="o">=</span><span class="n">oset</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;met_pools&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;metab0len&quot;</span><span class="p">])</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mcom</span><span class="p">)</span> <span class="p">:</span>
        <span class="c1"># unknown metabolite</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Non labeled specie in METABOLITE_POOLS. Metabolite(s) &#39;&quot;</span><span class="o">+</span><span class="s2">&quot;&#39;, &#39;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">mcom</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;&#39; defined in section METABOLITE_POOLS are not carrying labeled atoms&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">case_i</span><span class="p">:</span>
        <span class="c1">#pdb.set_trace()</span>
        <span class="c1"># check it other way: all metabint must be in metpools</span>
        <span class="n">mdif</span><span class="o">=</span><span class="n">oset</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;metabint&quot;</span><span class="p">]</span><span class="o">-</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;metab0len&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;met_pools&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mdif</span><span class="p">)</span> <span class="p">:</span>
            <span class="c1"># unknown metabolite</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Unknown metabolite concentration. Metabolite(s) carrying labeling &#39;&quot;</span><span class="o">+</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">mdif</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;&#39; defined in section NETWORK are not defined in METABOLITE_POOLS section.&quot;</span><span class="p">)</span>

    <span class="c1"># add growth fluxes if requested</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_growth&quot;</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;net&quot;</span><span class="p">:</span><span class="nb">dict</span><span class="p">()}</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_vgrowth&quot;</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;net&quot;</span><span class="p">:</span><span class="nb">dict</span><span class="p">(),</span> <span class="s2">&quot;xch&quot;</span><span class="p">:</span><span class="nb">dict</span><span class="p">()};</span> <span class="c1"># fluxes depending on variable pools</span>
    <span class="k">if</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;opt&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;include_growth_flux&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;opt&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;mu&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Parameter include_growth_flux is set to True but the growth parameter mu is absent or zero in OPTIONS section&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">si</span><span class="p">)</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;met_pools&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">mgr</span><span class="o">=</span><span class="n">m</span><span class="o">+</span><span class="s2">&quot;_gr&quot;</span>
            <span class="n">reac</span><span class="o">=</span><span class="n">mgr</span>
            <span class="k">if</span> <span class="n">reac</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;reac&quot;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Cannot add growth reaction &quot;</span><span class="o">+</span><span class="n">reac</span><span class="o">+</span><span class="s2">&quot;. It is already in the network&quot;</span><span class="p">)</span>
            <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;reac&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">reac</span><span class="p">)</span>
            <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;subs&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
            <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;prods&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">mgr</span><span class="p">)</span>
            <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;metabs&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
            <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;output&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">mgr</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">si</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">:</span>
               <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_growth&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">][</span><span class="n">reac</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
               <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_vgrowth&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">][</span><span class="n">reac</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span>
               <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_vgrowth&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">][</span><span class="n">reac</span><span class="p">]</span><span class="o">=</span><span class="mf">0.</span>
            <span class="c1">#aff(&quot;ms for &quot;+reac, ms);##</span>

            <span class="c1"># create chemical formula</span>
            <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;formula&quot;</span><span class="p">][</span><span class="n">reac</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;left&quot;</span><span class="p">:[(</span><span class="n">m</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)],</span> <span class="s2">&quot;right&quot;</span><span class="p">:[(</span><span class="n">mgr</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span> <span class="s2">&quot;all&quot;</span><span class="p">:[</span><span class="n">m</span><span class="p">,</span><span class="n">mgr</span><span class="p">]}</span>
            <span class="c1"># stoicheometry</span>
            <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;sto_m_r&quot;</span><span class="p">][</span><span class="n">m</span><span class="p">][</span><span class="s2">&quot;left&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">reac</span><span class="p">,</span> <span class="mf">1.</span><span class="p">))</span>
            <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;sto_m_r&quot;</span><span class="p">][</span><span class="n">mgr</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;left&quot;</span><span class="p">:</span> <span class="p">[],</span> <span class="s2">&quot;right&quot;</span><span class="p">:</span> <span class="p">[(</span><span class="n">reac</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)]}</span>
            <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;sto_r_m&quot;</span><span class="p">][</span><span class="n">reac</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;left&quot;</span><span class="p">:[(</span><span class="n">m</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)],</span> <span class="s2">&quot;right&quot;</span><span class="p">:[(</span><span class="n">mgr</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)]}</span>

    <span class="c1"># check metab names in pools and network</span>
    <span class="c1"># all met_pools must be in internal metabolites</span>
    <span class="n">mdif</span><span class="o">=</span><span class="n">oset</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;met_pools&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;metabint&quot;</span><span class="p">])</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mdif</span><span class="p">)</span> <span class="p">:</span>
        <span class="c1"># unknown metabolite</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Unknown metabolite(s). Metabolite(s) &#39;&quot;</span><span class="o">+</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">mdif</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;&#39; defined in the section METABOLITE_POOLS are not internal metabolites in the NETWORK section.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;met_pools&quot;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">me</span><span class="o">==</span><span class="s2">&quot;ftbl2labprop.py3&quot;</span><span class="p">:</span>
        <span class="c1"># all internal metabs must be also in met_pools section</span>
        <span class="n">mdif</span><span class="o">=</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;metabint&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;met_pools&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mdif</span><span class="p">)</span> <span class="p">:</span>
            <span class="c1"># unknown metabolite(s)</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Unknown metabolite(s). Metabolite(s) &#39;&quot;</span><span class="o">+</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">mdif</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;&#39; defined as internal in the section NETWORK, are not defined in the METABOLITE_POOLS section.&quot;</span><span class="p">)</span>
    
    <span class="c1"># input and output flux names</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_in&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">oset</span><span class="p">(</span><span class="n">f</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">f</span><span class="p">,</span><span class="n">_</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;sto_m_r&quot;</span><span class="p">][</span><span class="n">m</span><span class="p">][</span><span class="s2">&quot;left&quot;</span><span class="p">])</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_out&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">oset</span><span class="p">(</span><span class="n">f</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;output&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">f</span><span class="p">,</span><span class="n">_</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;sto_m_r&quot;</span><span class="p">][</span><span class="n">m</span><span class="p">][</span><span class="s2">&quot;right&quot;</span><span class="p">])</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_inout&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_in&quot;</span><span class="p">]</span> <span class="o">|</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_out&quot;</span><span class="p">]</span>
    <span class="c1">#print &quot;fl in + out=&quot;+str(netan[&quot;flux_in&quot;])+&quot;+&quot;+str( netan[&quot;flux_out&quot;]);##</span>
    
    <span class="c1"># get possible additional fluxes (i.e. from cofactors) from EQAULITY section (eqflux)</span>
    <span class="c1"># flux equalities</span>
    <span class="c1"># list of tuples (value,dict) where dict is flux:coef</span>
    <span class="c1"># net fluxes</span>
    
    <span class="c1"># temporary list of constrained net fluxes</span>
    <span class="n">fcnstr</span><span class="o">=</span><span class="n">oset</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;NAME&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">ftbl</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;FLUXES&quot;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">())</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;NET&quot;</span><span class="p">,</span> <span class="p">[])</span> <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;FCD&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;C&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">ftbl</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;EQUALITIES&quot;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">())</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;NET&quot;</span><span class="p">,[]):</span>
        <span class="n">dicf</span><span class="o">=</span><span class="n">formula2dict</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;FORMULA&quot;</span><span class="p">])</span>
        <span class="c1"># number of non constrained fluxes in a formula</span>
        <span class="n">nb_nonc</span><span class="o">=</span><span class="nb">sum</span><span class="p">(</span><span class="n">fl</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fcnstr</span> <span class="k">for</span> <span class="n">fl</span> <span class="ow">in</span> <span class="n">dicf</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nb_nonc</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">wout</span><span class="p">(</span><span class="s2">&quot;***Warning: in EQUALITIES/NET section, the formula &#39;&quot;</span><span class="o">+</span>
                <span class="n">row</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span><span class="o">+</span><span class="s2">&quot;=&quot;</span><span class="o">+</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;FORMULA&quot;</span><span class="p">]</span><span class="o">+</span><span class="s2">&quot;&#39; involves only constrained flux(es).</span><span class="se">\n</span><span class="s2">The equality is ignored as meaningless (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">).</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
            <span class="k">continue</span>
        <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_equal&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span>
                <span class="n">eval_expr</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]),</span>
                <span class="n">dicf</span><span class="p">,</span>
                <span class="n">row</span><span class="p">[</span><span class="s2">&quot;FORMULA&quot;</span><span class="p">]</span><span class="o">+</span><span class="s2">&quot;=&quot;</span><span class="o">+</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span><span class="o">+</span><span class="s2">&quot;: &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">])))</span>
    <span class="c1"># xch fluxes</span>
    <span class="c1"># temporary list of constrained xch fluxes</span>
    <span class="n">fcnstr</span><span class="o">=</span><span class="n">oset</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;NAME&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">ftbl</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;FLUXES&quot;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">())</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;XCH&quot;</span><span class="p">,</span> <span class="p">[])</span> <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;FCD&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;C&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">ftbl</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;EQUALITIES&quot;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">())</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;XCH&quot;</span><span class="p">,[]):</span>
        <span class="n">dicf</span><span class="o">=</span><span class="n">formula2dict</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;FORMULA&quot;</span><span class="p">])</span>
        <span class="c1"># number of non constrained fluxes in a formula</span>
        <span class="n">nb_nonc</span><span class="o">=</span><span class="nb">sum</span><span class="p">(</span><span class="n">fl</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fcnstr</span> <span class="k">for</span> <span class="n">fl</span> <span class="ow">in</span> <span class="n">dicf</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nb_nonc</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">wout</span><span class="p">(</span><span class="s2">&quot;***Warning: in EQUALITIES/XCH section, the formula &#39;&quot;</span><span class="o">+</span>
                <span class="n">row</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span><span class="o">+</span><span class="s2">&quot;=&quot;</span><span class="o">+</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;FORMULA&quot;</span><span class="p">]</span><span class="o">+</span><span class="s2">&quot;&#39; involves only constrained flux(es).</span><span class="se">\n</span><span class="s2">The equality is ignored as meaningless (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">).</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
            <span class="k">continue</span>
        <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_equal&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span>
                <span class="n">eval_expr</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]),</span>
                <span class="n">dicf</span><span class="p">,</span>
                <span class="n">row</span><span class="p">[</span><span class="s2">&quot;FORMULA&quot;</span><span class="p">]</span><span class="o">+</span><span class="s2">&quot;=&quot;</span><span class="o">+</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span><span class="o">+</span><span class="s2">&quot;: &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">])))</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;eqflux&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">oset</span><span class="p">(</span><span class="n">f</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_equal&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="p">[</span><span class="o">*</span><span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()])</span> <span class="o">|</span> <span class="n">oset</span><span class="p">(</span><span class="n">f</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_equal&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="p">[</span><span class="o">*</span><span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()])</span>
    <span class="n">eqflux</span><span class="o">=</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;eqflux&quot;</span><span class="p">]</span>
    <span class="c1"># metab EQAULITIES</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;metab_equal&quot;</span><span class="p">]</span><span class="o">=</span><span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">ftbl</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;EQUALITIES&quot;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">())</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;METAB&quot;</span><span class="p">,[]):</span>
        <span class="c1">#print row;##</span>
        <span class="n">dicf</span><span class="o">=</span><span class="n">formula2dict</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;FORMULA&quot;</span><span class="p">])</span>
        <span class="n">nb_neg</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">dicf</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">m</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;metabint&quot;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Metabolite `</span><span class="si">%s</span><span class="s2">` is not internal metabolite (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">).&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
            <span class="k">if</span> <span class="n">m</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;met_pools&quot;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Metabolite `</span><span class="si">%s</span><span class="s2">` is not declared in METABOLITE_POOLS section (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">).&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
            <span class="n">nb_neg</span><span class="o">+=</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;met_pools&quot;</span><span class="p">][</span><span class="n">m</span><span class="p">]</span><span class="o">&lt;</span><span class="mi">0</span>
        <span class="k">if</span> <span class="n">nb_neg</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;At least one of metabolites &#39;</span><span class="si">%s</span><span class="s2">&#39; must be declared as variable (i.e. having negative value) in the section METABOLITE_POOLS (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">).&quot;</span><span class="o">%</span><span class="p">(</span><span class="s2">&quot;&#39;, &#39;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">dicf</span><span class="o">.</span><span class="n">keys</span><span class="p">())),</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
        <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;metab_equal&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span>
                <span class="n">eval_expr</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]),</span>
                <span class="n">dicf</span><span class="p">,</span>
                <span class="n">row</span><span class="p">[</span><span class="s2">&quot;FORMULA&quot;</span><span class="p">]</span><span class="o">+</span><span class="s2">&quot;=&quot;</span><span class="o">+</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span><span class="o">+</span><span class="s2">&quot;: &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">])))</span>

    <span class="c1"># analyse reaction reversibility</span>
    <span class="c1"># free fluxes(dictionary flux-&gt;init value for simulation or minimization)</span>
    <span class="c1"># constrained fluxes (dictionary flux-&gt;value)</span>
    <span class="c1"># variable growth fluxes (dictionary flux-&gt;value)</span>
    <span class="c1"># The rest are dependent fluxes</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_dep&quot;</span><span class="p">]</span><span class="o">=</span><span class="nb">dict</span><span class="p">({</span><span class="s2">&quot;net&quot;</span><span class="p">:</span><span class="nb">dict</span><span class="p">(),</span> <span class="s2">&quot;xch&quot;</span><span class="p">:</span><span class="nb">dict</span><span class="p">()})</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_free&quot;</span><span class="p">]</span><span class="o">=</span><span class="nb">dict</span><span class="p">({</span><span class="s2">&quot;net&quot;</span><span class="p">:</span><span class="nb">dict</span><span class="p">(),</span> <span class="s2">&quot;xch&quot;</span><span class="p">:</span><span class="nb">dict</span><span class="p">()})</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_constr&quot;</span><span class="p">]</span><span class="o">=</span><span class="nb">dict</span><span class="p">({</span><span class="s2">&quot;net&quot;</span><span class="p">:</span><span class="nb">dict</span><span class="p">(),</span> <span class="s2">&quot;xch&quot;</span><span class="p">:</span><span class="nb">dict</span><span class="p">()})</span>
    <span class="n">flx</span><span class="o">=</span><span class="n">ftbl</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;FLUXES&quot;</span><span class="p">)</span>
    <span class="n">fcd</span><span class="o">=</span><span class="n">oset</span><span class="p">((</span><span class="s2">&quot;F&quot;</span><span class="p">,</span> <span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="s2">&quot;D&quot;</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">flx</span><span class="p">:</span>
        <span class="n">xch</span><span class="o">=</span><span class="n">flx</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;XCH&quot;</span><span class="p">)</span>
        <span class="n">net</span><span class="o">=</span><span class="n">flx</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;NET&quot;</span><span class="p">)</span>
<span class="c1">##        aff(&quot;net&quot;, net)</span>
        <span class="c1"># check that all fluxes are defined in network section</span>
        <span class="n">allreac</span><span class="o">=</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;reac&quot;</span><span class="p">]</span> <span class="o">|</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_inout&quot;</span><span class="p">]</span>
        <span class="n">unk</span><span class="o">=</span><span class="p">[</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;NAME&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">net</span> <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;FCD&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">fcd</span> <span class="ow">and</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;NAME&quot;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">allreac</span><span class="o">|</span><span class="n">eqflux</span> <span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unk</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The flux name(s) &#39;</span><span class="si">%s</span><span class="s2">&#39; from the FLUX/NET section is (are) not defined in the NETWORK neither EQUALITY section.&quot;</span><span class="o">%</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">unk</span><span class="p">)))</span>
        <span class="n">unk</span><span class="o">=</span><span class="p">[</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;NAME&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">xch</span> <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;FCD&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">fcd</span> <span class="ow">and</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;NAME&quot;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">allreac</span><span class="o">|</span><span class="n">eqflux</span> <span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unk</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The flux name(s) &#39;</span><span class="si">%s</span><span class="s2">&#39; from the FLUX/XCH section is (are) not defined in the NETWORK neither EQUALITY section.&quot;</span><span class="o">%</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">unk</span><span class="p">)))</span>

        <span class="c1"># check that all reactions from NETWORK are at least in FLUX/NET section</span>
        <span class="n">fnet</span><span class="o">=</span><span class="n">oset</span><span class="p">(</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;NAME&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">net</span> <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;NAME&quot;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;FCD&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">fcd</span> <span class="p">)</span>
        <span class="c1">#print(&quot;fnet=&quot;, fnet)</span>
        <span class="c1">#print(&quot;allreac=&quot;, allreac)</span>
        <span class="n">unk</span><span class="o">=</span><span class="n">allreac</span><span class="o">-</span><span class="n">fnet</span><span class="o">-</span><span class="n">oset</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_growth&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">])</span><span class="o">-</span><span class="n">oset</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_vgrowth&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unk</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The flux name(s) &#39;</span><span class="si">%s</span><span class="s2">&#39; from the NETWORK section is (are) not defined in the FLUX/NET section.&quot;</span><span class="o">%</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">unk</span><span class="p">)))</span>

        <span class="c1"># check that all reactions from EQUALITY are at least in FLUX/NET/XCH section</span>
        <span class="n">fnetxch</span><span class="o">=</span><span class="n">oset</span><span class="p">(</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;NAME&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">net</span><span class="o">+</span><span class="n">xch</span> <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;NAME&quot;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;FCD&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">fcd</span> <span class="p">)</span>
        <span class="n">unk</span> <span class="o">=</span> <span class="n">eqflux</span> <span class="o">-</span> <span class="n">fnet</span> <span class="o">-</span> <span class="n">oset</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_growth&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">])</span> <span class="o">-</span> <span class="n">oset</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_vgrowth&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unk</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The flux name(s) &#39;</span><span class="si">%s</span><span class="s2">&#39; from the NETWORK section is (are) not defined in the FLUX/NET section.&quot;</span><span class="o">%</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">unk</span><span class="p">)))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">werr</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">me</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;: netan[FLUXES] is not defined</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1">#return None</span>
    <span class="c1">#print &quot;list reac=&quot;, netan[&quot;reac&quot;];##</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1">#print( netan[&quot;reac&quot;] | netan[&quot;flux_inout&quot;])</span>
        <span class="k">for</span> <span class="n">reac</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;reac&quot;</span><span class="p">]</span> <span class="o">|</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_inout&quot;</span><span class="p">]</span> <span class="o">|</span> <span class="n">eqflux</span><span class="p">:</span>
            <span class="c1">#print(&quot;reac=&quot;, reac)</span>
            <span class="c1"># get xch condition for this reac</span>
            <span class="n">cond</span><span class="o">=</span><span class="p">[</span><span class="n">row</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">xch</span> <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;NAME&quot;</span><span class="p">]</span><span class="o">==</span><span class="n">reac</span><span class="p">]</span>
            <span class="c1"># get net condition for this reac</span>
            <span class="n">ncond</span><span class="o">=</span><span class="p">([</span><span class="n">row</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">net</span> <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;NAME&quot;</span><span class="p">]</span><span class="o">==</span><span class="n">reac</span><span class="p">])</span> <span class="k">if</span> <span class="n">net</span> <span class="k">else</span> <span class="p">[]</span>
            <span class="c1"># no xch dispatch check for input/output fluxes as they are</span>
            <span class="c1"># constrained by definition</span>
            <span class="c1">#print &quot;r,c,n=&quot;, reac, len(cond), len(ncond);##</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cond</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;FluxDef&quot;</span><span class="p">,</span> <span class="s2">&quot;Reaction `</span><span class="si">%s</span><span class="s2">` is over defined in exchange fluxes.&quot;</span><span class="o">%</span><span class="n">reac</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cond</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">reac</span> <span class="ow">in</span> <span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_in&quot;</span><span class="p">]</span> <span class="o">|</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_out&quot;</span><span class="p">])):</span>
                <span class="n">werr</span><span class="p">(</span><span class="s2">&quot;in+out fluxes=&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_inout&quot;</span><span class="p">])</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span><span class="c1">##</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;FluxDef&quot;</span><span class="p">,</span> <span class="s2">&quot;Reaction `</span><span class="si">%s</span><span class="s2">` is not defined D/F/C in exchange fluxes.&quot;</span><span class="o">%</span><span class="n">reac</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cond</span><span class="p">:</span>
                <span class="n">cond</span><span class="o">=</span><span class="n">cond</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ncond</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;FluxDef&quot;</span><span class="p">,</span> <span class="s2">&quot;Reaction `</span><span class="si">%s</span><span class="s2">` is over defined in net fluxes.&quot;</span><span class="o">%</span><span class="n">reac</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ncond</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">reac</span> <span class="ow">in</span> <span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_inout&quot;</span><span class="p">])):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;FluxDef&quot;</span><span class="p">,</span> <span class="s2">&quot;Reaction `</span><span class="si">%s</span><span class="s2">` is not defined D/F/C in net fluxes.&quot;</span><span class="o">%</span><span class="n">reac</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ncond</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span>
                <span class="p">(</span><span class="n">reac</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_inout&quot;</span><span class="p">]</span> <span class="ow">and</span>
                <span class="ow">not</span> <span class="n">reac</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_growth&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">]</span> <span class="ow">and</span>
                <span class="ow">not</span> <span class="n">reac</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_vgrowth&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">])):</span>
                <span class="c1"># input-output fluxes are by definition not reversible</span>
                <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;notrev&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">reac</span><span class="p">)</span>
                <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_constr&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">][</span><span class="n">reac</span><span class="p">]</span><span class="o">=</span><span class="mf">0.</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;opt&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;include_growth_flux&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">reac</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_growth&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">]:</span>
                <span class="n">m</span><span class="o">=</span><span class="n">reac</span><span class="p">[:</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span>
                <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;notrev&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">reac</span><span class="p">)</span>
                <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_constr&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">][</span><span class="n">reac</span><span class="p">]</span><span class="o">=</span><span class="mf">0.</span>
                <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_constr&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">][</span><span class="n">reac</span><span class="p">]</span><span class="o">=</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;opt&quot;</span><span class="p">][</span><span class="s2">&quot;mu&quot;</span><span class="p">]</span><span class="o">*</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;met_pools&quot;</span><span class="p">][</span><span class="n">m</span><span class="p">]</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;opt&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;include_growth_flux&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">reac</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_vgrowth&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">]:</span>
                <span class="n">m</span><span class="o">=</span><span class="n">reac</span><span class="p">[:</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span>
                <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;notrev&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">reac</span><span class="p">)</span>
                <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_vgrowth&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">][</span><span class="n">reac</span><span class="p">]</span><span class="o">=</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;opt&quot;</span><span class="p">][</span><span class="s2">&quot;mu&quot;</span><span class="p">]</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;met_pools&quot;</span><span class="p">][</span><span class="n">m</span><span class="p">])</span>
                <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_vgrowth&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">][</span><span class="n">reac</span><span class="p">]</span><span class="o">=</span><span class="mf">0.</span>
                <span class="k">continue</span>
            <span class="n">ncond</span><span class="o">=</span><span class="n">ncond</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1">#aff(&quot;cond&quot;, cond);##</span>
            <span class="c1">#aff(&quot;ncond&quot;, ncond);##</span>
            <span class="c1"># not reversibles are those reaction having xch flux=0 or</span>
            <span class="c1"># input/output fluxes</span>
            <span class="n">val</span><span class="o">=</span><span class="n">eval_expr</span><span class="p">(</span><span class="n">cond</span><span class="p">[</span><span class="s2">&quot;VALUE(F/C)&quot;</span><span class="p">])</span>
            <span class="n">xval</span><span class="o">=</span><span class="mf">0.</span> <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">float</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="n">val</span><span class="o">=</span><span class="n">eval_expr</span><span class="p">(</span><span class="n">ncond</span><span class="p">[</span><span class="s2">&quot;VALUE(F/C)&quot;</span><span class="p">])</span>
            <span class="n">nval</span><span class="o">=</span><span class="mf">0.</span> <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">float</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">cond</span> <span class="ow">and</span> <span class="n">cond</span><span class="p">[</span><span class="s2">&quot;FCD&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;C&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">reac</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_inout&quot;</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">reac</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_inout&quot;</span><span class="p">])</span> <span class="ow">or</span> \
                        <span class="p">(</span><span class="n">xval</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">):</span>
                        <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;notrev&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">reac</span><span class="p">)</span>
                        <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_constr&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">][</span><span class="n">reac</span><span class="p">]</span><span class="o">=</span><span class="mf">0.</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># not null constrained xch</span>
                        <span class="k">if</span> <span class="n">xval</span> <span class="o">&lt;</span> <span class="mf">0.</span> <span class="ow">or</span> <span class="n">xval</span> <span class="o">&gt;</span> <span class="mf">1.</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;FluxVal&quot;</span><span class="p">,</span> <span class="s2">&quot;Constrained exchange flux`</span><span class="si">%s</span><span class="s2">` must have value in [0; 1] interval.</span><span class="se">\n</span><span class="s2">Instead, a value </span><span class="si">%f</span><span class="s2"> is given&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">reac</span><span class="p">,</span> <span class="n">xval</span><span class="p">))</span>
                        <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_constr&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">][</span><span class="n">reac</span><span class="p">]</span><span class="o">=</span><span class="n">xval</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">cond</span> <span class="ow">and</span> <span class="n">cond</span><span class="p">[</span><span class="s2">&quot;FCD&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;F&quot;</span><span class="p">):</span>
                    <span class="c1"># free xch</span>
                    <span class="k">if</span> <span class="n">xval</span> <span class="o">&lt;</span> <span class="mf">0.</span> <span class="ow">or</span> <span class="n">xval</span> <span class="o">&gt;</span> <span class="mf">1.</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;FluxVal&quot;</span><span class="p">,</span> <span class="s2">&quot;Free exchange flux &#39;</span><span class="si">%s</span><span class="s2">&#39; must have starting value in [0; 1] interval.</span><span class="se">\n</span><span class="s2">Instead, a value </span><span class="si">%f</span><span class="s2"> is given&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">reac</span><span class="p">,</span> <span class="n">xval</span><span class="p">))</span>
                    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_free&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">][</span><span class="n">reac</span><span class="p">]</span><span class="o">=</span><span class="n">xval</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">cond</span> <span class="ow">and</span> <span class="n">cond</span><span class="p">[</span><span class="s2">&quot;FCD&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;D&quot;</span><span class="p">):</span>
                    <span class="c1"># dependent xch</span>
                    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_dep&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">][</span><span class="n">reac</span><span class="p">]</span><span class="o">=</span><span class="n">xval</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">ncond</span> <span class="ow">and</span> <span class="n">ncond</span><span class="p">[</span><span class="s2">&quot;FCD&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;F&quot;</span><span class="p">):</span>
                    <span class="c1"># free net</span>
                    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_free&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">][</span><span class="n">reac</span><span class="p">]</span><span class="o">=</span><span class="n">nval</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">ncond</span> <span class="ow">and</span> <span class="n">ncond</span><span class="p">[</span><span class="s2">&quot;FCD&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;C&quot;</span><span class="p">):</span>
                    <span class="c1"># constr net</span>
                    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_constr&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">][</span><span class="n">reac</span><span class="p">]</span><span class="o">=</span><span class="n">nval</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">ncond</span> <span class="ow">and</span> <span class="n">ncond</span><span class="p">[</span><span class="s2">&quot;FCD&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;D&quot;</span><span class="p">):</span>
                    <span class="c1"># dependent net</span>
                    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_dep&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">][</span><span class="n">reac</span><span class="p">]</span><span class="o">=</span><span class="n">nval</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="n">werr</span><span class="p">(</span><span class="s2">&quot;Error occured on the row </span><span class="si">%s</span><span class="s2"> or </span><span class="si">%s</span><span class="s2"> of ftbl file </span><span class="si">%s</span><span class="s2">:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">ncond</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">],</span> <span class="n">cond</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">],</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]))</span>
                <span class="k">raise</span>
    <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">inst</span><span class="p">:</span>
        <span class="c1">#werr(join(&quot; &quot;, sys.exc_info())+&quot;\n&quot;)</span>
        <span class="c1">#werr(&quot;: &quot;.join(inst)+&quot;\n&quot;)</span>
        <span class="n">werr</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">+</span><span class="nb">format</span><span class="p">(</span><span class="n">inst</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="c1"># complete variable growth exchange fluxes</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_vgrowth&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">]</span><span class="o">=</span><span class="nb">dict</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_vgrowth&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">])</span>
    
    <span class="c1"># measured fluxes</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">ftbl</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;FLUX_MEASUREMENTS&quot;</span><span class="p">,[]):</span>
        <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;FLUX_NAME&quot;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;reac&quot;</span><span class="p">]</span><span class="o">|</span><span class="n">eqflux</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Mesured flux `</span><span class="si">%s</span><span class="s2">` is not defined in NETWORK section neither in EQUALITIES (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">).&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;FLUX_NAME&quot;</span><span class="p">],</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;FLUX_NAME&quot;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_free&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">]</span> <span class="ow">and</span> \
            <span class="n">row</span><span class="p">[</span><span class="s2">&quot;FLUX_NAME&quot;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_dep&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Mesured flux `</span><span class="si">%s</span><span class="s2">` must be defined as either free or dependent (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">).&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;FLUX_NAME&quot;</span><span class="p">],</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
        <span class="n">val</span><span class="o">=</span><span class="n">eval_expr</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">])</span>
        <span class="n">fval</span><span class="o">=</span><span class="n">NaN</span> <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">float</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="n">val</span><span class="o">=</span><span class="n">eval_expr</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;DEVIATION&quot;</span><span class="p">])</span>
        <span class="n">sdev</span><span class="o">=</span><span class="kc">None</span> <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">float</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sdev</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;DEVIATION (</span><span class="si">%s</span><span class="s2">) must evaluate to a real number (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">).&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;DEVIATION&quot;</span><span class="p">],</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">sdev</span> <span class="o">&lt;=</span> <span class="mf">0.</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;DEVIATION (</span><span class="si">%s</span><span class="s2">) must be positive (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">).&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;DEVIATION&quot;</span><span class="p">],</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
        
        <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_measured&quot;</span><span class="p">][</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;FLUX_NAME&quot;</span><span class="p">]]</span><span class="o">=</span><span class="p">{</span>\
                <span class="s2">&quot;val&quot;</span><span class="p">:</span> <span class="n">fval</span><span class="p">,</span> \
                <span class="s2">&quot;dev&quot;</span><span class="p">:</span> <span class="n">sdev</span><span class="p">}</span>
    <span class="c1"># measured concentartions</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">ftbl</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;METAB_MEASUREMENTS&quot;</span><span class="p">,[]):</span>
        <span class="n">metabl</span><span class="o">=</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;META_NAME&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;+&quot;</span><span class="p">)</span>
        <span class="n">found_neg</span><span class="o">=</span><span class="kc">False</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">metabl</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">m</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;metabint&quot;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Mesured metabolite `</span><span class="si">%s</span><span class="s2">` is not internal metabolite (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">).&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
            <span class="k">if</span> <span class="n">m</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;met_pools&quot;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Mesured metabolite `</span><span class="si">%s</span><span class="s2">` is not declared in METABOLITE_POOLS section (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">).&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
            <span class="n">found_neg</span><span class="o">=</span><span class="n">found_neg</span> <span class="ow">or</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;met_pools&quot;</span><span class="p">][</span><span class="n">m</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">found_neg</span><span class="p">:</span>
            <span class="n">werr</span><span class="p">(</span><span class="s2">&quot;Warning: metabolite measurements on `</span><span class="si">%s</span><span class="s2">` does not have a free metabolite (i.e. being negative in the METABOLITE_POOLS ((</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">)).</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;META_NAME&quot;</span><span class="p">],</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
            <span class="n">werr</span><span class="p">(</span><span class="s2">&quot;This measurement is ignored</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">val</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">eval_expr</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]))</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">val</span><span class="o">=</span><span class="n">NaN</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">sdev</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">eval_expr</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;DEVIATION&quot;</span><span class="p">]))</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;DEVIATION must evaluate to a real positive number (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">).&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">sdev</span> <span class="o">&lt;=</span> <span class="mf">0.</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;DEVIATION must be positive (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">).&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
        <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;metab_measured&quot;</span><span class="p">][</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;META_NAME&quot;</span><span class="p">]]</span><span class="o">=</span><span class="p">{</span>\
                <span class="s2">&quot;val&quot;</span><span class="p">:</span> <span class="n">val</span><span class="p">,</span> \
                <span class="s2">&quot;dev&quot;</span><span class="p">:</span> <span class="n">sdev</span><span class="p">}</span>
    
    <span class="c1"># proceed LABEL_INPUT</span>
    <span class="n">proc_label_input</span><span class="p">(</span><span class="n">ftbl</span><span class="p">,</span> <span class="n">netan</span><span class="p">,</span> <span class="n">case_i</span><span class="p">)</span>
    <span class="c1"># flux inequalities</span>
    <span class="c1"># list of tuples (value,comp,dict) where dict is flux:coef</span>
    <span class="c1"># and comp is of &quot;&lt;&quot;, &quot;&lt;=&quot;, ...</span>
    <span class="c1"># net fluxes</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">ftbl</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;INEQUALITIES&quot;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">())</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;NET&quot;</span><span class="p">,[]):</span>
        <span class="c1">#print row;##</span>
        <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;COMP&quot;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;&gt;=&quot;</span><span class="p">,</span> <span class="s2">&quot;=&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;=&quot;</span><span class="p">,</span> <span class="s2">&quot;=&lt;&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;COMP field in INEQUALITIES section must be one of &#39;&gt;=&#39;, &#39;=&gt;&#39;, &#39;&lt;=&#39;, &#39;=&lt;&#39; and not &#39;</span><span class="si">%s</span><span class="s2">&#39; (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">).&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;COMP&quot;</span><span class="p">],</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
        <span class="n">dicf</span><span class="o">=</span><span class="n">formula2dict</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;FORMULA&quot;</span><span class="p">])</span>
        <span class="n">fl</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">dicf</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dicf</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">fl</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_constr&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">]:</span>
            <span class="n">wout</span><span class="p">(</span><span class="s2">&quot;***Warning: Inequalities: in NET section, the formula &#39;&quot;</span><span class="o">+</span>
                <span class="n">row</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span><span class="o">+</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;COMP&quot;</span><span class="p">]</span><span class="o">+</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;FORMULA&quot;</span><span class="p">]</span><span class="o">+</span><span class="s2">&quot;&#39; involves a constrained flux</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">+</span>
                <span class="s2">&quot; having a value &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_constr&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">][</span><span class="n">fl</span><span class="p">])</span><span class="o">+</span><span class="s2">&quot;. The inequality is ignored as meaningless ((</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">)).</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
            <span class="k">continue</span>
        <span class="n">val</span><span class="o">=</span><span class="n">eval_expr</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;VALUE field in INEQUALITIES section must evaluate to a float number &#39;</span><span class="si">%s</span><span class="s2">&#39; (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">).&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">],</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
        <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_inequal&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span>
                <span class="nb">float</span><span class="p">(</span><span class="n">val</span><span class="p">),</span>
                <span class="n">row</span><span class="p">[</span><span class="s2">&quot;COMP&quot;</span><span class="p">],</span>
                <span class="n">dicf</span><span class="p">))</span>
    <span class="c1"># xch fluxes</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">ftbl</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;INEQUALITIES&quot;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">())</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;XCH&quot;</span><span class="p">,[]):</span>
        <span class="c1">#print row;##</span>
        <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;COMP&quot;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;&gt;=&quot;</span><span class="p">,</span> <span class="s2">&quot;=&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;=&quot;</span><span class="p">,</span> <span class="s2">&quot;=&lt;&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;COMP field in INEQUALITIES section must be one of &#39;&gt;=&#39;, &#39;=&gt;&#39;, &#39;&lt;=&#39;, &#39;=&lt;&#39; and not &#39;</span><span class="si">%s</span><span class="s2">&#39; (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">).&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;COMP&quot;</span><span class="p">],</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
        <span class="n">val</span><span class="o">=</span><span class="n">eval_expr</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;VALUE field in INEQUALITIES section must evaluate to a float number &#39;</span><span class="si">%s</span><span class="s2">&#39; (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">).&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">],</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
        <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_inequal&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span>
                <span class="nb">float</span><span class="p">(</span><span class="n">val</span><span class="p">),</span>
                <span class="n">row</span><span class="p">[</span><span class="s2">&quot;COMP&quot;</span><span class="p">],</span>
                <span class="n">formula2dict</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;FORMULA&quot;</span><span class="p">])))</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">afftype</span><span class="p">,</span> <span class="n">ftype</span><span class="p">)</span> <span class="ow">in</span> <span class="p">((</span><span class="s2">&quot;Net&quot;</span><span class="p">,</span> <span class="s2">&quot;net&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;Exchange&quot;</span><span class="p">,</span> <span class="s2">&quot;xch&quot;</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_inequal&quot;</span><span class="p">][</span><span class="n">ftype</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">fl</span> <span class="ow">in</span> <span class="n">row</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">fl</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;reac&quot;</span><span class="p">]</span><span class="o">|</span><span class="n">eqflux</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> flux `</span><span class="si">%s</span><span class="s2">` in the inequality</span><span class="se">\n</span><span class="si">%s</span><span class="se">\n</span><span class="s2">is not defined in NETWORK neither EQUALITY sections.&quot;</span><span class="o">%</span>
                        <span class="p">(</span><span class="n">afftype</span><span class="p">,</span> <span class="n">fl</span><span class="p">,</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">row</span><span class="p">)))</span>
    <span class="c1"># metabolite inequalities (like the flux ones)</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;metab_inequal&quot;</span><span class="p">]</span><span class="o">=</span><span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">ftbl</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;INEQUALITIES&quot;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">())</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;METAB&quot;</span><span class="p">,[]):</span>
        <span class="n">dicf</span><span class="o">=</span><span class="n">formula2dict</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;FORMULA&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;COMP&quot;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;&gt;=&quot;</span><span class="p">,</span> <span class="s2">&quot;=&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;=&quot;</span><span class="p">,</span> <span class="s2">&quot;=&lt;&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;COMP field in INEQUALITIES section must be one of &#39;&gt;=&#39;, &#39;=&gt;&#39;, &#39;&lt;=&#39;, &#39;=&lt;&#39; and not &#39;</span><span class="si">%s</span><span class="s2">&#39; (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">).&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;COMP&quot;</span><span class="p">],</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
        <span class="n">nb_neg</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">dicf</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">m</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;metabint&quot;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Metabolite `</span><span class="si">%s</span><span class="s2">` is not internal metabolite (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">).&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
            <span class="k">if</span> <span class="n">m</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;met_pools&quot;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Metabolite `</span><span class="si">%s</span><span class="s2">` is not declared in METABOLITE_POOLS section (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">).&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
            <span class="n">nb_neg</span><span class="o">+=</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;met_pools&quot;</span><span class="p">][</span><span class="n">m</span><span class="p">]</span><span class="o">&lt;</span><span class="mi">0</span>
        <span class="k">if</span> <span class="n">nb_neg</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;At least one of metabolites &#39;</span><span class="si">%s</span><span class="s2">&#39; must be declared as variable (i.e. having negative value) in the section METABOLITE_POOLS (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">).&quot;</span><span class="o">%</span><span class="p">(</span><span class="s2">&quot;&#39;, &#39;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">dicf</span><span class="o">.</span><span class="n">keys</span><span class="p">())),</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
        <span class="n">val</span><span class="o">=</span><span class="n">eval_expr</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;VALUE content &#39;</span><span class="si">%s</span><span class="s2">&#39; must evaluate to a float number, cf. the section METABOLITE_POOLS (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">).&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">],</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
        <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;metab_inequal&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span>
                <span class="nb">float</span><span class="p">(</span><span class="n">val</span><span class="p">),</span>
                <span class="n">row</span><span class="p">[</span><span class="s2">&quot;COMP&quot;</span><span class="p">],</span>
                <span class="n">dicf</span><span class="p">,</span>
                <span class="n">row</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span><span class="o">+</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;COMP&quot;</span><span class="p">]</span><span class="o">+</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;FORMULA&quot;</span><span class="p">]</span><span class="o">+</span><span class="s2">&quot;: &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">])))</span>

    <span class="c1"># Check that fluxes are all in reactions and eqflux</span>
    <span class="c1"># then form nx2dfcg dictionary</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">affnx</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">nxsh</span><span class="p">)</span> <span class="ow">in</span> <span class="p">((</span><span class="s2">&quot;net&quot;</span><span class="p">,</span> <span class="s2">&quot;net&quot;</span><span class="p">,</span> <span class="s2">&quot;n.&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;exchange&quot;</span><span class="p">,</span> <span class="s2">&quot;xch&quot;</span><span class="p">,</span> <span class="s2">&quot;x.&quot;</span><span class="p">)):</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">affdfcg</span><span class="p">,</span> <span class="n">dfcg</span><span class="p">,</span> <span class="n">dfcgsh</span><span class="p">)</span> <span class="ow">in</span> <span class="p">((</span><span class="s2">&quot;Dependent&quot;</span><span class="p">,</span> <span class="s2">&quot;flux_dep&quot;</span><span class="p">,</span> <span class="s2">&quot;d.&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;Free&quot;</span><span class="p">,</span> <span class="s2">&quot;flux_free&quot;</span><span class="p">,</span> <span class="s2">&quot;f.&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;Constrained&quot;</span><span class="p">,</span> <span class="s2">&quot;flux_constr&quot;</span><span class="p">,</span> <span class="s2">&quot;c.&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;Variable growth&quot;</span><span class="p">,</span> <span class="s2">&quot;flux_vgrowth&quot;</span><span class="p">,</span> <span class="s2">&quot;g.&quot;</span><span class="p">)):</span>
            <span class="c1">#print netan[dfcg][nx];##</span>
            <span class="k">for</span> <span class="n">fl</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="n">dfcg</span><span class="p">][</span><span class="n">nx</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">fl</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;reac&quot;</span><span class="p">]</span><span class="o">|</span><span class="n">eqflux</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> flux `</span><span class="si">%s</span><span class="s2">` is not defined in NETWORK neither EQUALITY sections.&quot;</span><span class="o">%</span>
                       <span class="p">(</span><span class="n">affdfcg</span><span class="p">,</span> <span class="n">affnx</span><span class="p">,</span> <span class="n">fl</span><span class="p">))</span>
                <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;nx2dfcg&quot;</span><span class="p">][</span><span class="n">nxsh</span><span class="o">+</span><span class="n">fl</span><span class="p">]</span><span class="o">=</span><span class="n">dfcgsh</span><span class="o">+</span><span class="n">nxsh</span><span class="o">+</span><span class="n">fl</span>
    <span class="c1"># labeled measurements</span>
    <span class="n">proc_label_meas</span><span class="p">(</span><span class="n">ftbl</span><span class="p">,</span> <span class="n">netan</span><span class="p">)</span>
    <span class="n">proc_peak_meas</span><span class="p">(</span><span class="n">ftbl</span><span class="p">,</span> <span class="n">netan</span><span class="p">)</span>
    <span class="n">proc_mass_meas</span><span class="p">(</span><span class="n">ftbl</span><span class="p">,</span> <span class="n">netan</span><span class="p">)</span>
    
    <span class="c1"># discard empty entries</span>
    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">netan</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="n">netan</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span> <span class="k">pass</span>

    <span class="c1"># fwd-rev flux balance</span>
    <span class="k">del</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
    <span class="n">res</span><span class="o">=</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_m_r&quot;</span><span class="p">]</span>
    <span class="c1"># res[metab][&quot;in&quot;]=list(fwd.flux|rev.flux)</span>
    <span class="c1"># res[metab][&quot;out&quot;]=list(fwd.flux|rev.flux)</span>
    <span class="k">for</span> <span class="n">metab</span><span class="p">,</span><span class="n">lr</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;sto_m_r&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="c1"># lr is dico with &#39;left&#39; and &#39;right&#39; entries</span>
        <span class="c1">#print &quot;fwd metab=&quot;+str(metab);##</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">metab</span> <span class="ow">in</span> <span class="n">res</span><span class="p">:</span>
            <span class="n">res</span><span class="p">[</span><span class="n">metab</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;in&quot;</span><span class="p">:[],</span> <span class="s2">&quot;out&quot;</span><span class="p">:[]}</span>
        <span class="k">for</span> <span class="n">reac</span><span class="p">,</span><span class="n">_</span> <span class="ow">in</span> <span class="n">lr</span><span class="p">[</span><span class="s2">&quot;left&quot;</span><span class="p">]:</span>
            <span class="c1"># here metabolite is consumed in fwd reaction</span>
            <span class="c1"># and produced in the reverse one.</span>
            <span class="n">res</span><span class="p">[</span><span class="n">metab</span><span class="p">][</span><span class="s2">&quot;out&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;fwd.&quot;</span><span class="o">+</span><span class="n">reac</span><span class="p">)</span>
            <span class="c1">#if reac not in netan[&quot;notrev&quot;]:</span>
            <span class="k">if</span> <span class="n">reac</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_inout&quot;</span><span class="p">]:</span>
                <span class="n">res</span><span class="p">[</span><span class="n">metab</span><span class="p">][</span><span class="s2">&quot;in&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;rev.&quot;</span><span class="o">+</span><span class="n">reac</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">reac</span><span class="p">,</span><span class="n">_</span> <span class="ow">in</span> <span class="n">lr</span><span class="p">[</span><span class="s2">&quot;right&quot;</span><span class="p">]:</span>
            <span class="c1"># here metabolite is consumed in rev reaction</span>
            <span class="c1"># and produced in the forward one.</span>
            <span class="n">res</span><span class="p">[</span><span class="n">metab</span><span class="p">][</span><span class="s2">&quot;in&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;fwd.&quot;</span><span class="o">+</span><span class="n">reac</span><span class="p">)</span>
            <span class="c1">#if reac not in netan[&quot;notrev&quot;]:</span>
            <span class="k">if</span> <span class="n">reac</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_inout&quot;</span><span class="p">]:</span>
                <span class="n">res</span><span class="p">[</span><span class="n">metab</span><span class="p">][</span><span class="s2">&quot;out&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;rev.&quot;</span><span class="o">+</span><span class="n">reac</span><span class="p">)</span>

    <span class="c1"># metabolite network</span>
    <span class="n">res</span><span class="o">=</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;metab_netw&quot;</span><span class="p">]</span>
    <span class="c1"># left part or reaction points to right part</span>
    <span class="k">for</span> <span class="n">reac</span><span class="p">,</span><span class="n">parts</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;formula&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">metab</span><span class="p">,</span><span class="n">_</span> <span class="ow">in</span> <span class="n">parts</span><span class="p">[</span><span class="s2">&quot;left&quot;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">metab</span> <span class="ow">in</span> <span class="n">res</span><span class="p">:</span>
                <span class="n">res</span><span class="p">[</span><span class="n">metab</span><span class="p">]</span><span class="o">=</span><span class="n">oset</span><span class="p">()</span>
            <span class="n">res</span><span class="p">[</span><span class="n">metab</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">m</span> <span class="k">for</span> <span class="n">m</span><span class="p">,</span><span class="n">_</span> <span class="ow">in</span> <span class="n">parts</span><span class="p">[</span><span class="s2">&quot;right&quot;</span><span class="p">])</span>
    <span class="c1"># order cumomers by weight. For a given weight, cumomers are sorted by</span>
    <span class="c1"># metabolites order.</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;Cmax&quot;</span><span class="p">]</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;Clen&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="n">Cmax</span><span class="o">=</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;Cmax&quot;</span><span class="p">]</span>
    <span class="c1">#return netan;##</span>
    <span class="c1"># cumomers systems A*x=b, one by weight</span>
    <span class="c1"># weights are going from 1 to Cmax where Cmax is the maximal</span>
    <span class="c1"># carbon string length in all metabolites</span>
    <span class="c1"># A is a list of matrices (in weight order)</span>
    <span class="c1"># b is a list of right hand parts (still in weight order)</span>
    <span class="c1"># the dimensions of various weights in b are not the same</span>
    <span class="c1"># too short metabolites are dropped when going to higher weights.</span>
    <span class="n">res</span><span class="o">=</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;cumo_sys&quot;</span><span class="p">]</span>
    <span class="n">res</span><span class="p">[</span><span class="s2">&quot;A&quot;</span><span class="p">]</span><span class="o">=</span><span class="p">[{}</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Cmax</span><span class="p">)]</span>
    <span class="n">res</span><span class="p">[</span><span class="s2">&quot;b&quot;</span><span class="p">]</span><span class="o">=</span><span class="p">[{}</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Cmax</span><span class="p">)]</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># run through all reactions and update bilan of involved cumomers</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">reac</span><span class="p">,</span><span class="n">lrdict</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">iter</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;carbotrans&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span> <span class="k">if</span> <span class="n">fullsys</span> <span class="k">else</span> <span class="p">[]:</span>
            <span class="c1"># run through metabs</span>
            <span class="c1">## aff(&quot;lrdict&quot;, lrdict);#</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">imetab</span><span class="p">,</span><span class="n">lr</span><span class="p">,</span><span class="n">metab</span><span class="p">,</span><span class="n">cstr</span><span class="p">)</span> <span class="ow">in</span> <span class="p">((</span><span class="n">imetab</span><span class="p">,</span><span class="n">lr</span><span class="p">,</span><span class="n">metab</span><span class="p">,</span><span class="n">cstr</span><span class="p">)</span>
                    <span class="k">for</span> <span class="p">(</span><span class="n">lr</span><span class="p">,</span><span class="n">lst</span><span class="p">)</span> <span class="ow">in</span> <span class="n">lrdict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                    <span class="k">for</span> <span class="p">(</span><span class="n">imetab</span><span class="p">,(</span><span class="n">metab</span><span class="p">,</span><span class="n">cstr</span><span class="p">))</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lst</span><span class="p">)):</span>
                <span class="c1"># if output metab then influx is set to 1</span>
                <span class="c1"># so its cumomer distribution is directly</span>
                <span class="c1"># defined by cumodistr of inputs</span>
                <span class="n">Clen</span><span class="o">=</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;Clen&quot;</span><span class="p">][</span><span class="n">metab</span><span class="p">]</span>
                <span class="c1"># input metabolite has fixed value so put it in rhs</span>
                <span class="c1"># when it is an influx for some internal cumomer</span>
                <span class="k">if</span> <span class="n">metab</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">]</span> <span class="ow">or</span> <span class="n">metab</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;output&quot;</span><span class="p">]:</span>
                    <span class="k">continue</span>
                <span class="c1"># &#39;out&#39; part of this metab</span>
                <span class="n">fwd_rev</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;fwd.&quot;</span> <span class="k">if</span> <span class="n">lr</span><span class="o">==</span><span class="s2">&quot;left&quot;</span> <span class="k">else</span> <span class="s2">&quot;rev.&quot;</span><span class="p">)</span>
                <span class="n">flux</span><span class="o">=</span><span class="n">fwd_rev</span><span class="o">+</span><span class="n">reac</span>
                <span class="c1">#if (fwd_rev==&quot;fwd.&quot; or reac not in netan[&quot;notrev&quot;]):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">fwd_rev</span><span class="o">==</span><span class="s2">&quot;fwd.&quot;</span> <span class="ow">or</span> <span class="n">reac</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_inout&quot;</span><span class="p">]):</span>
                    <span class="c1"># add this out-flux</span>
                    <span class="c1"># run through all cumomers of metab</span>
                    <span class="k">for</span> <span class="n">icumo</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">Clen</span><span class="p">):</span>
                        <span class="n">cumo</span><span class="o">=</span><span class="n">metab</span><span class="o">+</span><span class="s2">&quot;:&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">icumo</span><span class="p">)</span>
                        <span class="n">w</span><span class="o">=</span><span class="n">sumbit</span><span class="p">(</span><span class="n">icumo</span><span class="p">)</span>
                        <span class="c1">#print &quot;w,i,clen,metab=&quot;, w, icumo,Clen,metab;##</span>
                        <span class="k">if</span> <span class="n">cumo</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">res</span><span class="p">[</span><span class="s2">&quot;A&quot;</span><span class="p">][</span><span class="n">w</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                            <span class="n">res</span><span class="p">[</span><span class="s2">&quot;A&quot;</span><span class="p">][</span><span class="n">w</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">cumo</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="n">cumo</span><span class="p">:[]}</span>
                        <span class="c1"># main diagonal term (&#39;out&#39; part)</span>
                        <span class="n">res</span><span class="p">[</span><span class="s2">&quot;A&quot;</span><span class="p">][</span><span class="n">w</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">cumo</span><span class="p">][</span><span class="n">cumo</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">flux</span><span class="p">)</span>
                        <span class="c1">##print &#39;m,ic,w=&#39;+metab, icumo, w;#</span>
                        <span class="c1">##aff(&quot;res[&quot;A&quot;][w-1][cumo][cumo]&quot;, res[&quot;A&quot;][w-1][cumo][cumo]);#</span>
                <span class="c1"># &#39;in&#39; part</span>
                <span class="n">fwd_rev</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;rev.&quot;</span> <span class="k">if</span> <span class="n">lr</span><span class="o">==</span><span class="s2">&quot;left&quot;</span> <span class="k">else</span> <span class="s2">&quot;fwd.&quot;</span><span class="p">)</span>
                <span class="n">flux</span><span class="o">=</span><span class="n">fwd_rev</span><span class="o">+</span><span class="n">reac</span>
                <span class="n">in_lr</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;left&quot;</span> <span class="k">if</span> <span class="n">lr</span><span class="o">==</span><span class="s2">&quot;right&quot;</span> <span class="k">else</span> <span class="s2">&quot;right&quot;</span><span class="p">)</span>
                <span class="c1">#if (fwd_rev==&quot;rev.&quot; and reac in netan[&quot;notrev&quot;]):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">fwd_rev</span><span class="o">==</span><span class="s2">&quot;rev.&quot;</span> <span class="ow">and</span> <span class="n">reac</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_inout&quot;</span><span class="p">]):</span>
                    <span class="c1"># this cannot be by definition</span>
                    <span class="k">continue</span>
                <span class="c1"># add this in-flux</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">in_i</span><span class="p">,(</span><span class="n">in_metab</span><span class="p">,</span> <span class="n">in_cstr</span><span class="p">))</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lrdict</span><span class="p">[</span><span class="n">in_lr</span><span class="p">]):</span>
                    <span class="c1"># run through all cumomers of metab</span>
                    <span class="k">for</span> <span class="n">icumo</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">Clen</span><span class="p">):</span>
                        <span class="n">cumo</span><span class="o">=</span><span class="n">metab</span><span class="o">+</span><span class="s2">&quot;:&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">icumo</span><span class="p">)</span>
                        <span class="n">w</span><span class="o">=</span><span class="n">sumbit</span><span class="p">(</span><span class="n">icumo</span><span class="p">)</span>
                        <span class="c1"># get in_cumo</span>
                        <span class="n">in_icumo</span><span class="o">=</span><span class="n">src_ind</span><span class="p">(</span><span class="n">in_cstr</span><span class="p">,</span> <span class="n">cstr</span><span class="p">,</span> <span class="n">icumo</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">in_icumo</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="n">in_cumo</span><span class="o">=</span><span class="n">in_metab</span><span class="o">+</span><span class="s2">&quot;:&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">in_icumo</span><span class="p">)</span>
                        <span class="n">in_w</span><span class="o">=</span><span class="n">sumbit</span><span class="p">(</span><span class="n">in_icumo</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">cumo</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">res</span><span class="p">[</span><span class="s2">&quot;A&quot;</span><span class="p">][</span><span class="n">w</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                            <span class="n">res</span><span class="p">[</span><span class="s2">&quot;A&quot;</span><span class="p">][</span><span class="n">w</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">cumo</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="n">cumo</span><span class="p">:[]}</span>
                        <span class="k">if</span> <span class="n">in_w</span><span class="o">==</span><span class="n">w</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">in_metab</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">]:</span>
                                <span class="c1"># put it in rhs</span>
                                <span class="k">if</span> <span class="n">cumo</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">res</span><span class="p">[</span><span class="s2">&quot;b&quot;</span><span class="p">][</span><span class="n">w</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                                    <span class="n">res</span><span class="p">[</span><span class="s2">&quot;b&quot;</span><span class="p">][</span><span class="n">w</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">cumo</span><span class="p">]</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span>
                                <span class="k">if</span> <span class="n">flux</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">res</span><span class="p">[</span><span class="s2">&quot;b&quot;</span><span class="p">][</span><span class="n">w</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">cumo</span><span class="p">]:</span>
                                    <span class="n">res</span><span class="p">[</span><span class="s2">&quot;b&quot;</span><span class="p">][</span><span class="n">w</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">cumo</span><span class="p">][</span><span class="n">flux</span><span class="p">]</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span>
                                <span class="k">if</span> <span class="n">imetab</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">res</span><span class="p">[</span><span class="s2">&quot;b&quot;</span><span class="p">][</span><span class="n">w</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">cumo</span><span class="p">][</span><span class="n">flux</span><span class="p">]:</span>
                                    <span class="n">res</span><span class="p">[</span><span class="s2">&quot;b&quot;</span><span class="p">][</span><span class="n">w</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">cumo</span><span class="p">][</span><span class="n">flux</span><span class="p">][</span><span class="n">imetab</span><span class="p">]</span><span class="o">=</span><span class="p">[]</span>
                                <span class="k">if</span> <span class="ow">not</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;cumo_input&quot;</span><span class="p">]</span> <span class="ow">or</span> <span class="n">in_cumo</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;cumo_input&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
                                    <span class="c1"># put this in_cumo ih the dict</span>
                                    <span class="n">iso2cumo</span><span class="p">(</span><span class="n">netan</span><span class="p">,</span> <span class="s2">&quot;cumo_input&quot;</span><span class="p">,</span> <span class="n">in_cumo</span><span class="p">,</span> <span class="n">in_icumo</span><span class="p">,</span> <span class="n">in_metab</span><span class="p">)</span>
                                <span class="n">res</span><span class="p">[</span><span class="s2">&quot;b&quot;</span><span class="p">][</span><span class="n">w</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">cumo</span><span class="p">][</span><span class="n">flux</span><span class="p">][</span><span class="n">imetab</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">in_cumo</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">in_cumo</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">res</span><span class="p">[</span><span class="s2">&quot;A&quot;</span><span class="p">][</span><span class="n">w</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">cumo</span><span class="p">]:</span>
                                    <span class="n">res</span><span class="p">[</span><span class="s2">&quot;A&quot;</span><span class="p">][</span><span class="n">w</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">cumo</span><span class="p">][</span><span class="n">in_cumo</span><span class="p">]</span><span class="o">=</span><span class="p">[]</span>
                                <span class="c1"># matrix: linearized off-diagonal term</span>
                                <span class="n">res</span><span class="p">[</span><span class="s2">&quot;A&quot;</span><span class="p">][</span><span class="n">w</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">cumo</span><span class="p">][</span><span class="n">in_cumo</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">flux</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="n">in_w</span> <span class="o">&lt;</span> <span class="n">w</span><span class="p">:</span>
                            <span class="c1"># put lighter cumomer product in rhs list[iterm]</span>
                            <span class="k">if</span> <span class="n">cumo</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">res</span><span class="p">[</span><span class="s2">&quot;b&quot;</span><span class="p">][</span><span class="n">w</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                                <span class="n">res</span><span class="p">[</span><span class="s2">&quot;b&quot;</span><span class="p">][</span><span class="n">w</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">cumo</span><span class="p">]</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span>
                            <span class="k">if</span> <span class="n">flux</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">res</span><span class="p">[</span><span class="s2">&quot;b&quot;</span><span class="p">][</span><span class="n">w</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">cumo</span><span class="p">]:</span>
                                <span class="n">res</span><span class="p">[</span><span class="s2">&quot;b&quot;</span><span class="p">][</span><span class="n">w</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">cumo</span><span class="p">][</span><span class="n">flux</span><span class="p">]</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span>
                            <span class="k">if</span> <span class="n">imetab</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">res</span><span class="p">[</span><span class="s2">&quot;b&quot;</span><span class="p">][</span><span class="n">w</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">cumo</span><span class="p">][</span><span class="n">flux</span><span class="p">]:</span>
                                <span class="n">res</span><span class="p">[</span><span class="s2">&quot;b&quot;</span><span class="p">][</span><span class="n">w</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">cumo</span><span class="p">][</span><span class="n">flux</span><span class="p">][</span><span class="n">imetab</span><span class="p">]</span><span class="o">=</span><span class="p">[]</span>
                            <span class="c1">#res[&quot;b&quot;][w-1][cumo][flux][imetab].append(</span>
                            <span class="c1">#    in_cumo if in_metab not in netan[&quot;input&quot;] else</span>
                            <span class="c1">#    netan[&quot;cumo_input&quot;][in_cumo])</span>
                            <span class="n">res</span><span class="p">[</span><span class="s2">&quot;b&quot;</span><span class="p">][</span><span class="n">w</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">cumo</span><span class="p">][</span><span class="n">flux</span><span class="p">][</span><span class="n">imetab</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">in_cumo</span><span class="p">)</span>
                            <span class="c1">#print &quot;b=&quot;+str(res[&quot;b&quot;][w-1][cumo][flux]);##</span>
                        <span class="c1"># if in_w==0 then in_cumo=1 by definition =&gt; ignore here</span>
                        <span class="c1"># in_w cannot be &gt; w because of src_ind()</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">inst</span><span class="p">:</span>
        <span class="n">werr</span><span class="p">(</span><span class="s2">&quot;: &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">inst</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="c1">#netan[&quot;cumo_input&quot;]=[dict((k,(v if v==v else 0.)) for k,v in d.items()) for d in netan[&quot;cumo_input&quot;]]</span>
    <span class="c1"># ordered cumomer lists</span>
    <span class="c1">#for w in range(1,netan[&quot;Cmax&quot;]+1):</span>
        <span class="c1"># weight 1 equations have all metabolites</span>
        <span class="c1">##aff(&quot;A &quot;+str(w), netan[&quot;cumo_sys&quot;][&quot;A&quot;][w-1]);#</span>
        <span class="c1">##aff(&quot;b &quot;+str(w), netan[&quot;cumo_sys&quot;][&quot;b&quot;][w-1]);#</span>
        <span class="c1"># order cumos along pathways</span>
        <span class="c1"># starts are input cumomers</span>
    <span class="c1">#    starts=[cumo for cumo in netan[&quot;cumo_sys&quot;][&quot;A&quot;][w-1] \</span>
    <span class="c1">#        if cumo.split(&quot;:&quot;)[0] in netan[&quot;input&quot;]]</span>
        <span class="c1">##aff(&quot;st &quot;+str(w), starts)</span>
        <span class="c1"># complete starts by all others cumomers</span>
    <span class="c1">#    starts+=[c for c in netan[&quot;cumo_sys&quot;][&quot;A&quot;][w-1] if not c in starts]</span>
    <span class="c1">#    cumo_paths=cumo_path(starts, netan[&quot;cumo_sys&quot;][&quot;A&quot;][w-1], oset())</span>
        <span class="c1"># order</span>
    <span class="c1">#    netan[&quot;vcumo&quot;].append([cumo for cumo in valval(cumo_paths)])</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vcumo&quot;</span><span class="p">]</span><span class="o">=</span><span class="p">[[</span><span class="o">*</span><span class="n">a</span><span class="o">.</span><span class="n">keys</span><span class="p">()]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;cumo_sys&quot;</span><span class="p">][</span><span class="s2">&quot;A&quot;</span><span class="p">]]</span>

    <span class="c1"># ordered unknown flux lists</span>
    <span class="c1"># get all reactions which are not constrained, not free and not growth</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">reac</span> <span class="k">for</span> <span class="n">reac</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;reac&quot;</span><span class="p">]</span><span class="o">|</span><span class="n">eqflux</span>
        <span class="k">if</span> <span class="n">reac</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_constr&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">]</span> <span class="ow">and</span>
        <span class="n">reac</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_free&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">]</span> <span class="ow">and</span>
        <span class="n">reac</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_vgrowth&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">])</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">reac</span> <span class="k">for</span> <span class="n">reac</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;reac&quot;</span><span class="p">]</span><span class="o">|</span><span class="n">eqflux</span>
        <span class="k">if</span> <span class="n">reac</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_constr&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">]</span> <span class="ow">and</span>
        <span class="n">reac</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_free&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">]</span> <span class="ow">and</span>
        <span class="n">reac</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_vgrowth&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">])</span>

    <span class="c1"># order</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    
    <span class="c1"># easy index finder</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux&quot;</span><span class="p">][</span><span class="s2">&quot;net2i&quot;</span><span class="p">]</span><span class="o">=</span><span class="nb">dict</span><span class="p">((</span><span class="n">fl</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">fl</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">]))</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux&quot;</span><span class="p">][</span><span class="s2">&quot;xch2i&quot;</span><span class="p">]</span><span class="o">=</span><span class="nb">dict</span><span class="p">((</span><span class="n">fl</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">fl</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">]))</span>


    <span class="c1"># ordered free flux lists</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_free&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">]</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_free&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_free&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">]</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_free&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="c1"># order</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_free&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_free&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    
    <span class="c1"># easy index finder</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_free&quot;</span><span class="p">][</span><span class="s2">&quot;net2i&quot;</span><span class="p">]</span><span class="o">=</span><span class="nb">dict</span><span class="p">((</span><span class="n">fl</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">fl</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_free&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">]))</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_free&quot;</span><span class="p">][</span><span class="s2">&quot;xch2i&quot;</span><span class="p">]</span><span class="o">=</span><span class="nb">dict</span><span class="p">((</span><span class="n">fl</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">fl</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_free&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">]))</span>


    <span class="c1"># ordered constrained flux lists</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_constr&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">]</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_constr&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_constr&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">]</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_constr&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="c1"># order</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_constr&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_constr&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    
    <span class="c1"># easy index finder</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_constr&quot;</span><span class="p">][</span><span class="s2">&quot;net2i&quot;</span><span class="p">]</span><span class="o">=</span><span class="nb">dict</span><span class="p">((</span><span class="n">fl</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">fl</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_constr&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">]))</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_constr&quot;</span><span class="p">][</span><span class="s2">&quot;xch2i&quot;</span><span class="p">]</span><span class="o">=</span><span class="nb">dict</span><span class="p">((</span><span class="n">fl</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">fl</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_constr&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">]))</span>


    <span class="c1"># ordered measured flux lists</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_meas&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">]</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_measured&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="c1"># order</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_meas&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    
    <span class="c1"># easy index finder</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_meas&quot;</span><span class="p">][</span><span class="s2">&quot;net2i&quot;</span><span class="p">]</span><span class="o">=</span><span class="nb">dict</span><span class="p">((</span><span class="n">fl</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">fl</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_meas&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">]))</span>

    <span class="c1"># ordered variable growth fluxes</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_growth&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">]</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_vgrowth&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_growth&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">]</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_vgrowth&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="c1"># order</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_growth&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_growth&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    
    <span class="c1"># easy index finder</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_growth&quot;</span><span class="p">][</span><span class="s2">&quot;net2i&quot;</span><span class="p">]</span><span class="o">=</span><span class="nb">dict</span><span class="p">((</span><span class="n">fl</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">fl</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_growth&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">]))</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_growth&quot;</span><span class="p">][</span><span class="s2">&quot;xch2i&quot;</span><span class="p">]</span><span class="o">=</span><span class="nb">dict</span><span class="p">((</span><span class="n">fl</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">fl</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_growth&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">]))</span>

    <span class="c1"># ordered complete flux lists</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_compl&quot;</span><span class="p">]</span><span class="o">=</span><span class="p">{</span>
        <span class="s2">&quot;net&quot;</span><span class="p">:</span> 
        <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">]</span><span class="o">+</span>
        <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_free&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">]</span><span class="o">+</span>
        <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_constr&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">]</span><span class="o">+</span>
        <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_growth&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">],</span>
        <span class="s2">&quot;xch&quot;</span><span class="p">:</span>
        <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">]</span><span class="o">+</span>
        <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_free&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">]</span><span class="o">+</span>
        <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_constr&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">]</span><span class="o">+</span>
        <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_growth&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">],</span>
    <span class="p">}</span>
    <span class="c1"># easy index finding</span>
    <span class="c1"># net</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_compl&quot;</span><span class="p">][</span><span class="s2">&quot;net2i&quot;</span><span class="p">]</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
        <span class="p">(</span><span class="n">fl</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">fl</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">])</span>
    <span class="p">)</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_compl&quot;</span><span class="p">][</span><span class="s2">&quot;net2i&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span>
        <span class="p">(</span><span class="n">fl</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">]))</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">fl</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_free&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">])</span>
    <span class="p">))</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_compl&quot;</span><span class="p">][</span><span class="s2">&quot;net2i&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span>
        <span class="p">(</span><span class="n">fl</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">])</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_free&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">]))</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">fl</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_constr&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">])</span>
    <span class="p">))</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_compl&quot;</span><span class="p">][</span><span class="s2">&quot;net2i&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span>
        <span class="p">(</span><span class="n">fl</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">])</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_free&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">])</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_constr&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">]))</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">fl</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_growth&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">])</span>
    <span class="p">))</span>
    <span class="c1"># xch</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_compl&quot;</span><span class="p">][</span><span class="s2">&quot;xch2i&quot;</span><span class="p">]</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
        <span class="p">(</span><span class="n">fl</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">fl</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">])</span>
    <span class="p">)</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_compl&quot;</span><span class="p">][</span><span class="s2">&quot;xch2i&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span>
        <span class="p">(</span><span class="n">fl</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">]))</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">fl</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_free&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">])</span>
    <span class="p">))</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_compl&quot;</span><span class="p">][</span><span class="s2">&quot;xch2i&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span>
        <span class="p">(</span><span class="n">fl</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">])</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_free&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">]))</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">fl</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_constr&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">])</span>
    <span class="p">))</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_compl&quot;</span><span class="p">][</span><span class="s2">&quot;xch2i&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span>
        <span class="p">(</span><span class="n">fl</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">])</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_free&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">])</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_constr&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">]))</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">fl</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_growth&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">])</span>
    <span class="p">))</span>

    <span class="c1"># ordered fwd-rev flux lists</span>
    <span class="c1"># fw and rv parts are identical so they match each other</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_fwrv&quot;</span><span class="p">][</span><span class="s2">&quot;fwrv&quot;</span><span class="p">]</span><span class="o">=</span>\
        <span class="p">[</span><span class="s2">&quot;fwd.&quot;</span><span class="o">+</span><span class="n">fl</span> <span class="k">for</span> <span class="n">fl</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">]]</span><span class="o">+</span>\
        <span class="p">[</span><span class="s2">&quot;fwd.&quot;</span><span class="o">+</span><span class="n">fl</span> <span class="k">for</span> <span class="n">fl</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_free&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">]]</span><span class="o">+</span>\
        <span class="p">[</span><span class="s2">&quot;fwd.&quot;</span><span class="o">+</span><span class="n">fl</span> <span class="k">for</span> <span class="n">fl</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_constr&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">]]</span><span class="o">+</span>\
        <span class="p">[</span><span class="s2">&quot;fwd.&quot;</span><span class="o">+</span><span class="n">fl</span> <span class="k">for</span> <span class="n">fl</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_growth&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">]]</span><span class="o">+</span>\
        <span class="p">[</span><span class="s2">&quot;rev.&quot;</span><span class="o">+</span><span class="n">fl</span> <span class="k">for</span> <span class="n">fl</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">]]</span><span class="o">+</span>\
        <span class="p">[</span><span class="s2">&quot;rev.&quot;</span><span class="o">+</span><span class="n">fl</span> <span class="k">for</span> <span class="n">fl</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_free&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">]]</span><span class="o">+</span>\
        <span class="p">[</span><span class="s2">&quot;rev.&quot;</span><span class="o">+</span><span class="n">fl</span> <span class="k">for</span> <span class="n">fl</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_constr&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">]]</span><span class="o">+</span>\
        <span class="p">[</span><span class="s2">&quot;rev.&quot;</span><span class="o">+</span><span class="n">fl</span> <span class="k">for</span> <span class="n">fl</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_growth&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">]]</span>
    
    <span class="c1"># order</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_fwrv&quot;</span><span class="p">][</span><span class="s2">&quot;fwrv&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    
    <span class="c1"># easy index finder</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_fwrv&quot;</span><span class="p">][</span><span class="s2">&quot;fwrv2i&quot;</span><span class="p">]</span><span class="o">=</span><span class="nb">dict</span><span class="p">((</span><span class="n">fl</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">fl</span><span class="p">)</span> <span class="ow">in</span>
        <span class="nb">enumerate</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux_fwrv&quot;</span><span class="p">][</span><span class="s2">&quot;fwrv&quot;</span><span class="p">]))</span>
        
    <span class="c1"># ordered metabolite pools</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vpool&quot;</span><span class="p">]</span><span class="o">=</span><span class="p">{</span>
        <span class="s2">&quot;free&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">m</span> <span class="k">for</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;met_pools&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="mf">0.</span><span class="p">],</span>
        <span class="s2">&quot;constrained&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">m</span> <span class="k">for</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;met_pools&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="o">&gt;=</span> <span class="mf">0.</span><span class="p">],</span>
    <span class="p">}</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vpool&quot;</span><span class="p">][</span><span class="s2">&quot;free&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vpool&quot;</span><span class="p">][</span><span class="s2">&quot;constrained&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vpool&quot;</span><span class="p">][</span><span class="s2">&quot;all&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vpool&quot;</span><span class="p">][</span><span class="s2">&quot;free&quot;</span><span class="p">]</span><span class="o">+</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vpool&quot;</span><span class="p">][</span><span class="s2">&quot;constrained&quot;</span><span class="p">]</span>
    <span class="c1"># easy index finding</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vpool&quot;</span><span class="p">][</span><span class="s2">&quot;all2i&quot;</span><span class="p">]</span><span class="o">=</span><span class="nb">dict</span><span class="p">((</span><span class="n">m</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">m</span><span class="p">)</span> <span class="ow">in</span>
        <span class="nb">enumerate</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vpool&quot;</span><span class="p">][</span><span class="s2">&quot;all&quot;</span><span class="p">]))</span>
    
    
    <span class="c1"># linear problem on fluxes Afl*(fl_net;fl_xch)=bfl</span>
    <span class="c1"># matrix Afl is composed of the following parts :</span>
    <span class="c1"># - stocheometic equations (only .net fluxes are involved)</span>
    <span class="c1"># - flux equalities</span>
    <span class="c1"># constrained to non zero value fluxes are replaced by their values in rhs</span>
    <span class="c1"># Afl is a list of lists (two dim array). Primary list is a matrix row,</span>
    <span class="c1"># columns are values in the secondary list and contains matrix coefficients</span>
    <span class="c1"># bfl is a list of linear expressions. Each expression is a dict</span>
    <span class="c1"># where keys are variable names like &quot;f.n.flx&quot; and values are</span>
    <span class="c1"># numeric coefficients</span>
    <span class="c1"># If the key is empty &quot;&quot;, it means that the value is just a scalar to add</span>
    
    <span class="c1"># Full flux names are of the format [dfcg].[nx].&lt;reac&gt;</span>
    <span class="c1"># where &quot;d&quot;, &quot;f&quot;, &quot;c&quot; or &quot;g&quot; correspond to</span>
    <span class="c1"># - dependent</span>
    <span class="c1"># - free</span>
    <span class="c1"># - constrained</span>
    <span class="c1"># - growth</span>
    <span class="c1"># and &lt;reac&gt; correspond to the reaction name</span>
    
    <span class="c1"># stocheometric part</span>
    <span class="n">res</span><span class="o">=</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;Afl&quot;</span><span class="p">]</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">metab</span><span class="p">,</span><span class="n">lr</span><span class="p">)</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;sto_m_r&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="c1">#if metab == &quot;M_adp_c&quot;:</span>
            <span class="c1">#pdb.set_trace()</span>
        <span class="k">if</span> <span class="n">metab</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">]</span> <span class="ow">or</span> <span class="n">metab</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;output&quot;</span><span class="p">]:</span>
            <span class="k">continue</span>
        <span class="c1"># calculate coefs (repeated fluxes)</span>
        <span class="n">coefs</span><span class="o">=</span><span class="nb">dict</span><span class="p">((</span><span class="n">rea</span><span class="p">,</span> <span class="p">[])</span> <span class="k">for</span> <span class="n">rea</span><span class="p">,</span><span class="n">co</span> <span class="ow">in</span> <span class="n">lr</span><span class="p">[</span><span class="s2">&quot;left&quot;</span><span class="p">]</span><span class="o">+</span><span class="n">lr</span><span class="p">[</span><span class="s2">&quot;right&quot;</span><span class="p">])</span>
        <span class="c1"># &#39;left&#39; part consumes metab, hence the sign &#39;-&#39; in -co</span>
        <span class="n">_</span><span class="o">=</span><span class="p">[</span><span class="n">coefs</span><span class="p">[</span><span class="n">rea</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="n">co</span><span class="p">)</span> <span class="k">for</span> <span class="n">rea</span><span class="p">,</span><span class="n">co</span> <span class="ow">in</span> <span class="n">lr</span><span class="p">[</span><span class="s2">&quot;left&quot;</span><span class="p">]]</span>
        <span class="c1"># &#39;right&#39; part produces metab</span>
        <span class="n">_</span><span class="o">=</span><span class="p">[</span><span class="n">coefs</span><span class="p">[</span><span class="n">rea</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">co</span><span class="p">)</span> <span class="k">for</span> <span class="n">rea</span><span class="p">,</span><span class="n">co</span> <span class="ow">in</span> <span class="n">lr</span><span class="p">[</span><span class="s2">&quot;right&quot;</span><span class="p">]]</span>
        <span class="n">coefs</span><span class="o">=</span><span class="nb">dict</span><span class="p">((</span><span class="n">rea</span><span class="p">,</span> <span class="nb">sum</span><span class="p">(</span><span class="n">li</span><span class="p">))</span> <span class="k">for</span> <span class="n">rea</span><span class="p">,</span><span class="n">li</span> <span class="ow">in</span> <span class="n">coefs</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
        <span class="n">deps</span><span class="o">=</span><span class="n">oset</span><span class="p">(</span><span class="n">coefs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">deps</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;A balance on metabolite &#39;</span><span class="si">%s</span><span class="s2">&#39; does not contain any dependent flux.</span><span class="se">\n</span><span class="s2">At least one of the following net fluxes </span><span class="si">%s</span><span class="se">\n</span><span class="s2">must be declared dependent in the FLUX/NET section (put letter &#39;D&#39; in the column &#39;FCD&#39; for some flux).&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">metab</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">coefs</span><span class="o">.</span><span class="n">keys</span><span class="p">())))</span>
        <span class="n">qry</span><span class="o">=</span><span class="p">[</span><span class="n">coefs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">fl</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">fl</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">]]</span>
        <span class="n">qry</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">]))</span>
        <span class="n">mqry</span><span class="o">=-</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">qry</span><span class="p">)</span>
        <span class="c1">#if qry==[0]*len(qry): must be included even if all zeros, so an R warning will work</span>
        <span class="c1">#    # degenerated equation, skip it</span>
        <span class="c1">#    #netan[&quot;flux_equal&quot;][&quot;net&quot;].append((0., coefs))</span>
        <span class="c1">#    raise Exception(&quot;Stocheometric equation is zero for metab &quot;+metab+&quot;\n&quot;+str(lr)+&quot;\n&quot;+str(coefs))</span>
        <span class="c1">#    continue</span>
        <span class="c1"># check if this line was already entered before</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">row</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">res</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">ffguess</span> <span class="ow">and</span> <span class="p">(</span><span class="n">row</span> <span class="o">==</span> <span class="n">qry</span> <span class="ow">or</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="o">==</span> <span class="n">mqry</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()):</span>
                <span class="n">inz</span><span class="o">=</span><span class="nb">set</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">coef</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="k">if</span> <span class="n">coef</span> <span class="o">!=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">wout</span><span class="p">(</span><span class="s2">&quot;***Warning: when trying to add a balance equation for metabolite &#39;&quot;</span><span class="o">+</span><span class="n">metab</span><span class="o">+</span>
                    <span class="s2">&quot;&#39;, got equation redundant with those for &#39;&quot;</span><span class="o">+</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vrowAfl&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="s2">&quot;&#39;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">wout</span><span class="p">(</span><span class="s2">&quot;metab:</span><span class="se">\t</span><span class="s2">&quot;</span><span class="o">+</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">fl</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">fl</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">]</span><span class="o">+</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">])</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inz</span><span class="p">])</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">wout</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vrowAfl&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="s2">&quot;:</span><span class="se">\t</span><span class="s2">&quot;</span><span class="o">+</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">coef</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">coef</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inz</span><span class="p">])</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">wout</span><span class="p">(</span><span class="n">metab</span><span class="o">+</span><span class="s2">&quot;:</span><span class="se">\t</span><span class="s2">&quot;</span><span class="o">+</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">coef</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">coef</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">qry</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inz</span><span class="p">])</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># identique row is not found, add it</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qry</span><span class="p">)</span>
            <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vrowAfl&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">metab</span><span class="p">)</span>
            <span class="c1"># prepare right hand side</span>
            <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;bfl&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">({})</span>
            <span class="n">dtmp</span><span class="o">=</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;bfl&quot;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">fl</span> <span class="ow">in</span> <span class="n">coefs</span><span class="p">:</span>
                <span class="c1">#print &quot;bfl: fl=&quot;+fl;##</span>
                <span class="k">if</span> <span class="n">fl</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_free&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">]:</span>
                    <span class="n">dtmp</span><span class="p">[</span><span class="s2">&quot;f.n.&quot;</span><span class="o">+</span><span class="n">fl</span><span class="p">]</span><span class="o">=</span><span class="n">dtmp</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;f.n.&quot;</span><span class="o">+</span><span class="n">fl</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">-</span><span class="n">coefs</span><span class="p">[</span><span class="n">fl</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">fl</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_constr&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">]:</span>
                    <span class="n">dtmp</span><span class="p">[</span><span class="s2">&quot;c.n.&quot;</span><span class="o">+</span><span class="n">fl</span><span class="p">]</span><span class="o">=</span><span class="n">dtmp</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;c.n.&quot;</span><span class="o">+</span><span class="n">fl</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">-</span><span class="n">coefs</span><span class="p">[</span><span class="n">fl</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">fl</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_vgrowth&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">]:</span>
                    <span class="n">dtmp</span><span class="p">[</span><span class="s2">&quot;g.n.&quot;</span><span class="o">+</span><span class="n">fl</span><span class="p">]</span><span class="o">=</span><span class="n">dtmp</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;g.n.&quot;</span><span class="o">+</span><span class="n">fl</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">-</span><span class="n">coefs</span><span class="p">[</span><span class="n">fl</span><span class="p">]</span>
            <span class="c1">#print &quot;dtmp=&quot;, dtmp</span>

    <span class="c1"># flux equality part</span>
    <span class="n">res</span><span class="o">=</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;Afl&quot;</span><span class="p">]</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">nxl</span><span class="p">)</span> <span class="ow">in</span> <span class="p">((</span><span class="s2">&quot;net&quot;</span><span class="p">,</span> <span class="s2">&quot;n&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;xch&quot;</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">eq</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_equal&quot;</span><span class="p">][</span><span class="n">nx</span><span class="p">]:</span>
            <span class="n">qry</span><span class="o">=</span><span class="p">[]</span>
            <span class="n">qry</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">eq</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">fl</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">fl</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux&quot;</span><span class="p">][</span><span class="n">nx</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">nx</span> <span class="o">==</span> <span class="s2">&quot;net&quot;</span><span class="p">:</span>
                <span class="c1"># add xch zeros</span>
                <span class="n">qry</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux&quot;</span><span class="p">][</span><span class="s2">&quot;xch&quot;</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># prepend zeros for net fluxes</span>
                <span class="n">qry</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vflux&quot;</span><span class="p">][</span><span class="s2">&quot;net&quot;</span><span class="p">])</span>
            <span class="c1"># check qry</span>
            <span class="k">if</span> <span class="n">qry</span> <span class="o">==</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">qry</span><span class="p">):</span>
                <span class="c1"># degenerated equality</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Equality in &quot;</span><span class="o">+</span><span class="n">nx</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="o">+</span><span class="s2">&quot; section: &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; must have at least one dependent flux</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="c1"># check if this line was already entered before</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">ffguess</span><span class="p">:</span>
                <span class="n">mqry</span><span class="o">=-</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">qry</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">res</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">row</span> <span class="o">==</span> <span class="n">qry</span> <span class="ow">or</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="o">==</span> <span class="n">mqry</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;An equality in &quot;</span><span class="o">+</span><span class="n">nx</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="o">+</span><span class="s2">&quot; section is redundant. eq:&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span><span class="o">+</span>
                            <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">qry=&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">qry</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">row=&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">row</span><span class="p">))</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qry</span><span class="p">)</span>
            <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vrowAfl&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;eq &quot;</span><span class="o">+</span><span class="n">nx</span><span class="o">+</span><span class="s2">&quot;: &quot;</span><span class="o">+</span><span class="n">eq</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;bfl&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;&quot;</span><span class="p">:</span><span class="n">eq</span><span class="p">[</span><span class="mi">0</span><span class="p">]})</span>
            <span class="n">dtmp</span><span class="o">=</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;bfl&quot;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># pass free fluxes to rhs</span>
            <span class="k">for</span> <span class="n">fl</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_free&quot;</span><span class="p">][</span><span class="n">nx</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">fl</span> <span class="ow">in</span> <span class="n">eq</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">dtmp</span><span class="p">[</span><span class="s2">&quot;f.&quot;</span><span class="o">+</span><span class="n">nxl</span><span class="o">+</span><span class="s2">&quot;.&quot;</span><span class="o">+</span><span class="n">fl</span><span class="p">]</span><span class="o">=</span><span class="n">dtmp</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;f.&quot;</span><span class="o">+</span><span class="n">nxl</span><span class="o">+</span><span class="s2">&quot;.&quot;</span><span class="o">+</span><span class="n">fl</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">-</span><span class="nb">float</span><span class="p">(</span><span class="n">eq</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">fl</span><span class="p">])</span>
            <span class="c1"># pass constrained fluxes to rhs</span>
            <span class="k">for</span> <span class="n">fl</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_constr&quot;</span><span class="p">][</span><span class="n">nx</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">fl</span> <span class="ow">in</span> <span class="n">eq</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">dtmp</span><span class="p">[</span><span class="s2">&quot;c.&quot;</span><span class="o">+</span><span class="n">nxl</span><span class="o">+</span><span class="s2">&quot;.&quot;</span><span class="o">+</span><span class="n">fl</span><span class="p">]</span><span class="o">=</span><span class="n">dtmp</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;c.&quot;</span><span class="o">+</span><span class="n">nxl</span><span class="o">+</span><span class="s2">&quot;.&quot;</span><span class="o">+</span><span class="n">fl</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">-</span><span class="nb">float</span><span class="p">(</span><span class="n">eq</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">fl</span><span class="p">])</span>
            <span class="c1"># pass growth fluxes to rhs</span>
            <span class="k">for</span> <span class="n">fl</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_vgrowth&quot;</span><span class="p">][</span><span class="n">nx</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">fl</span> <span class="ow">in</span> <span class="n">eq</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">dtmp</span><span class="p">[</span><span class="s2">&quot;g.&quot;</span><span class="o">+</span><span class="n">nxl</span><span class="o">+</span><span class="s2">&quot;.&quot;</span><span class="o">+</span><span class="n">fl</span><span class="p">]</span><span class="o">=</span><span class="n">dtmp</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;c.&quot;</span><span class="o">+</span><span class="n">nxl</span><span class="o">+</span><span class="s2">&quot;.&quot;</span><span class="o">+</span><span class="n">fl</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">-</span><span class="nb">float</span><span class="p">(</span><span class="n">eq</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">fl</span><span class="p">])</span>

    <span class="c1"># read parallel experiments if any</span>
    <span class="n">proc_kinopt</span><span class="p">(</span><span class="n">ftbl</span><span class="p">,</span> <span class="n">netan</span><span class="p">)</span>
    <span class="k">if</span> <span class="s2">&quot;opt&quot;</span> <span class="ow">in</span> <span class="n">netan</span> <span class="ow">and</span> <span class="s2">&quot;prl_exp&quot;</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;opt&quot;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;opt&quot;</span><span class="p">][</span><span class="s2">&quot;prl_exp&quot;</span><span class="p">]:</span>
        <span class="c1"># parse ftbl files</span>
        <span class="n">fli</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\s*;\s*&quot;</span><span class="p">,</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;opt&quot;</span><span class="p">][</span><span class="s2">&quot;prl_exp&quot;</span><span class="p">])</span>
        <span class="n">dirw</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;abs_path&quot;</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">fli</span><span class="p">:</span>
            <span class="n">fn</span><span class="o">=</span><span class="n">fn</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">fn</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">fp</span><span class="o">=</span><span class="n">ftbl_parse</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirw</span><span class="p">,</span> <span class="n">fn</span><span class="p">))</span>
            <span class="c1"># test the presence of at least one required field</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">f</span> <span class="ow">in</span> <span class="n">fp</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">req_prl</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Not found label input and/or measurements in &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span><span class="o">%</span><span class="n">fn</span><span class="p">)</span>
            <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;exp_names&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fp</span><span class="p">[</span><span class="s2">&quot;base_name&quot;</span><span class="p">])</span>
            <span class="n">proc_label_input</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">netan</span><span class="p">,</span> <span class="n">case_i</span><span class="p">)</span>
            <span class="n">proc_label_meas</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">netan</span><span class="p">)</span>
            <span class="n">proc_peak_meas</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">netan</span><span class="p">)</span>
            <span class="n">proc_mass_meas</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">netan</span><span class="p">)</span>
            <span class="n">proc_kinopt</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">netan</span><span class="p">)</span></div>


<div class="viewcode-block" id="enum_path">
<a class="viewcode-back" href="../progdoc.html#C13_ftbl.enum_path">[docs]</a>
<span class="k">def</span> <span class="nf">enum_path</span><span class="p">(</span><span class="n">starts</span><span class="p">,</span> <span class="n">netw</span><span class="p">,</span> <span class="n">outs</span><span class="p">,</span> <span class="n">visited</span><span class="o">=</span><span class="n">oset</span><span class="p">()):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Enumerate metabilites along to reaction pathways.</span>
<span class="sd">    Algo: start from an input, follow chemical pathways till an output or</span>
<span class="sd">    already visited metabolite. Returns a list of metabolite pathways.</span>
<span class="sd">    Each pathways is an ordered list.&quot;&quot;&quot;</span>
    <span class="n">res</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">visited</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">netw</span><span class="o">.</span><span class="n">keys</span><span class="p">()))):</span>
        <span class="c1"># no more metabolites </span>
        <span class="k">return</span> <span class="n">res</span>
    <span class="k">for</span> <span class="n">start</span> <span class="ow">in</span> <span class="n">starts</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">):</span>
           <span class="k">continue</span>
        <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">start</span> <span class="ow">in</span> <span class="n">outs</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[[</span><span class="n">start</span><span class="p">]]</span>
        <span class="n">paths</span><span class="o">=</span><span class="n">enum_path</span><span class="p">(</span><span class="n">netw</span><span class="p">[</span><span class="n">start</span><span class="p">]</span><span class="o">-</span><span class="n">visited</span><span class="p">,</span> <span class="n">netw</span><span class="p">,</span> <span class="n">outs</span><span class="p">,</span> <span class="n">visited</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">paths</span><span class="p">):</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">start</span><span class="p">]</span><span class="o">+</span><span class="n">paths</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">paths</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">paths</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">start</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="cumo_path">
<a class="viewcode-back" href="../progdoc.html#C13_ftbl.cumo_path">[docs]</a>
<span class="k">def</span> <span class="nf">cumo_path</span><span class="p">(</span><span class="n">starts</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">visited</span><span class="o">=</span><span class="n">oset</span><span class="p">()):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Enumerate cumomers along reaction pathways.</span>
<span class="sd">    Algo: start from an input, follow chemical pathways till no more</span>
<span class="sd">    neighbours or till only visited metabolite rest in network.</span>
<span class="sd">    Return a list of cumomer pathways.</span>
<span class="sd">    Each pathways is an ordered list.&quot;&quot;&quot;</span>
    <span class="c1">#if [s for s in starts if s.find(&#39;.&#39;) &gt;= 0]:</span>
    <span class="c1">#    aff(&#39;s&#39;, starts)</span>
    <span class="n">res</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">visited</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)):</span>
        <span class="c1"># no more cumomers</span>
        <span class="k">return</span> <span class="n">res</span>
    <span class="k">for</span> <span class="n">start</span> <span class="ow">in</span> <span class="n">starts</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="ow">in</span> <span class="n">visited</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">start</span> <span class="ow">in</span> <span class="n">A</span><span class="p">):</span>
           <span class="k">continue</span>
        <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
        <span class="c1"># next_starts are cumos influenced by start</span>
        <span class="n">next_starts</span><span class="o">=</span><span class="n">oset</span><span class="p">(</span><span class="n">cumo</span> <span class="k">for</span> <span class="n">cumo</span> <span class="ow">in</span> <span class="n">A</span> <span class="k">if</span> <span class="n">start</span> <span class="ow">in</span> <span class="n">A</span><span class="p">[</span><span class="n">cumo</span><span class="p">])</span>
<span class="c1">##        aff(&#39;next to &#39;+start, next_starts)</span>
        <span class="n">next_starts</span><span class="o">-=</span><span class="n">visited</span>
        <span class="k">if</span> <span class="n">next_starts</span><span class="p">:</span>
            <span class="n">paths</span><span class="o">=</span><span class="n">cumo_path</span><span class="p">(</span><span class="n">next_starts</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">visited</span><span class="p">)</span>
<span class="c1">##            aff(&#39;paths for &#39;+start, paths)</span>
<span class="c1">##            aff(&#39;visited&#39;, visited)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">path</span><span class="o">=</span><span class="p">[]</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">start</span><span class="p">])</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">paths</span><span class="p">):</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">start</span><span class="p">]</span><span class="o">+</span><span class="n">paths</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">paths</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">paths</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">start</span><span class="p">])</span>
<span class="c1">##    aff(&#39;r&#39;, res)</span>
    <span class="k">return</span> <span class="n">res</span></div>

    
<div class="viewcode-block" id="src_ind">
<a class="viewcode-back" href="../progdoc.html#C13_ftbl.src_ind">[docs]</a>
<span class="k">def</span> <span class="nf">src_ind</span><span class="p">(</span><span class="n">substrate</span><span class="p">,</span> <span class="n">product</span><span class="p">,</span> <span class="n">iprod</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For a given substrate and product carbon strings (e.g. &quot;abc&quot;, &quot;ab&quot;)</span>
<span class="sd">    calculate substrate index corresponding to product index.</span>
<span class="sd">    Return None if no source found.</span>
<span class="sd">    Return 0 if iprod==0 and intersection of product and substrate strings</span>
<span class="sd">    is not empty&quot;&quot;&quot;</span>
    <span class="n">movbit</span><span class="o">=</span><span class="mi">1</span>
    <span class="n">isubstr</span><span class="o">=</span><span class="mi">0</span>
    <span class="n">substrate</span><span class="o">=</span><span class="n">substrate</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">product</span><span class="o">=</span><span class="n">product</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">nb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">product</span><span class="p">)):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">movbit</span> <span class="o">&amp;</span> <span class="n">iprod</span><span class="p">):</span>
            <span class="c1"># algo: if the current bit is set in product search for its origin</span>
            <span class="c1"># and set the corresponding bit in substrate</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">isubstr</span><span class="o">|=</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">substrate</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">product</span><span class="p">[</span><span class="n">nb</span><span class="p">])</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="n">movbit</span><span class="o">&lt;&lt;=</span><span class="mi">1</span>
    <span class="k">return</span> <span class="n">isubstr</span> <span class="k">if</span> <span class="p">(</span><span class="n">isubstr</span> <span class="ow">or</span>
        <span class="p">(</span><span class="n">iprod</span><span class="o">==</span><span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="n">oset</span><span class="p">(</span><span class="n">product</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">oset</span><span class="p">(</span><span class="n">substrate</span><span class="p">))))</span> <span class="k">else</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="labprods">
<a class="viewcode-back" href="../progdoc.html#C13_ftbl.labprods">[docs]</a>
<span class="k">def</span> <span class="nf">labprods</span><span class="p">(</span><span class="n">prods</span><span class="p">,</span> <span class="n">metab</span><span class="p">,</span> <span class="n">isostr</span><span class="p">,</span> <span class="n">strs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;labprods(prods, metab, isostr, strs)</span>
<span class="sd">    Return a set of tuples (vmetab,visostr) which receive at least</span>
<span class="sd">    one labeled carbon from (metab, isostr)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># run through product part of reaction to get</span>
    <span class="c1"># metabs containing labeled letter from isostr</span>
    <span class="c1">#print &quot;p=&quot;, prods, &quot;m=&quot;, metab, &quot;i=&quot;, isostr, &quot;s=&quot;, strs;##</span>
    <span class="n">res</span><span class="o">=</span><span class="n">oset</span><span class="p">()</span>
    <span class="c1"># get labeled letters</span>
    <span class="n">lets</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">carb</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">isostr</span><span class="p">)</span> <span class="k">if</span> <span class="n">carb</span><span class="o">==</span><span class="s2">&quot;1&quot;</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">strs</span><span class="p">)</span>
    <span class="c1">#print &quot;ls=&quot;, lets;##</span>
    <span class="c1"># find labeled letters in reaction products and set</span>
    <span class="c1"># them to &quot;1&quot;, while others to &quot;0&quot;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">vm</span><span class="p">,</span><span class="n">vs</span><span class="p">)</span> <span class="ow">in</span> <span class="n">prods</span><span class="p">:</span>
        <span class="n">rs</span><span class="o">=</span><span class="s2">&quot;&quot;</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">vs</span><span class="p">:</span>
            <span class="n">rs</span><span class="o">=</span><span class="n">rs</span><span class="o">+</span><span class="p">(</span><span class="s2">&quot;1&quot;</span> <span class="k">if</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">lets</span> <span class="k">else</span> <span class="s2">&quot;0&quot;</span><span class="p">)</span>
            <span class="c1">#print &quot;r=&quot;,r, &quot;rs=&quot;,rs</span>
        <span class="k">if</span> <span class="n">rs</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;1&quot;</span><span class="p">)</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">vm</span><span class="p">,</span><span class="n">rs</span><span class="p">))</span>
            <span class="c1">#print &quot;append=&quot;, vm, rs;##</span>
    <span class="c1">#print &quot;res=&quot;, res;##</span>
    <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="allprods">
<a class="viewcode-back" href="../progdoc.html#C13_ftbl.allprods">[docs]</a>
<span class="k">def</span> <span class="nf">allprods</span><span class="p">(</span><span class="n">srcs</span><span class="p">,</span> <span class="n">prods</span><span class="p">,</span> <span class="n">isos</span><span class="p">,</span> <span class="n">metab</span><span class="p">,</span> <span class="n">isostr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;allprods(srcs, prods, isos, metab, isostr)</span>
<span class="sd">    Return a set of tuples (cmetab, cisostr, vmetab, visostr)</span>
<span class="sd">    where cmetab and cisostr describe a contex metabolite</span>
<span class="sd">    which combined with metab+isostr produced vmetab+visostr.</span>
<span class="sd">    if metab is alone on its reaction part cmetab and cisostr are set to</span>
<span class="sd">    an empty string (&quot;&quot;).</span>
<span class="sd">    The set covers all combination of</span>
<span class="sd">    metab+isostr and its co-substrates which</span>
<span class="sd">    produce isotopes having at least one labeled carbon from</span>
<span class="sd">    metab+isostr.</span>
<span class="sd">    Co-substrate isotops are</span>
<span class="sd">    in a dictionary isos[cmetab]=list(cisotopes).&quot;&quot;&quot;</span>
    <span class="c1"># run through all combinations of srcs isotopes</span>
    <span class="c1"># to get all products</span>
    <span class="c1"># |isostr|*|iso2|[+|iso1|*|isostr| if metab is in both position]</span>
    <span class="c1"># If there is only one src than m2=&quot;&quot;</span>
    <span class="c1">#print &quot;allprods: metab=&quot;, metab, &quot;isostr=&quot;, isostr</span>
    <span class="c1">#print &quot;s=&quot;, srcs, &quot;p=&quot;, prods, &quot;i=&quot;, isos;##</span>
    <span class="c1"># find metabolite position(s) in the reaction</span>
    <span class="n">mpos</span><span class="o">=</span><span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,(</span><span class="n">m</span><span class="p">,</span><span class="n">s</span><span class="p">))</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">srcs</span><span class="p">)</span> <span class="k">if</span> <span class="n">m</span><span class="o">==</span><span class="n">metab</span><span class="p">]</span>
    
    <span class="c1"># all source isotop couples (im,ic)</span>
    <span class="n">icouples</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">if</span> <span class="n">metab</span><span class="o">==</span><span class="n">m1</span><span class="p">:</span>
        <span class="n">icouples</span><span class="o">=</span><span class="p">[(</span><span class="n">isostr</span><span class="p">,</span><span class="n">is2</span><span class="p">)</span> <span class="k">for</span> <span class="n">is2</span> <span class="ow">in</span> <span class="n">isos</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">m2</span><span class="p">,</span><span class="n">oset</span><span class="p">((</span><span class="s2">&quot;&quot;</span><span class="p">,)))]</span>
    <span class="k">if</span> <span class="n">metab</span><span class="o">==</span><span class="n">m2</span><span class="p">:</span>
        <span class="n">icouples</span><span class="o">.</span><span class="n">extend</span><span class="p">((</span><span class="n">is1</span><span class="p">,</span><span class="n">isostr</span><span class="p">)</span> <span class="k">for</span> <span class="n">is1</span> <span class="ow">in</span> <span class="n">isos</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span><span class="n">oset</span><span class="p">((</span><span class="s2">&quot;&quot;</span><span class="p">,))))</span>
    <span class="c1">#print &quot;icpls=&quot;, list(icouples);##</span>
    <span class="c1">#sys.exit(1);##</span>
    <span class="c1"># labeled source letters</span>
    <span class="c1">#print &quot;s1=&quot;, s1, &quot;s2=&quot;, s2</span>
    <span class="n">lets</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">l</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">l</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span> <span class="k">if</span> <span class="n">is1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;1&quot;</span><span class="p">)</span><span class="o">+</span>
        <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">l</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">l</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span> <span class="k">if</span> <span class="n">is2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;1&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">is1</span><span class="p">,</span><span class="n">is2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">icouples</span><span class="p">]</span>
    <span class="c1">#print &quot;lets=&quot;, lets;##</span>
    <span class="c1"># form all products</span>
    <span class="n">res</span><span class="o">=</span><span class="n">oset</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">inm</span> <span class="ow">in</span> <span class="n">mpos</span><span class="p">:</span>
        <span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">s</span><span class="p">)</span><span class="o">=</span><span class="n">srcs</span><span class="p">[</span><span class="n">inm</span><span class="p">]</span>
        <span class="n">mlab</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">l</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">l</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">if</span> <span class="n">isostr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;1&quot;</span><span class="p">)</span>
        <span class="c1"># co-substrate (if any)</span>
        <span class="p">(</span><span class="n">cm</span><span class="p">,</span><span class="n">cs</span><span class="p">)</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">srcs</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span> <span class="k">else</span> <span class="n">srcs</span><span class="p">[(</span><span class="n">inm</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="mi">2</span><span class="p">]</span>
        <span class="c1"># run through isotops of co-substrate</span>
        <span class="k">for</span> <span class="n">coiso</span> <span class="ow">in</span> <span class="n">isos</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">cm</span><span class="p">,</span><span class="n">oset</span><span class="p">((</span><span class="s2">&quot;&quot;</span><span class="p">,))):</span>
            <span class="n">lab</span><span class="o">=</span><span class="n">mlab</span><span class="o">+</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">l</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">l</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cs</span><span class="p">)</span> <span class="k">if</span> <span class="n">coiso</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;1&quot;</span><span class="p">)</span>
            <span class="c1"># form product isotops</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">pm</span><span class="p">,</span><span class="n">ps</span><span class="p">)</span> <span class="ow">in</span> <span class="n">prods</span><span class="p">:</span>
                <span class="n">ip</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="s2">&quot;1&quot;</span> <span class="k">if</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">lab</span> <span class="k">else</span> <span class="s2">&quot;0&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">ps</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">oset</span><span class="p">(</span><span class="n">ps</span><span class="p">)</span><span class="o">&amp;</span><span class="n">oset</span><span class="p">(</span><span class="n">mlab</span><span class="p">):</span>
                    <span class="c1"># get only products labeled by metab+isostr</span>
                    <span class="n">res</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">cm</span><span class="p">,</span><span class="n">coiso</span><span class="p">,</span> <span class="n">pm</span><span class="p">,</span> <span class="n">ip</span><span class="p">))</span>
    <span class="c1">#print &quot;res=&quot;, res</span>
    <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="prod">
<a class="viewcode-back" href="../progdoc.html#C13_ftbl.prod">[docs]</a>
<span class="k">def</span> <span class="nf">prod</span><span class="p">(</span><span class="n">metab</span><span class="p">,</span> <span class="n">iso</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">cmetab</span><span class="p">,</span> <span class="n">ciso</span><span class="p">,</span> <span class="n">cs</span><span class="p">,</span> <span class="n">prods</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;prod(metab, iso, s, cmetab, ciso, cs, prods)-&gt;oset()</span>
<span class="sd">    get isotops from labeled substrates&quot;&quot;&quot;</span>
    <span class="c1">#print &quot;prod: m=&quot;, metab, &quot;s=&quot;, s, &quot;i=&quot;, iso, &quot;cm=&quot;, cmetab, &quot;cs=&quot;, cs, &quot;ci=&quot;, ciso</span>
    <span class="n">res</span><span class="o">=</span><span class="n">oset</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">cs</span> <span class="ow">and</span> <span class="n">ciso</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">res</span>
    <span class="n">lab</span><span class="o">=</span><span class="s2">&quot;&quot;</span>
    <span class="n">n</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="ow">in</span> <span class="n">iternumbit</span><span class="p">(</span><span class="n">iso</span><span class="p">):</span>
        <span class="n">lab</span><span class="o">=</span><span class="n">lab</span><span class="o">+</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">b</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="n">n</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">cs</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="ow">in</span> <span class="n">iternumbit</span><span class="p">(</span><span class="n">ciso</span><span class="p">):</span>
        <span class="n">lab</span><span class="o">=</span><span class="n">lab</span><span class="o">+</span><span class="p">(</span><span class="n">cs</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">b</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">pm</span><span class="p">,</span><span class="n">ps</span><span class="p">)</span> <span class="ow">in</span> <span class="n">prods</span><span class="p">:</span>
        <span class="n">ip</span><span class="o">=</span><span class="nb">sum</span><span class="p">((</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">i</span> <span class="k">if</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">lab</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">l</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ps</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">res</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">pm</span><span class="p">,</span> <span class="n">ip</span><span class="p">))</span>
    <span class="c1">#print &quot;res=&quot;, res</span>
    <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="frag_prod">
<a class="viewcode-back" href="../progdoc.html#C13_ftbl.frag_prod">[docs]</a>
<span class="k">def</span> <span class="nf">frag_prod</span><span class="p">(</span><span class="n">metab</span><span class="p">,</span> <span class="n">frag</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">cmetab</span><span class="p">,</span> <span class="n">cfrag</span><span class="p">,</span> <span class="n">cs</span><span class="p">,</span> <span class="n">prods</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;frag_prod(metab, frag, s, cmetab, cfrag, cs, prods)</span>
<span class="sd">    Get fragments from labeled substrates&quot;&quot;&quot;</span>
    <span class="c1">#print &quot;frag_prod: m=&quot;, metab, &quot;s=&quot;, s, &quot;f=&quot;, frag, &quot;cm=&quot;, cmetab, &quot;cs=&quot;, cs, &quot;cf=&quot;, cfrag</span>
    <span class="n">res</span><span class="o">=</span><span class="n">oset</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">cs</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">cfrag</span><span class="p">:</span>
        <span class="c1"># no fragment for this metabolite is yet produced</span>
        <span class="k">return</span> <span class="n">res</span>
    <span class="n">lab</span><span class="o">=</span><span class="s2">&quot;&quot;</span>
    <span class="n">lab</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">frag</span><span class="p">)</span> <span class="k">if</span> <span class="n">c</span><span class="o">!=</span><span class="s2">&quot;0&quot;</span><span class="p">)</span><span class="o">+</span>
        <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cfrag</span><span class="p">)</span> <span class="k">if</span> <span class="n">c</span><span class="o">!=</span><span class="s2">&quot;0&quot;</span><span class="p">))</span>
    <span class="n">flab</span><span class="o">=</span><span class="n">frag</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">+</span><span class="n">cfrag</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">pm</span><span class="p">,</span><span class="n">ps</span><span class="p">)</span> <span class="ow">in</span> <span class="n">prods</span><span class="p">:</span>
        <span class="n">fp</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="n">flab</span><span class="p">[</span><span class="n">lab</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span> <span class="k">if</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">lab</span> <span class="k">else</span> <span class="s2">&quot;0&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">l</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ps</span><span class="p">))</span>
        <span class="n">res</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">pm</span><span class="p">,</span> <span class="n">fp</span><span class="p">))</span>
    <span class="c1">#print &quot;res=&quot;, res</span>
    <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="cumo_iw">
<a class="viewcode-back" href="../progdoc.html#C13_ftbl.cumo_iw">[docs]</a>
<span class="k">def</span> <span class="nf">cumo_iw</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">nlen</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;iterator for a given cumomer weight w in the carbon length nlen&quot;&quot;&quot;</span>
    <span class="c1">#print (&quot;cumo_iw: w=%d,nlen=%d\n&quot; % (w,nlen));##</span>
    <span class="k">if</span> <span class="n">w</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">w</span> <span class="o">&gt;</span> <span class="n">nlen</span><span class="p">:</span>
       <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;CumoWeightOutOfRange&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">nlen</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
       <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;CumoLengthNegative&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">w</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">movbit</span><span class="o">=</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nlen</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">movbit</span>
            <span class="n">movbit</span><span class="o">&lt;&lt;=</span><span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">movbit</span><span class="o">=</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">w</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nlen</span><span class="o">-</span><span class="n">w</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">subi</span> <span class="ow">in</span> <span class="n">cumo_iw</span><span class="p">(</span><span class="n">w</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">w</span><span class="o">+</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">movbit</span><span class="o">+</span><span class="n">subi</span>
            <span class="n">movbit</span><span class="o">&lt;&lt;=</span><span class="mi">1</span></div>


<div class="viewcode-block" id="iso2cumo">
<a class="viewcode-back" href="../progdoc.html#C13_ftbl.iso2cumo">[docs]</a>
<span class="k">def</span> <span class="nf">iso2cumo</span><span class="p">(</span><span class="n">netan</span><span class="p">,</span> <span class="n">strin</span><span class="p">,</span> <span class="n">in_cumo</span><span class="p">,</span> <span class="n">icumo</span><span class="p">,</span> <span class="n">in_metab</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;calculate cumomer fraction from isotopomer ones&quot;&quot;&quot;</span>
    <span class="c1">#return sum(iso_dic.get(iiso,0.)</span>
    <span class="c1">#    for iiso in icumo2iiso(icumo, Clen))</span>
    <span class="n">w</span><span class="o">=</span><span class="n">sumbit</span><span class="p">(</span><span class="n">icumo</span><span class="p">)</span>
    <span class="n">n</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;iso_input&quot;</span><span class="p">])</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="n">strin</span><span class="p">])</span> <span class="o">!=</span> <span class="n">n</span><span class="p">:</span>
        <span class="c1"># init cumo_input list of dicts</span>
        <span class="n">netan</span><span class="p">[</span><span class="n">strin</span><span class="p">]</span><span class="o">=</span><span class="p">[{}</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">ili</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;iso_input&quot;</span><span class="p">])):</span>
        <span class="n">d</span><span class="o">=</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;iso_input&quot;</span><span class="p">][</span><span class="n">ili</span><span class="p">][</span><span class="n">in_metab</span><span class="p">]</span>
        <span class="n">netan</span><span class="p">[</span><span class="n">strin</span><span class="p">][</span><span class="n">ili</span><span class="p">][</span><span class="n">in_cumo</span><span class="p">]</span><span class="o">=</span><span class="nb">sum</span><span class="p">(</span><span class="n">val</span> <span class="k">for</span> <span class="p">(</span><span class="n">iso</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">sumbit</span><span class="p">(</span><span class="n">iso</span><span class="o">&amp;</span><span class="n">icumo</span><span class="p">)</span> <span class="o">==</span> <span class="n">w</span><span class="p">)</span></div>


<div class="viewcode-block" id="iso2emu">
<a class="viewcode-back" href="../progdoc.html#C13_ftbl.iso2emu">[docs]</a>
<span class="k">def</span> <span class="nf">iso2emu</span><span class="p">(</span><span class="n">netan</span><span class="p">,</span> <span class="n">inmetab</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">mpi</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;calculate emu fraction from isotopomer dict iso_input.</span>
<span class="sd">    The fraction corresponds to a fragment defined by a mask and the mass component mpi.</span>
<span class="sd">    Return a real number in [0; 1] interval.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#return(sum([val for (frag, val) in iso_input[inmetab].iteritems() if sumbit(frag&amp;mask) == mpi]))</span>
    <span class="n">n</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;iso_input&quot;</span><span class="p">])</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;emu_input&quot;</span><span class="p">])</span> <span class="o">!=</span> <span class="n">n</span><span class="p">:</span>
        <span class="c1"># init emu_input list of dicts</span>
        <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;emu_input&quot;</span><span class="p">]</span><span class="o">=</span><span class="p">[{}</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">ili</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">d</span><span class="o">=</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;iso_input&quot;</span><span class="p">][</span><span class="n">ili</span><span class="p">][</span><span class="n">inmetab</span><span class="p">]</span>
        <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;emu_input&quot;</span><span class="p">][</span><span class="n">ili</span><span class="p">][</span><span class="n">e</span><span class="p">]</span><span class="o">=</span><span class="nb">sum</span><span class="p">([</span><span class="n">val</span> <span class="k">for</span> <span class="p">(</span><span class="n">frag</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">sumbit</span><span class="p">(</span><span class="n">frag</span><span class="o">&amp;</span><span class="n">mask</span><span class="p">)</span> <span class="o">==</span> <span class="n">mpi</span><span class="p">])</span></div>


<div class="viewcode-block" id="formula2dict">
<a class="viewcode-back" href="../progdoc.html#C13_ftbl.formula2dict">[docs]</a>
<span class="k">def</span> <span class="nf">formula2dict</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">pterm</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;([+-])&#39;</span><span class="p">),</span> <span class="n">pflux</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(?P&lt;coef&gt;\d+\.?\d*|^)?\s*\*?\s*(?P&lt;var&gt;[a-zA-Z_[\]()][\w\. -\[\]]*)\W*&#39;</span><span class="p">)):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;parse a linear combination sum([+|-][a_i][*]f_i) where a_i is a </span>
<span class="sd">    positive number and f_i is a string starting by non-digit and not white</span>
<span class="sd">    character (# is allowed). Output is a dict f_i:[+-]a_i&quot;&quot;&quot;</span>
    <span class="n">res</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span>
    <span class="n">sign</span><span class="o">=</span><span class="mi">1</span>
    <span class="n">l</span><span class="o">=</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">pterm</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">f</span><span class="p">)))</span>
    <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">next_sign</span><span class="o">=</span><span class="nb">next</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
            <span class="n">next_sign</span><span class="o">=-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">next_sign</span> <span class="o">==</span> <span class="s2">&quot;-&quot;</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="n">next_sign</span><span class="o">=</span><span class="mi">0</span>
            <span class="k">pass</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">term</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">continue</span>
        <span class="n">m</span><span class="o">=</span><span class="n">pflux</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">m</span><span class="p">:</span>
            <span class="n">coef</span><span class="o">=</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s2">&quot;coef&quot;</span><span class="p">)</span>
            <span class="n">coef</span><span class="o">=</span><span class="mf">1.</span> <span class="k">if</span> <span class="n">coef</span><span class="o">==</span><span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">coef</span><span class="p">)</span> <span class="k">else</span> <span class="nb">float</span><span class="p">(</span><span class="n">coef</span><span class="p">)</span>
            <span class="n">var</span><span class="o">=</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s2">&quot;var&quot;</span><span class="p">)</span>
            <span class="n">sign</span><span class="o">=-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">sign</span><span class="o">==-</span><span class="mi">1</span> <span class="k">else</span> <span class="mi">1</span>
            <span class="n">res</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">=</span><span class="n">res</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)</span><span class="o">+</span><span class="n">sign</span><span class="o">*</span><span class="n">coef</span>
            <span class="n">sign</span><span class="o">=</span><span class="n">next_sign</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Term &#39;&quot;</span><span class="o">+</span><span class="n">term</span><span class="o">+</span><span class="s2">&quot;&#39; in formula &#39;&quot;</span><span class="o">+</span><span class="n">f</span><span class="o">+</span><span class="s2">&quot;&#39; cannot be parsed.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="mecoparse">
<a class="viewcode-back" href="../progdoc.html#C13_ftbl.mecoparse">[docs]</a>
<span class="k">def</span> <span class="nf">mecoparse</span><span class="p">(</span><span class="n">terms</span><span class="p">,</span> <span class="n">pmeco</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\s*((?P&lt;coef&gt;\d+\.?\d*|^)\s*\*\s*)?(?P&lt;metab&gt;[^*+ ]*)\s*$&#39;</span><span class="p">)):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Parse a string term from a list (or a sing string) of chemical equation entries.</span>
<span class="sd">    The general form of each term is &#39;coef*metab&#39;.</span>
<span class="sd">    coef (if present) must be separated from metab by &#39;*&#39; and be convertible to float.</span>
<span class="sd">    metab can start with a number (e.g. &#39;6PG&#39;) so the presence of &#39;*&#39; is mandatory to</span>
<span class="sd">    separate coef from metab. If coef is absent, it is considered to be 1. </span>
<span class="sd">    Return a list of (or a single for str) tuples (metab (str), coef (real)).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">single</span><span class="o">=</span><span class="n">isstr</span><span class="p">(</span><span class="n">terms</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">single</span><span class="p">:</span>
        <span class="n">terms</span><span class="o">=</span><span class="p">[</span><span class="n">terms</span><span class="p">]</span>
    <span class="n">res</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">terms</span><span class="p">:</span>
        <span class="n">m</span><span class="o">=</span><span class="n">pmeco</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">m</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Wrong format for term &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span><span class="o">%</span><span class="n">term</span><span class="p">)</span>
        <span class="n">coef</span><span class="o">=</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s2">&quot;coef&quot;</span><span class="p">)</span>
        <span class="n">coef</span><span class="o">=</span><span class="mf">1.</span> <span class="k">if</span> <span class="n">coef</span><span class="o">==</span><span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">coef</span><span class="p">)</span> <span class="k">else</span> <span class="nb">float</span><span class="p">(</span><span class="n">coef</span><span class="p">)</span>
        <span class="n">metab</span><span class="o">=</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s2">&quot;metab&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">metab</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Metabolite cannot be empty in term &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span><span class="o">%</span><span class="n">term</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">metab</span><span class="p">,</span> <span class="n">coef</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">single</span><span class="p">:</span>
        <span class="n">res</span><span class="o">=</span><span class="n">res</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="label_meas2matrix_vec_dev">
<a class="viewcode-back" href="../progdoc.html#C13_ftbl.label_meas2matrix_vec_dev">[docs]</a>
<span class="k">def</span> <span class="nf">label_meas2matrix_vec_dev</span><span class="p">(</span><span class="n">netan</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;use netan[&quot;label_meas&quot;] list to construct a corresponding list of</span>
<span class="sd">    measure matrix matx_lab</span>
<span class="sd">    such that scale_diag*metab_pool_diag*matx_lab*(cumos_vector,1) corresponds to label_measurements_vector.</span>
<span class="sd">    matx_lab is defined as</span>
<span class="sd">    list of dict{&quot;scale&quot;:scale_name, &quot;coefs&quot;:dict{icumo:coef}, &quot;metab&quot;: metabolite, &quot;poolid&quot;: metabolite pool id if pooled}</span>
<span class="sd">    where coef is a contribution of cumo in linear combination for given measure.</span>
<span class="sd">    scale_name is of the form &quot;metabs;group&quot;. Group number is to group</span>
<span class="sd">    measurements of the same measurement set.</span>
<span class="sd">    poolid is the index of pool list in pooled where each list regroups</span>
<span class="sd">    0-based indexes rows in returned matrix for what has to be pooled together.</span>
<span class="sd">    vec is a list of measurements (values in .ftbl)</span>
<span class="sd">    dev is a list of deviations.</span>
<span class="sd">    Elements in matx_lab, vec and dev are ordered in the same way.</span>
<span class="sd">    The returned result is a dict (mat,vec,dev)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># lab[metab][group]=list of {id:txt, val:x, dev:y, bcumos:list of #bcumo}</span>
    <span class="c1"># bcumo is like #1xx01 (0,1 and x are allowed)</span>
    <span class="c1"># their sum have to be transformed in cumomer linear combination</span>
    <span class="n">nexp</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;iso_input&quot;</span><span class="p">])</span>
    <span class="n">mli</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nexp</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">ili</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nexp</span><span class="p">):</span>
        <span class="n">mat</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">vec</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">dev</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">pooled</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">ids</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">imrow</span><span class="o">=-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">metabs</span><span class="p">,</span><span class="n">groups</span><span class="p">)</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;label_meas&quot;</span><span class="p">][</span><span class="n">ili</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">group</span><span class="p">,</span><span class="n">rows</span><span class="p">)</span> <span class="ow">in</span> <span class="n">groups</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">rows</span><span class="p">:</span>
                    <span class="n">vec</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;val&quot;</span><span class="p">])</span>
                    <span class="n">dev</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;dev&quot;</span><span class="p">])</span>
                    <span class="n">ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">])</span>
                    <span class="n">res</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">cumostr</span> <span class="ow">in</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;bcumos&quot;</span><span class="p">]:</span>
                        <span class="n">decomp</span><span class="o">=</span><span class="n">bcumo_decomp</span><span class="p">(</span><span class="n">cumostr</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">icumo</span> <span class="ow">in</span> <span class="n">decomp</span><span class="p">[</span><span class="s2">&quot;+&quot;</span><span class="p">]:</span>
                            <span class="n">res</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">icumo</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
                            <span class="n">res</span><span class="p">[</span><span class="n">icumo</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
                        <span class="k">for</span> <span class="n">icumo</span> <span class="ow">in</span> <span class="n">decomp</span><span class="p">[</span><span class="s2">&quot;-&quot;</span><span class="p">]:</span>
                            <span class="n">res</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">icumo</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
                            <span class="n">res</span><span class="p">[</span><span class="n">icumo</span><span class="p">]</span><span class="o">-=</span><span class="mi">1</span>
                    <span class="n">emuco</span><span class="o">=</span><span class="nb">dict</span><span class="p">((</span><span class="nb">str</span><span class="p">(</span><span class="n">ic</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;+&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">sumbit</span><span class="p">(</span><span class="n">ic</span><span class="p">)),</span> <span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">ic</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="n">res</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;pooled&quot;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="c1"># init index list</span>
                        <span class="n">pooled</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]])</span>
                    <span class="k">for</span> <span class="n">metab</span> <span class="ow">in</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;pooled&quot;</span><span class="p">]:</span>
                        <span class="n">imrow</span><span class="o">+=</span><span class="mi">1</span>
                        <span class="n">mat</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">],</span> <span class="s2">&quot;scale&quot;</span><span class="p">:</span> <span class="n">metabs</span><span class="o">+</span><span class="s2">&quot;;&quot;</span><span class="o">+</span><span class="n">group</span><span class="p">,</span> <span class="s2">&quot;coefs&quot;</span><span class="p">:</span><span class="n">res</span><span class="p">,</span>
                            <span class="s2">&quot;bcumos&quot;</span><span class="p">:</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;bcumos&quot;</span><span class="p">],</span> <span class="s2">&quot;metab&quot;</span><span class="p">:</span> <span class="n">metab</span><span class="p">,</span> <span class="s2">&quot;emuco&quot;</span><span class="p">:</span> <span class="n">emuco</span><span class="p">})</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;pooled&quot;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="c1"># indeed something is pooled</span>
                            <span class="n">pooled</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">imrow</span><span class="p">)</span>
        <span class="n">mli</span><span class="p">[</span><span class="n">ili</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;ids&quot;</span><span class="p">:</span> <span class="n">ids</span><span class="p">,</span> <span class="s2">&quot;mat&quot;</span><span class="p">:</span> <span class="n">mat</span><span class="p">,</span> <span class="s2">&quot;vec&quot;</span><span class="p">:</span> <span class="n">vec</span><span class="p">,</span> <span class="s2">&quot;dev&quot;</span><span class="p">:</span> <span class="n">dev</span><span class="p">,</span> <span class="s2">&quot;pooled&quot;</span><span class="p">:</span> <span class="n">pooled</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">mli</span></div>


<div class="viewcode-block" id="mass_meas2matrix_vec_dev">
<a class="viewcode-back" href="../progdoc.html#C13_ftbl.mass_meas2matrix_vec_dev">[docs]</a>
<span class="k">def</span> <span class="nf">mass_meas2matrix_vec_dev</span><span class="p">(</span><span class="n">netan</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;use netan[&quot;mass_meas&quot;] list to construct a corresponding list of</span>
<span class="sd">    measure matrix matx_mass</span>
<span class="sd">    such that scale_diag*matx_mass*cumos_vector corresponds to mass_measures_vector.</span>
<span class="sd">    matx_mass is defined as matx_lab in label_meas2matrix_vec_dev()</span>
<span class="sd">    Elements in matx_mass, vec and dev are ordered in the same way.</span>
<span class="sd">    scale name is defined as &quot;metab;fragment_mask&quot;</span>
<span class="sd">    The returned result is a dict (mat,vec,dev)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">emu</span><span class="o">=</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;emu&quot;</span><span class="p">]</span>
    <span class="c1"># mass[metab][frag_mask][weight]={val:x, dev:y}</span>
    <span class="c1"># weight has to be transformed in cumomer linear combination</span>
    <span class="n">nexp</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;iso_input&quot;</span><span class="p">])</span>
    <span class="n">mli</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nexp</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">ili</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nexp</span><span class="p">):</span>
        <span class="n">mat</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">vec</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">dev</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">pooled</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">ids</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">imrow</span><span class="o">=-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">m_id</span><span class="p">,</span><span class="n">frag_masks</span><span class="p">)</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;mass_meas&quot;</span><span class="p">][</span><span class="n">ili</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1">#print &quot;mass matx calc for &quot;, metab;##</span>
            <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">metabs</span><span class="p">,</span> <span class="n">frag</span><span class="p">,</span> <span class="n">m_irow</span><span class="p">)</span><span class="o">=</span><span class="n">m_id</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">fmask</span><span class="p">,</span><span class="n">weights</span><span class="p">)</span> <span class="ow">in</span> <span class="n">frag_masks</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">onepos</span><span class="o">=</span><span class="p">[</span><span class="n">b_no</span> <span class="k">for</span> <span class="p">(</span><span class="n">b_no</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="ow">in</span> <span class="n">iternumbit</span><span class="p">(</span><span class="n">fmask</span><span class="p">)</span> <span class="k">if</span> <span class="n">b</span><span class="p">]</span>
                <span class="n">nmask</span><span class="o">=</span><span class="n">sumbit</span><span class="p">(</span><span class="n">fmask</span><span class="p">)</span>
    <span class="c1">#            aff(&quot;weights for met,fmask &quot;+&quot;, &quot;.join((metab,strbit(fmask))), weights);##</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">weight</span><span class="p">,</span><span class="n">row</span><span class="p">)</span> <span class="ow">in</span> <span class="n">weights</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">vec</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;val&quot;</span><span class="p">])</span>
                    <span class="n">dev</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;dev&quot;</span><span class="p">])</span>
                    <span class="n">ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">])</span>
                    <span class="n">metabl</span><span class="o">=</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;pooled&quot;</span><span class="p">]</span>
                    <span class="n">metab0</span><span class="o">=</span><span class="n">metabl</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">n</span><span class="o">=</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;Clen&quot;</span><span class="p">][</span><span class="n">metab0</span><span class="p">]</span>
                    <span class="n">str0</span><span class="o">=</span><span class="s2">&quot;0&quot;</span><span class="o">*</span><span class="n">n</span>
                    <span class="n">strx</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="o">*</span><span class="n">n</span>
                    <span class="n">str1</span><span class="o">=</span><span class="s2">&quot;1&quot;</span><span class="o">*</span><span class="n">n</span>
                    <span class="n">fmask0x</span><span class="o">=</span><span class="n">setcharbit</span><span class="p">(</span><span class="n">strx</span><span class="p">,</span><span class="s2">&quot;0&quot;</span><span class="p">,</span><span class="n">fmask</span><span class="p">)</span>
                    <span class="n">fmask01</span><span class="o">=</span><span class="n">setcharbit</span><span class="p">(</span><span class="n">str0</span><span class="p">,</span><span class="s2">&quot;1&quot;</span><span class="p">,</span><span class="n">fmask</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">emu</span><span class="p">:</span>
                        <span class="c1"># for a given weight construct bcumo sum: #x10x+#x01x+...</span>
                        <span class="n">bcumos</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;#&quot;</span><span class="o">+</span><span class="n">setcharbit</span><span class="p">(</span><span class="n">fmask0x</span><span class="p">,</span><span class="s2">&quot;1&quot;</span><span class="p">,</span><span class="n">expandbit</span><span class="p">(</span><span class="n">iw</span><span class="p">,</span><span class="n">onepos</span><span class="p">))</span>
                                <span class="k">for</span> <span class="n">iw</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">nmask</span><span class="p">)</span> <span class="k">if</span> <span class="n">sumbit</span><span class="p">(</span><span class="n">iw</span><span class="p">)</span><span class="o">==</span><span class="n">weight</span><span class="p">]</span>
        <span class="c1">#                aff(&quot;bcumos for met,fmask,w &quot;+&quot;, &quot;.join((metab,strbit(fmask),str(weight))), [b for b in bcumos]);##</span>
                        <span class="n">res</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span>
                        <span class="k">for</span> <span class="n">cumostr</span> <span class="ow">in</span> <span class="n">bcumos</span><span class="p">:</span>
                            <span class="c1">#print cumostr;##</span>
                            <span class="n">decomp</span><span class="o">=</span><span class="n">bcumo_decomp</span><span class="p">(</span><span class="n">cumostr</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">icumo</span> <span class="ow">in</span> <span class="n">decomp</span><span class="p">[</span><span class="s2">&quot;+&quot;</span><span class="p">]:</span>
                                <span class="n">res</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">icumo</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
                                <span class="n">res</span><span class="p">[</span><span class="n">icumo</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
                            <span class="k">for</span> <span class="n">icumo</span> <span class="ow">in</span> <span class="n">decomp</span><span class="p">[</span><span class="s2">&quot;-&quot;</span><span class="p">]:</span>
                                <span class="n">res</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">icumo</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
                                <span class="n">res</span><span class="p">[</span><span class="n">icumo</span><span class="p">]</span><span class="o">-=</span><span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">bcumos</span><span class="o">=</span><span class="kc">None</span>
                        <span class="n">res</span><span class="o">=</span><span class="kc">None</span>
                    <span class="n">emuco</span><span class="o">=</span><span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="n">fmask</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;+&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">weight</span><span class="p">):</span> <span class="mi">1</span><span class="p">}</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;pooled&quot;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="c1"># init index list</span>
                        <span class="n">pooled</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]])</span>
                    <span class="k">for</span> <span class="n">metab</span> <span class="ow">in</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;pooled&quot;</span><span class="p">]:</span>
                        <span class="n">imrow</span><span class="o">+=</span><span class="mi">1</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;pooled&quot;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="c1"># indeed something is pooled</span>
                            <span class="n">pooled</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">imrow</span><span class="p">)</span>
                        <span class="n">mat</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">],</span> <span class="s2">&quot;scale&quot;</span><span class="p">:</span> <span class="n">metabs</span><span class="o">+</span><span class="s2">&quot;;&quot;</span><span class="o">+</span><span class="n">fmask01</span><span class="o">+</span><span class="s2">&quot;;&quot;</span><span class="o">+</span><span class="n">m_irow</span><span class="p">,</span> <span class="s2">&quot;coefs&quot;</span><span class="p">:</span><span class="n">res</span><span class="p">,</span>
                            <span class="s2">&quot;bcumos&quot;</span><span class="p">:</span> <span class="n">bcumos</span><span class="p">,</span> <span class="s2">&quot;metab&quot;</span><span class="p">:</span> <span class="n">metab</span><span class="p">,</span> <span class="s2">&quot;emuco&quot;</span><span class="p">:</span> <span class="n">emuco</span><span class="p">})</span>
        <span class="n">mli</span><span class="p">[</span><span class="n">ili</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;ids&quot;</span><span class="p">:</span> <span class="n">ids</span><span class="p">,</span> <span class="s2">&quot;mat&quot;</span><span class="p">:</span> <span class="n">mat</span><span class="p">,</span> <span class="s2">&quot;vec&quot;</span><span class="p">:</span> <span class="n">vec</span><span class="p">,</span> <span class="s2">&quot;dev&quot;</span><span class="p">:</span> <span class="n">dev</span><span class="p">,</span> <span class="s2">&quot;pooled&quot;</span><span class="p">:</span> <span class="n">pooled</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">mli</span></div>


<div class="viewcode-block" id="peak_meas2matrix_vec_dev">
<a class="viewcode-back" href="../progdoc.html#C13_ftbl.peak_meas2matrix_vec_dev">[docs]</a>
<span class="k">def</span> <span class="nf">peak_meas2matrix_vec_dev</span><span class="p">(</span><span class="n">netan</span><span class="p">,</span> <span class="n">dmask</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;S&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;D-&quot;</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span> <span class="s2">&quot;D+&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span> <span class="s2">&quot;DD&quot;</span><span class="p">:</span> <span class="mi">7</span><span class="p">}):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;use netan[&quot;peak_meas&quot;] list to construct a corresponding list of</span>
<span class="sd">    measure matrix matx_peak</span>
<span class="sd">    such that scale_diag*matx_peak*cumos_vector corresponds to</span>
<span class="sd">    peak_measures_vector.</span>
<span class="sd">    dmask is a dictionary with 3 carbon labeling pattern mask for</span>
<span class="sd">    various peak types. The middle bit corresponds to the targeted carbon,</span>
<span class="sd">    lower bit corresponds to the next neighbour (D+) and higher bit</span>
<span class="sd">    corresponds to previous carbon (D-).</span>
<span class="sd">    matx_peak is defined as matx_lab in peak_meas2matrix_vec_dev()</span>
<span class="sd">    Elements in matx_peak, vec and dev are ordered in the same way.</span>
<span class="sd">    scale name is defined as &quot;metab;c_no;irow&quot;</span>
<span class="sd">    The returned result is a dict (mat,vec,dev)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># peak[metab][c_no][peak_type]={val:x, dev:y}</span>
    <span class="c1"># c_no+peak_type have to be transformed in cumomer linear combination</span>
    <span class="c1"># c_no is 1-based and left (just after # sign) started.</span>
    <span class="n">nexp</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;iso_input&quot;</span><span class="p">])</span>
    <span class="n">mli</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nexp</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">ili</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nexp</span><span class="p">):</span>
        <span class="n">mat</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">vec</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">dev</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">pooled</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">ids</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">imrow</span><span class="o">=-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">metabs</span><span class="p">,</span><span class="n">irows</span><span class="p">)</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;peak_meas&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1">#print &quot;peak matx calc for &quot;, metab;##</span>
            <span class="c1">#import pdb; pdb.set_trace()</span>
            <span class="n">metabl</span><span class="o">=</span><span class="p">[</span><span class="o">*</span><span class="p">[</span><span class="o">*</span><span class="n">irows</span><span class="o">.</span><span class="n">values</span><span class="p">()][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()][</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;pooled&quot;</span><span class="p">]</span>
            <span class="c1">#print(metabl)</span>
            <span class="c1">#metabl=metabl[&quot;pooled&quot;]</span>
            
            <span class="n">metab0</span><span class="o">=</span><span class="n">metabl</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">n</span><span class="o">=</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;Clen&quot;</span><span class="p">][</span><span class="n">metab0</span><span class="p">]</span>
            <span class="n">strx</span><span class="o">=</span><span class="s2">&quot;#&quot;</span><span class="o">+</span><span class="s2">&quot;x&quot;</span><span class="o">*</span><span class="n">n</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">irow</span><span class="p">,</span><span class="n">peaks</span><span class="p">)</span> <span class="ow">in</span> <span class="n">irows</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="c1"># pmask0x put 0 on three targeted carbons and leave x elsewhere</span>
                <span class="n">c_no</span><span class="o">=</span><span class="p">[</span><span class="o">*</span><span class="n">peaks</span><span class="o">.</span><span class="n">values</span><span class="p">()][</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;c_no&quot;</span><span class="p">]</span>
                <span class="n">pmask0x</span><span class="o">=</span><span class="n">setcharbit</span><span class="p">(</span><span class="n">strx</span><span class="p">,</span><span class="s2">&quot;0&quot;</span><span class="p">,</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">c_no</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">c_no</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># add left neighbour</span>
                    <span class="n">pmask0x</span><span class="o">=</span><span class="n">setcharbit</span><span class="p">(</span><span class="n">pmask0x</span><span class="p">,</span><span class="s2">&quot;0&quot;</span><span class="p">,</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">c_no</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">c_no</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
                    <span class="c1"># add right neighbour</span>
                    <span class="n">pmask0x</span><span class="o">=</span><span class="n">setcharbit</span><span class="p">(</span><span class="n">pmask0x</span><span class="p">,</span><span class="s2">&quot;0&quot;</span><span class="p">,</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">c_no</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="c1">#            aff(&quot;peaks for met,c_no,pmask0x=&quot;+&quot;, &quot;.join((metab,str(c_no),pmask0x)), peaks);##</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">peak</span><span class="p">,</span><span class="n">row</span><span class="p">)</span> <span class="ow">in</span> <span class="n">peaks</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">vec</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;val&quot;</span><span class="p">])</span>
                    <span class="n">dev</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;dev&quot;</span><span class="p">])</span>
                    <span class="n">ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">])</span>
                    <span class="n">res</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span>
                    <span class="c1"># for a given (c_no,peak) construct bcumo sum: #x10x+#x01x+...</span>
                    <span class="c1"># shift the 3-bit mask to the right carbon position</span>
                    <span class="k">if</span> <span class="n">c_no</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
                        <span class="n">pmask</span><span class="o">=</span><span class="n">dmask</span><span class="p">[</span><span class="n">peak</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">c_no</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">pmask</span><span class="o">=</span><span class="n">dmask</span><span class="p">[</span><span class="n">peak</span><span class="p">]</span><span class="o">&gt;&gt;</span><span class="mi">1</span>
                    <span class="n">bcumos</span><span class="o">=</span><span class="p">[</span><span class="n">setcharbit</span><span class="p">(</span><span class="n">pmask0x</span><span class="p">,</span><span class="s2">&quot;1&quot;</span><span class="p">,</span><span class="n">pmask</span><span class="p">)]</span>
                    <span class="k">if</span> <span class="n">peak</span><span class="o">==</span><span class="s2">&quot;D-&quot;</span> <span class="ow">and</span> <span class="s2">&quot;T&quot;</span> <span class="ow">in</span> <span class="n">peaks</span><span class="p">:</span>
                        <span class="c1"># D+===D- =&gt; add D+ to the list of measured bcumomers</span>
                        <span class="c1"># set the 3-bit mask to the right carbon position</span>
                        <span class="k">if</span> <span class="n">c_no</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
                            <span class="n">pmask</span><span class="o">=</span><span class="n">dmask</span><span class="p">[</span><span class="s2">&quot;D+&quot;</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">c_no</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">pmask</span><span class="o">=</span><span class="n">dmask</span><span class="p">[</span><span class="s2">&quot;D+&quot;</span><span class="p">]</span><span class="o">&gt;&gt;</span><span class="mi">1</span>
                        <span class="n">bcumos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">setcharbit</span><span class="p">(</span><span class="n">pmask0x</span><span class="p">,</span><span class="s2">&quot;1&quot;</span><span class="p">,</span><span class="n">pmask</span><span class="p">))</span>
    <span class="c1">#                aff(&quot;bcumos for met,fmask,w &quot;+&quot;, &quot;.join((metab,strbit(fmask),str(weight))), [b for b in bcumos]);##</span>
                    <span class="k">for</span> <span class="n">cumostr</span> <span class="ow">in</span> <span class="n">bcumos</span><span class="p">:</span>
                        <span class="c1">#print cumostr;##</span>
                        <span class="n">decomp</span><span class="o">=</span><span class="n">bcumo_decomp</span><span class="p">(</span><span class="n">cumostr</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">icumo</span> <span class="ow">in</span> <span class="n">decomp</span><span class="p">[</span><span class="s2">&quot;+&quot;</span><span class="p">]:</span>
                            <span class="n">res</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">icumo</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
                            <span class="n">res</span><span class="p">[</span><span class="n">icumo</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
                        <span class="k">for</span> <span class="n">icumo</span> <span class="ow">in</span> <span class="n">decomp</span><span class="p">[</span><span class="s2">&quot;-&quot;</span><span class="p">]:</span>
                            <span class="n">res</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">icumo</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
                            <span class="n">res</span><span class="p">[</span><span class="n">icumo</span><span class="p">]</span><span class="o">-=</span><span class="mi">1</span>
                    <span class="n">emuco</span><span class="o">=</span><span class="nb">dict</span><span class="p">((</span><span class="nb">str</span><span class="p">(</span><span class="n">ic</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;+&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">sumbit</span><span class="p">(</span><span class="n">ic</span><span class="p">)),</span> <span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">ic</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="n">res</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;pooled&quot;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="c1"># init index list</span>
                        <span class="n">pooled</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]])</span>
                    <span class="k">for</span> <span class="n">metab</span> <span class="ow">in</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;pooled&quot;</span><span class="p">]:</span>
                        <span class="n">imrow</span><span class="o">+=</span><span class="mi">1</span>
                        <span class="n">mat</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">],</span> <span class="s2">&quot;scale&quot;</span><span class="p">:</span> <span class="n">metabs</span><span class="o">+</span><span class="s2">&quot;;&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">c_no</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;;&quot;</span><span class="o">+</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">],</span> <span class="s2">&quot;coefs&quot;</span><span class="p">:</span><span class="n">res</span><span class="p">,</span>
                            <span class="s2">&quot;bcumos&quot;</span><span class="p">:</span> <span class="n">bcumos</span><span class="p">,</span> <span class="s2">&quot;metab&quot;</span><span class="p">:</span> <span class="n">metab</span><span class="p">,</span> <span class="s2">&quot;emuco&quot;</span><span class="p">:</span> <span class="n">emuco</span><span class="p">})</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;pooled&quot;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="c1"># indeed something is pooled</span>
                            <span class="n">pooled</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">imrow</span><span class="p">)</span>
                    <span class="c1">#print &quot;metab,c_no,peak=&quot;+&quot;,&quot;.join((metab,str(c_no),str(peak)));##</span>
                    <span class="c1">#print &quot;res=&quot;,str(res);##</span>
        <span class="n">mli</span><span class="p">[</span><span class="n">ili</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;ids&quot;</span><span class="p">:</span> <span class="n">ids</span><span class="p">,</span> <span class="s2">&quot;mat&quot;</span><span class="p">:</span> <span class="n">mat</span><span class="p">,</span> <span class="s2">&quot;vec&quot;</span><span class="p">:</span> <span class="n">vec</span><span class="p">,</span> <span class="s2">&quot;dev&quot;</span><span class="p">:</span> <span class="n">dev</span><span class="p">,</span> <span class="s2">&quot;pooled&quot;</span><span class="p">:</span> <span class="n">pooled</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">mli</span></div>


<div class="viewcode-block" id="bcumo_decomp">
<a class="viewcode-back" href="../progdoc.html#C13_ftbl.bcumo_decomp">[docs]</a>
<span class="k">def</span> <span class="nf">bcumo_decomp</span><span class="p">(</span><span class="n">bcumo</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;bcumo is a string of the form #[01x]+. It has to be decomposed</span>
<span class="sd">    in the linear combination of cumomers #[1x]+. The coefficients</span>
<span class="sd">    of this linear combination are 1 or -1. So it can be represented as</span>
<span class="sd">    sum(cumos_positive)-sum(cumos_negative). The result of this function</span>
<span class="sd">    is a dictionary {&quot;+&quot;: list of icumos, &quot;-&quot;: list of icumos}. icumo is</span>
<span class="sd">    an integer whose binary form indicates 1&#39;s positions in a cumomer.&quot;&quot;&quot;</span>
    
    <span class="c1"># take zero positions</span>
    <span class="n">zpos</span><span class="o">=</span><span class="p">[</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bcumo</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">bcumo</span><span class="p">[</span><span class="o">-</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;0&quot;</span> <span class="p">]</span>
    
    <span class="c1"># basic 1&#39;s cumomer mask</span>
    <span class="n">icumo_base</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bcumo</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">bcumo</span><span class="p">[</span><span class="o">-</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;1&quot;</span><span class="p">:</span>
            <span class="n">icumo_base</span><span class="o">|=</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">i</span>
    
    <span class="c1"># run through all 2^n zero masks separating positive and negative</span>
    <span class="c1"># cumomers</span>
    <span class="n">res</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;+&quot;</span><span class="p">:</span> <span class="p">[],</span> <span class="s2">&quot;-&quot;</span><span class="p">:</span> <span class="p">[]}</span>
    <span class="n">nz</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">zpos</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">zmask</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">nz</span><span class="p">):</span>
        <span class="c1"># odd or even bit number?</span>
        <span class="n">sign</span><span class="o">=</span><span class="s2">&quot;-&quot;</span> <span class="k">if</span> <span class="n">sumbit</span><span class="p">(</span><span class="n">zmask</span><span class="p">)</span><span class="o">%</span><span class="mi">2</span> <span class="k">else</span> <span class="s2">&quot;+&quot;</span>
        
        <span class="c1"># get full cumomer mask</span>
        <span class="n">icumo</span><span class="o">=</span><span class="n">icumo_base</span><span class="o">|</span><span class="n">expandbit</span><span class="p">(</span><span class="n">zmask</span><span class="p">,</span><span class="n">zpos</span><span class="p">)</span>
        <span class="c1"># put in result dict</span>
        <span class="n">res</span><span class="p">[</span><span class="n">sign</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">icumo</span><span class="p">)</span>
    <span class="c1">#print bcumo+&quot;=&quot; + &quot;+&quot;.join(setcharbit(&quot;x&quot;*len(bcumo),&quot;1&quot;,i) for i in res[&quot;+&quot;])+(&quot;-&quot; if res[&quot;-&quot;] else &quot;&quot;) +&quot;-&quot;.join(setcharbit(&quot;x&quot;*len(bcumo),&quot;1&quot;,i) for i in res[&quot;-&quot;]);##</span>
    <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="mat2graph">
<a class="viewcode-back" href="../progdoc.html#C13_ftbl.mat2graph">[docs]</a>
<span class="k">def</span> <span class="nf">mat2graph</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">fp</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;write digraph file on file pointer fp representing</span>
<span class="sd">    links in matrix A given as bi-level dictionnary. A key of</span>
<span class="sd">    first level (row index) is influenced by keys of second level</span>
<span class="sd">    (column indicies).&quot;&quot;&quot;</span>
    <span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;digraph A {</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">A</span><span class="p">:</span>
        <span class="n">labi</span><span class="o">=</span><span class="n">i</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">==</span><span class="n">j</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">labj</span><span class="o">=</span><span class="n">j</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span><span class="p">)</span>
            <span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;   </span><span class="se">\&quot;</span><span class="s2">&quot;</span><span class="o">+</span><span class="n">labj</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\&quot;</span><span class="s2"> -&gt; </span><span class="se">\&quot;</span><span class="s2">&quot;</span><span class="o">+</span><span class="n">labi</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\&quot;\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="dom_cmp">
<a class="viewcode-back" href="../progdoc.html#C13_ftbl.dom_cmp">[docs]</a>
<span class="k">def</span> <span class="nf">dom_cmp</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compares influances of i-th and j-th lements of A.</span>
<span class="sd">    Returns 0 if i and j are mutually influenced, 1 if i in A[j]</span>
<span class="sd">    (i influences j) , -1 otherwise&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="mi">0</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="ow">and</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">else</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span></div>

<div class="viewcode-block" id="mat2pbm">
<a class="viewcode-back" href="../progdoc.html#C13_ftbl.mat2pbm">[docs]</a>
<span class="k">def</span> <span class="nf">mat2pbm</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">fp</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Write an image map of non-zero entries of matrix A to file pointer fp.</span>
<span class="sd">    Matrix A is a dictionnary, v is a list ordering keys of A.&quot;&quot;&quot;</span>
    <span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;P1</span><span class="se">\n</span><span class="si">%d</span><span class="s2"> </span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">v</span><span class="p">:</span>
        <span class="n">p</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">v</span><span class="p">:</span>
            <span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;1 &quot;</span> <span class="k">if</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">else</span> <span class="s2">&quot;0 &quot;</span><span class="p">)</span>
            <span class="n">p</span><span class="o">+=</span><span class="mi">2</span>
            <span class="k">if</span> <span class="n">p</span> <span class="o">&gt;=</span> <span class="mi">69</span><span class="p">:</span>
                <span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">p</span><span class="o">=</span><span class="mi">0</span>
        <span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">p</span><span class="o">=</span><span class="mi">0</span></div>

<div class="viewcode-block" id="aglom_loop1">
<a class="viewcode-back" href="../progdoc.html#C13_ftbl.aglom_loop1">[docs]</a>
<span class="k">def</span> <span class="nf">aglom_loop1</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Agglomerate nodes of A if they mutually influence each other</span>
<span class="sd">    i.e. they are in a loop of length 1.</span>
<span class="sd">    Return a new dictionary of influence where entries are those of A aglomerated and glued &quot;by&quot; tab symbol&quot;&quot;&quot;</span>
    <span class="c1"># i-&gt;loop_name(=min of all nodes in this loop)</span>
    <span class="n">na</span><span class="o">=</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">loop</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span>
    <span class="k">while</span> <span class="n">aglom</span><span class="p">(</span><span class="n">na</span><span class="p">,</span><span class="n">transpose</span><span class="p">(</span><span class="n">na</span><span class="p">),</span><span class="n">loop</span><span class="p">):</span>
        <span class="k">pass</span>
    <span class="k">return</span><span class="p">({</span><span class="s2">&quot;na&quot;</span><span class="p">:</span> <span class="n">na</span><span class="p">,</span> <span class="s2">&quot;loop&quot;</span><span class="p">:</span><span class="n">loop</span><span class="p">})</span></div>

<div class="viewcode-block" id="aglom">
<a class="viewcode-back" href="../progdoc.html#C13_ftbl.aglom">[docs]</a>
<span class="k">def</span> <span class="nf">aglom</span><span class="p">(</span><span class="n">na</span><span class="p">,</span><span class="n">ta</span><span class="p">,</span><span class="n">loop</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;new matrix A (na), transpose A (ta) are used to</span>
<span class="sd">    aglomerate neigbour mutually influencing nodes in a supernode.</span>
<span class="sd">    Aglomerated noeds are put in the loop dictionnary.</span>
<span class="sd">    Return False if no nodes were aglomerated.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">found</span><span class="o">=</span><span class="kc">False</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">na</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">na</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">j</span><span class="o">==</span><span class="n">i</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">na</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="c1"># agglomerate i and j in na</span>
                <span class="c1"># which means keep lowest netween i and j</span>
                <span class="c1"># lo=min(i,j)</span>
                <span class="c1"># hi=max(i,j)</span>
                <span class="c1"># and imports influences of hi to lo</span>
                <span class="n">found</span><span class="o">=</span><span class="kc">True</span>
                <span class="n">lo</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
                <span class="n">hi</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
                <span class="k">del</span><span class="p">(</span><span class="n">na</span><span class="p">[</span><span class="n">hi</span><span class="p">][</span><span class="n">hi</span><span class="p">])</span>
                <span class="k">del</span><span class="p">(</span><span class="n">ta</span><span class="p">[</span><span class="n">hi</span><span class="p">][</span><span class="n">hi</span><span class="p">])</span>
                <span class="c1">#print &quot;aglom: &quot;+i+&quot;+&quot;+j+&quot;-&gt;&quot;+lo;##</span>
                <span class="c1">#print &quot;elim row &quot;+hi+str(na[hi].keys());##</span>
                <span class="c1">#print &quot;influenced rows &quot;+str(ta[hi].keys());##</span>
                <span class="c1"># update na rows influenced by hi</span>
                <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="p">[</span><span class="o">*</span><span class="n">ta</span><span class="p">[</span><span class="n">hi</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()]:</span>
                    <span class="c1">#print &quot;\nold row &quot;+ii+str(na[ii].keys());##</span>
                    <span class="n">na</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">na</span><span class="p">[</span><span class="n">hi</span><span class="p">])</span>
                    <span class="k">del</span><span class="p">(</span><span class="n">na</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">hi</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="n">na</span><span class="p">[</span><span class="n">ii</span><span class="p">]:</span>
                        <span class="n">ta</span><span class="p">[</span><span class="n">jj</span><span class="p">][</span><span class="n">ii</span><span class="p">]</span><span class="o">=</span><span class="n">na</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">jj</span><span class="p">]</span>
                    <span class="c1">#print &quot;new row &quot;+ii+str(na[ii].keys());##</span>
                <span class="c1"># remove na[hi], ta[hi] and ta&#39;s corresponding to na[hi]</span>
                <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">na</span><span class="p">[</span><span class="n">hi</span><span class="p">]:</span>
                    <span class="k">del</span><span class="p">(</span><span class="n">ta</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">hi</span><span class="p">])</span>
                <span class="k">del</span><span class="p">(</span><span class="n">na</span><span class="p">[</span><span class="n">hi</span><span class="p">])</span>
                <span class="k">del</span><span class="p">(</span><span class="n">ta</span><span class="p">[</span><span class="n">hi</span><span class="p">])</span>
                <span class="c1"># update loop dictionary</span>
                <span class="n">loop</span><span class="p">[</span><span class="n">lo</span><span class="p">]</span><span class="o">=</span><span class="n">loop</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span><span class="n">oset</span><span class="p">((</span><span class="n">lo</span><span class="p">,)))</span>
                <span class="n">loop</span><span class="p">[</span><span class="n">lo</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">loop</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">hi</span><span class="p">,</span> <span class="n">oset</span><span class="p">((</span><span class="n">hi</span><span class="p">,))))</span>
                <span class="k">if</span> <span class="n">hi</span> <span class="ow">in</span> <span class="n">loop</span><span class="p">:</span>
                    <span class="k">del</span><span class="p">(</span><span class="n">loop</span><span class="p">[</span><span class="n">hi</span><span class="p">])</span>
                <span class="c1">#print &quot;loop:&quot;+str(loop)</span>
                <span class="k">return</span><span class="p">(</span><span class="n">found</span><span class="p">)</span></div>

<div class="viewcode-block" id="lowtri">
<a class="viewcode-back" href="../progdoc.html#C13_ftbl.lowtri">[docs]</a>
<span class="k">def</span> <span class="nf">lowtri</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Try low triangular ordering of matrix A entries&quot;&quot;&quot;</span>
    <span class="n">unsrt</span><span class="o">=</span><span class="p">[</span><span class="o">*</span><span class="n">A</span><span class="o">.</span><span class="n">keys</span><span class="p">()]</span>
    <span class="n">srt</span><span class="o">=</span><span class="nb">list</span><span class="p">()</span>
    <span class="c1"># first get inputs (no influences on them)</span>
    <span class="n">srt</span><span class="o">=</span><span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">unsrt</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">==</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">srt</span><span class="p">:</span>
        <span class="n">unsrt</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
    <span class="c1"># now move to lower number keys that influence others</span>
    <span class="k">while</span> <span class="n">unsrt</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">unsrt</span><span class="p">):</span>
            <span class="n">srt</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">oset</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">oset</span><span class="p">(</span><span class="n">srt</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="o">*</span><span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()]:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">unsrt</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="k">pass</span>
    <span class="k">return</span> <span class="n">srt</span></div>

<div class="viewcode-block" id="topo_order">
<a class="viewcode-back" href="../progdoc.html#C13_ftbl.topo_order">[docs]</a>
<span class="k">def</span> <span class="nf">topo_order</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">tA</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Try to sort keys of A in topological order. tA is just a transpose of A&quot;&quot;&quot;</span>
    <span class="n">unsrt</span><span class="o">=</span><span class="n">oset</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">srtin</span><span class="o">=</span><span class="nb">list</span><span class="p">()</span>
    <span class="n">srtout</span><span class="o">=</span><span class="nb">list</span><span class="p">()</span>
    
    <span class="k">while</span> <span class="n">unsrt</span><span class="p">:</span>
        <span class="c1"># shave inputs and outputs</span>
        <span class="n">inps</span><span class="o">=</span><span class="n">oset</span><span class="p">(</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">unsrt</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">oset</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">srtin</span><span class="p">))</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">srtin</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">inps</span><span class="p">)</span>
        <span class="n">unsrt</span><span class="o">.</span><span class="n">difference_update</span><span class="p">(</span><span class="n">inps</span><span class="p">)</span>
        <span class="n">outs</span><span class="o">=</span><span class="n">oset</span><span class="p">(</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">unsrt</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">oset</span><span class="p">(</span><span class="n">tA</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">unsrt</span><span class="p">))</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">outs</span><span class="p">:</span>
            <span class="n">srtout</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">outs</span><span class="p">)</span>
            <span class="n">unsrt</span><span class="o">.</span><span class="n">difference_update</span><span class="p">(</span><span class="n">outs</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">inps</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">outs</span><span class="p">:</span>
            <span class="c1"># this is not a dag</span>
            <span class="n">srtin</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">unsrt</span><span class="p">)</span>
            <span class="c1">#print &quot;not a dag&quot;</span>
            <span class="k">break</span>
    <span class="k">return</span><span class="p">(</span><span class="n">srtin</span><span class="o">+</span><span class="n">srtout</span><span class="p">)</span></div>

<div class="viewcode-block" id="transpose">
<a class="viewcode-back" href="../progdoc.html#C13_ftbl.transpose">[docs]</a>
<span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Transpose a matrix defined as a dict.&quot;&quot;&quot;</span>
    <span class="n">tA</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">A</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">tA</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">tA</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="nb">dict</span><span class="p">())</span>
            <span class="n">tA</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
    <span class="k">return</span><span class="p">(</span><span class="n">tA</span><span class="p">)</span></div>

<div class="viewcode-block" id="rcumo_sys">
<a class="viewcode-back" href="../progdoc.html#C13_ftbl.rcumo_sys">[docs]</a>
<span class="k">def</span> <span class="nf">rcumo_sys</span><span class="p">(</span><span class="n">netan</span><span class="p">,</span> <span class="n">emu</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate reduced cumomers or EMU systems A*x=b</span>
<span class="sd">    we start with observed cumomers (emus) of max weight</span>
<span class="sd">    and we include only needed involved cumomers (emus)</span>
<span class="sd">    A list of cumomer (emu) lists (by weight) is stored</span>
<span class="sd">    in netan[&quot;vrcumo&quot;] (netan[&quot;vemu&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># generate measurements dico if not yet done</span>
    <span class="k">if</span> <span class="s2">&quot;measures&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">:</span>
        <span class="n">measures</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">meas</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;label&quot;</span><span class="p">,</span> <span class="s2">&quot;mass&quot;</span><span class="p">,</span> <span class="s2">&quot;peak&quot;</span><span class="p">):</span>
            <span class="n">measures</span><span class="p">[</span><span class="n">meas</span><span class="p">]</span><span class="o">=</span><span class="nb">eval</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">_meas2matrix_vec_dev(netan)&quot;</span><span class="o">%</span><span class="n">meas</span><span class="p">)</span>
        <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;measures&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">measures</span>
    <span class="n">measures</span><span class="o">=</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;measures&quot;</span><span class="p">]</span>

    <span class="c1"># init rcumo_input</span>
    <span class="n">n</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;iso_input&quot;</span><span class="p">])</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;rcumo_input&quot;</span><span class="p">])</span> <span class="o">!=</span> <span class="n">n</span><span class="p">:</span>
        <span class="c1"># init rcumo_input list of dicts</span>
        <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;rcumo_input&quot;</span><span class="p">]</span><span class="o">=</span><span class="p">[{}</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
    
    <span class="c1"># get cumomers involved in measurements</span>
    <span class="n">meas_cumos</span><span class="o">=</span><span class="n">oset</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">emu</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">meas</span> <span class="ow">in</span> <span class="n">measures</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">measures</span><span class="p">[</span><span class="n">meas</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">item</span><span class="p">[</span><span class="s2">&quot;mat&quot;</span><span class="p">]:</span>
                    <span class="n">metab</span><span class="o">=</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;metab&quot;</span><span class="p">]</span>
                    <span class="n">meas_cumos</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">metab</span><span class="o">+</span><span class="s2">&quot;:&quot;</span><span class="o">+</span><span class="n">i</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;+&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="o">*</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;emuco&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()])</span> <span class="c1"># if i[-2:]!=&quot;+0&quot;)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">meas</span> <span class="ow">in</span> <span class="n">measures</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">measures</span><span class="p">[</span><span class="n">meas</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">item</span><span class="p">[</span><span class="s2">&quot;mat&quot;</span><span class="p">]:</span>
                    <span class="n">metab</span><span class="o">=</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;metab&quot;</span><span class="p">]</span>
                    <span class="n">meas_cumos</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">metab</span><span class="o">+</span><span class="s2">&quot;:&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">icumo</span><span class="p">)</span> <span class="k">for</span> <span class="n">icumo</span> <span class="ow">in</span> <span class="p">[</span><span class="o">*</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;coefs&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()]</span> <span class="k">if</span> <span class="n">icumo</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="c1"># make list of observed weights</span>
    <span class="n">weights</span><span class="o">=</span><span class="n">oset</span><span class="p">(</span><span class="n">sumbit</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">cumo</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]))</span> <span class="k">for</span> <span class="n">cumo</span> <span class="ow">in</span> <span class="n">meas_cumos</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">weights</span><span class="p">:</span>
        <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vrcumo&quot;</span><span class="p">]</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;rcumo2i0&quot;</span><span class="p">]</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span>
        <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;rcumo_sys&quot;</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;A&quot;</span><span class="p">:</span> <span class="p">[],</span> <span class="s2">&quot;b&quot;</span><span class="p">:</span> <span class="p">[]}</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;A&quot;</span><span class="p">:</span> <span class="p">[],</span> <span class="s2">&quot;b&quot;</span><span class="p">:</span> <span class="p">[]}</span>
    
    <span class="n">maxw</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
    <span class="n">weights</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">maxw</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">weights</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
    
    <span class="c1"># cumomers to visit are stored in lists by weights</span>
    <span class="n">to_visit</span><span class="o">=</span><span class="nb">dict</span><span class="p">((</span><span class="n">w</span><span class="p">,[])</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">weights</span><span class="p">)</span>
    <span class="n">A</span><span class="o">=</span><span class="p">[{}</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">maxw</span><span class="p">)];</span> <span class="c1"># store matrices by weight</span>
    <span class="n">b</span><span class="o">=</span><span class="p">[{}</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">maxw</span><span class="p">)];</span> <span class="c1"># store rhs by weight</span>
    <span class="n">used</span><span class="o">=</span><span class="n">oset</span><span class="p">()</span>

    <span class="c1"># initialize to_visit, we&#39;ll stop when it&#39;s empty</span>
    <span class="k">for</span> <span class="n">cumo</span> <span class="ow">in</span> <span class="n">meas_cumos</span><span class="p">:</span>
        <span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">w</span><span class="p">)</span><span class="o">=</span><span class="n">cumo</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">]:</span>
            <span class="k">continue</span>
        <span class="n">w</span><span class="o">=</span><span class="n">sumbit</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">w</span><span class="p">))</span>
        <span class="n">to_visit</span><span class="p">[</span><span class="n">w</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cumo</span><span class="p">)</span>

    <span class="c1"># run through the network starting with heaviest cumomers</span>
    <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">weights</span><span class="p">:</span>
        <span class="n">cumo_i</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">while</span> <span class="n">cumo_i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_visit</span><span class="p">[</span><span class="n">w</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">cumo</span> <span class="ow">in</span> <span class="n">to_visit</span><span class="p">[</span><span class="n">w</span><span class="p">]:</span>
                <span class="n">cumo_i</span><span class="o">+=</span><span class="mi">1</span>
                <span class="k">if</span> <span class="n">cumo</span> <span class="ow">in</span> <span class="n">used</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="c1"># add this cumo to used</span>
                <span class="n">used</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">cumo</span><span class="p">)</span>
                <span class="p">(</span><span class="n">metab</span><span class="p">,</span> <span class="n">icumo</span><span class="p">)</span><span class="o">=</span><span class="n">cumo</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">metab</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;output&quot;</span><span class="p">]:</span>
                    <span class="c1"># no equation for output metabs</span>
                    <span class="k">continue</span>
                <span class="n">icumo</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">icumo</span><span class="p">)</span>
                <span class="n">A</span><span class="p">[</span><span class="n">w</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">cumo</span><span class="p">]</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="n">w</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">cumo</span><span class="p">,{</span><span class="n">cumo</span><span class="p">:[]})</span>
                <span class="c1"># get the influents to cumo of all weights: equal and lower</span>
                <span class="c1"># equals go to A and lowers go to b</span>
                <span class="n">infl</span><span class="o">=</span><span class="n">cumo_infl</span><span class="p">(</span><span class="n">netan</span><span class="p">,</span> <span class="n">cumo</span><span class="p">)</span>
                <span class="c1">#print(&quot;cumo=&quot;, cumo, &quot;infl=&quot;, infl)</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">incumo</span><span class="p">,</span><span class="n">fl</span><span class="p">,</span><span class="n">imetab</span><span class="p">,</span><span class="n">iinmetab</span><span class="p">)</span> <span class="ow">in</span> <span class="n">infl</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">incumo</span><span class="o">==</span><span class="n">cumo</span><span class="p">:</span>
                        <span class="c1"># no equation as no transformation</span>
                        <span class="k">continue</span>
                    <span class="p">(</span><span class="n">inmetab</span><span class="p">,</span> <span class="n">inw</span><span class="p">)</span><span class="o">=</span><span class="n">incumo</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)</span>
                    <span class="n">inicumo</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">inw</span><span class="p">)</span>
                    <span class="n">inw</span><span class="o">=</span><span class="n">sumbit</span><span class="p">(</span><span class="n">inicumo</span><span class="p">)</span>
                    <span class="c1"># input metabolites are to rhs, others are to visit</span>
                    <span class="k">if</span> <span class="n">inmetab</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">inw</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">incumo</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">to_visit</span><span class="p">[</span><span class="n">inw</span><span class="p">]:</span>
                        <span class="n">to_visit</span><span class="p">[</span><span class="n">inw</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">incumo</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">inmetab</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">emu</span><span class="p">:</span>
                            <span class="c1"># tuple emu (mask, m+i, string)</span>
                            <span class="k">for</span> <span class="n">mask</span><span class="p">,</span> <span class="n">mpi</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="p">((</span><span class="n">inicumo</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">incumo</span><span class="o">+</span><span class="s2">&quot;+&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inw</span><span class="o">+</span><span class="mi">1</span><span class="p">)):</span>
                                <span class="n">iso2emu</span><span class="p">(</span><span class="n">netan</span><span class="p">,</span> <span class="n">inmetab</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">mpi</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;rcumo_input&quot;</span><span class="p">]</span> <span class="ow">or</span> <span class="n">incumo</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;rcumo_input&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
                            <span class="n">iso2cumo</span><span class="p">(</span><span class="n">netan</span><span class="p">,</span> <span class="s2">&quot;rcumo_input&quot;</span><span class="p">,</span> <span class="n">incumo</span><span class="p">,</span> <span class="n">inicumo</span><span class="p">,</span> <span class="n">inmetab</span><span class="p">)</span>
                        <span class="c1">#netan[&quot;rcumo_input&quot;][incumo]=netan[&quot;cumo_input&quot;][incumo]</span>
                    <span class="c1"># main part: write equations</span>
                    <span class="k">if</span> <span class="n">inw</span><span class="o">==</span><span class="n">w</span> <span class="p">:</span>
                        <span class="c1"># equal weight =&gt; A</span>
                        <span class="k">if</span> <span class="n">inmetab</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">]:</span>
                            <span class="n">b</span><span class="p">[</span><span class="n">w</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">cumo</span><span class="p">]</span><span class="o">=</span><span class="n">b</span><span class="p">[</span><span class="n">w</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">cumo</span><span class="p">,</span> <span class="nb">dict</span><span class="p">())</span>
                            <span class="n">b</span><span class="p">[</span><span class="n">w</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">cumo</span><span class="p">][</span><span class="n">fl</span><span class="p">]</span><span class="o">=</span><span class="n">b</span><span class="p">[</span><span class="n">w</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">cumo</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">fl</span><span class="p">,</span> <span class="nb">dict</span><span class="p">())</span>
                            <span class="n">b</span><span class="p">[</span><span class="n">w</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">cumo</span><span class="p">][</span><span class="n">fl</span><span class="p">][</span><span class="n">imetab</span><span class="p">]</span><span class="o">=</span><span class="n">b</span><span class="p">[</span><span class="n">w</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">cumo</span><span class="p">][</span><span class="n">fl</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">imetab</span><span class="p">,[])</span>
                            <span class="c1">#b[w-1][cumo][fl][imetab].append(netan[&quot;cumo_input&quot;][incumo])</span>
                            <span class="n">b</span><span class="p">[</span><span class="n">w</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">cumo</span><span class="p">][</span><span class="n">fl</span><span class="p">][</span><span class="n">imetab</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">incumo</span><span class="p">)</span>
                            <span class="k">continue</span>
                        <span class="n">A</span><span class="p">[</span><span class="n">w</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">cumo</span><span class="p">][</span><span class="n">incumo</span><span class="p">]</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="n">w</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">cumo</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">incumo</span><span class="p">,[])</span>
                        <span class="n">A</span><span class="p">[</span><span class="n">w</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">cumo</span><span class="p">][</span><span class="n">incumo</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fl</span><span class="p">)</span>
                        <span class="c1">#aff(&quot;A &quot;+str(w)+cumo, A[w-1][cumo]);##</span>
                    <span class="k">elif</span> <span class="n">inw</span> <span class="o">&lt;</span> <span class="n">w</span><span class="p">:</span>
                        <span class="c1"># lower weight =&gt; b</span>
                        <span class="n">b</span><span class="p">[</span><span class="n">w</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">cumo</span><span class="p">]</span><span class="o">=</span><span class="n">b</span><span class="p">[</span><span class="n">w</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">cumo</span><span class="p">,</span> <span class="nb">dict</span><span class="p">())</span>
                        <span class="n">b</span><span class="p">[</span><span class="n">w</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">cumo</span><span class="p">][</span><span class="n">fl</span><span class="p">]</span><span class="o">=</span><span class="n">b</span><span class="p">[</span><span class="n">w</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">cumo</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">fl</span><span class="p">,</span> <span class="nb">dict</span><span class="p">())</span>
                        <span class="n">b</span><span class="p">[</span><span class="n">w</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">cumo</span><span class="p">][</span><span class="n">fl</span><span class="p">][</span><span class="n">imetab</span><span class="p">]</span><span class="o">=</span><span class="n">b</span><span class="p">[</span><span class="n">w</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">cumo</span><span class="p">][</span><span class="n">fl</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">imetab</span><span class="p">,[])</span>
                        <span class="n">b</span><span class="p">[</span><span class="n">w</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">cumo</span><span class="p">][</span><span class="n">fl</span><span class="p">][</span><span class="n">imetab</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">incumo</span><span class="p">)</span>
                <span class="c1"># gather all influx in diagonal term</span>
                <span class="c1">#aff(&quot;A &quot;+str(w)+&quot; &quot;+cumo, A[w-1][cumo]);##</span>
                <span class="c1">#aff(&quot;b &quot;+str(w)+&quot; &quot;+cumo, b[w-1].get(cumo));##</span>
                <span class="k">for</span> <span class="n">incumo</span> <span class="ow">in</span> <span class="n">A</span><span class="p">[</span><span class="n">w</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">cumo</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">incumo</span> <span class="o">==</span> <span class="n">cumo</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">A</span><span class="p">[</span><span class="n">w</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">cumo</span><span class="p">]</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="n">w</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">cumo</span><span class="p">,{</span><span class="n">cumo</span><span class="p">:[]})</span>
                    <span class="c1">#print(&quot;adding A:&quot;, incumo, &quot;-&gt;&quot;, cumo, A[w-1][cumo][incumo]);##</span>
                    <span class="n">A</span><span class="p">[</span><span class="n">w</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">cumo</span><span class="p">][</span><span class="n">cumo</span><span class="p">]</span><span class="o">+=</span><span class="n">A</span><span class="p">[</span><span class="n">w</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">cumo</span><span class="p">][</span><span class="n">incumo</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">cumo</span> <span class="ow">in</span> <span class="n">b</span><span class="p">[</span><span class="n">w</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">A</span><span class="p">[</span><span class="n">w</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">cumo</span><span class="p">]</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="n">w</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">cumo</span><span class="p">,{</span><span class="n">cumo</span><span class="p">:[]})</span>
                    <span class="c1">#print(&quot;adding b:&quot;, cumo, b[w-1][cumo].keys());##</span>
                    <span class="n">A</span><span class="p">[</span><span class="n">w</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">cumo</span><span class="p">][</span><span class="n">cumo</span><span class="p">]</span><span class="o">+=</span><span class="p">[</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="n">w</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">cumo</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()]</span>
    <span class="c1">#import pdb; pdb.set_trace()</span>
    <span class="c1">#netan[&quot;rcumo_input&quot;]=[dict((k, (v if v==v else 0.)) for k,v in d.items()) for d in netan[&quot;rcumo_input&quot;]]</span>
    <span class="c1">#aff(&quot;to_v&quot;, to_visit);##</span>
    <span class="c1"># make ordered list for reduced cumomer set</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vrcumo&quot;</span><span class="p">]</span><span class="o">=</span><span class="p">[[</span><span class="o">*</span><span class="n">a</span><span class="o">.</span><span class="n">keys</span><span class="p">()]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">A</span><span class="p">]</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;rcumo2i0&quot;</span><span class="p">]</span><span class="o">=</span><span class="nb">dict</span><span class="p">((</span><span class="n">cumo</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">cumo</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">valval</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vrcumo&quot;</span><span class="p">])))</span>
    <span class="c1">#print(&quot;A=&quot;, A)</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;rcumo_sys&quot;</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;A&quot;</span><span class="p">:</span> <span class="n">A</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">:</span> <span class="n">b</span><span class="p">}</span>
    <span class="c1"># make order list for emu_input</span>
    <span class="k">if</span> <span class="n">emu</span><span class="p">:</span>
        <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vemu_input&quot;</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="o">*</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;emu_input&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()]</span>
        <span class="c1"># make order list for internal emus</span>
        <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vemu&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vrcumo&quot;</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vemu&quot;</span><span class="p">])):</span>
            <span class="n">l</span><span class="o">=</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vemu&quot;</span><span class="p">][</span><span class="n">w</span><span class="p">]</span>
            <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vemu&quot;</span><span class="p">][</span><span class="n">w</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="n">m</span><span class="o">+</span><span class="s2">&quot;+&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">w</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">l</span><span class="p">]</span>
        <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;emu2i0&quot;</span><span class="p">]</span><span class="o">=</span><span class="nb">dict</span><span class="p">((</span><span class="n">emu</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">emu</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">valval</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;vemu&quot;</span><span class="p">])))</span>
    <span class="k">return</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;rcumo_sys&quot;</span><span class="p">]</span></div>


<div class="viewcode-block" id="cumo_infl">
<a class="viewcode-back" href="../progdoc.html#C13_ftbl.cumo_infl">[docs]</a>
<span class="k">def</span> <span class="nf">cumo_infl</span><span class="p">(</span><span class="n">netan</span><span class="p">,</span> <span class="n">cumo</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;cumo_infl(netan, cumo)-&gt;list(tuple(in_cumo, fl, imetab, iin_metab))</span>
<span class="sd">    return the list of tuples (in_cumo, fl, imetab, iin_metab):</span>
<span class="sd">    input cumomer, flux (fwd.fl or rev.fl), index of metab and index of in_metab</span>
<span class="sd">    generating cumo. cumo is in format &quot;metab:icumo&quot;.</span>
<span class="sd">    Condenstation reaction will give the same flux and icumo but various</span>
<span class="sd">    iin_metab.</span>
<span class="sd">    Convergent point will give multiple fluxes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="p">(</span><span class="n">metab</span><span class="p">,</span> <span class="n">icumo</span><span class="p">)</span><span class="o">=</span><span class="n">cumo</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)</span>
    <span class="n">icumo</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">icumo</span><span class="p">)</span>
    <span class="n">res</span><span class="o">=</span><span class="p">[]</span>
    <span class="c1"># run through input forward fluxes of this metab</span>
    <span class="k">for</span> <span class="n">reac</span><span class="p">,</span><span class="n">coef</span> <span class="ow">in</span> <span class="n">oset</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;sto_m_r&quot;</span><span class="p">][</span><span class="n">metab</span><span class="p">][</span><span class="s2">&quot;right&quot;</span><span class="p">]):</span>
        <span class="k">if</span> <span class="n">reac</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;carbotrans&quot;</span><span class="p">]:</span>
            <span class="k">continue</span> <span class="c1"># it can happen because of NOTRACER_NETWORK</span>
        <span class="c1"># get all cstr for given metab</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">imetab</span><span class="p">,</span><span class="n">cstr</span><span class="p">)</span> <span class="ow">in</span> <span class="p">((</span><span class="n">i</span><span class="p">,</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,(</span><span class="n">m</span><span class="p">,</span><span class="n">s</span><span class="p">))</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;carbotrans&quot;</span><span class="p">][</span><span class="n">reac</span><span class="p">][</span><span class="s2">&quot;right&quot;</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">m</span><span class="o">==</span><span class="n">metab</span><span class="p">):</span>
            <span class="c1"># get all input cumomer in this reaction for this cstr</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">iin_metab</span><span class="p">,</span> <span class="p">(</span><span class="n">in_metab</span><span class="p">,</span><span class="n">in_str</span><span class="p">))</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;carbotrans&quot;</span><span class="p">][</span><span class="n">reac</span><span class="p">][</span><span class="s2">&quot;left&quot;</span><span class="p">]):</span>
                <span class="n">in_icumo</span><span class="o">=</span><span class="n">src_ind</span><span class="p">(</span><span class="n">in_str</span><span class="p">,</span> <span class="n">cstr</span><span class="p">,</span> <span class="n">icumo</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">in_icumo</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">in_cumo</span><span class="o">=</span><span class="n">in_metab</span><span class="o">+</span><span class="s2">&quot;:&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">in_icumo</span><span class="p">)</span>
                    <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">in_cumo</span><span class="p">,</span> <span class="s2">&quot;fwd.&quot;</span><span class="o">+</span><span class="n">reac</span><span class="p">,</span> <span class="n">imetab</span><span class="p">,</span> <span class="n">iin_metab</span><span class="p">))</span>
    <span class="c1"># run through input reverse fluxes of this metab</span>
    <span class="n">fluxset</span><span class="o">=</span><span class="n">oset</span><span class="p">(</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span><span class="p">,</span><span class="n">c</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;sto_m_r&quot;</span><span class="p">][</span><span class="n">metab</span><span class="p">][</span><span class="s2">&quot;left&quot;</span><span class="p">])</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">clownr</span><span class="p">):</span>
        <span class="c1"># non reversible reactions are all positive</span>
        <span class="n">fluxset</span><span class="o">=</span><span class="n">fluxset</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;notrev&quot;</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># non reversible reactions can change sens =&gt; keep reverse flux just in case</span>
        <span class="n">fluxset</span><span class="o">=</span><span class="n">fluxset</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_inout&quot;</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">reac</span> <span class="ow">in</span> <span class="n">fluxset</span><span class="p">:</span>
        <span class="c1"># get all cstr for given metab</span>
        <span class="k">if</span> <span class="n">reac</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;carbotrans&quot;</span><span class="p">]:</span>
            <span class="k">continue</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">imetab</span><span class="p">,</span><span class="n">cstr</span><span class="p">)</span> <span class="ow">in</span> <span class="p">((</span><span class="n">i</span><span class="p">,</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,(</span><span class="n">m</span><span class="p">,</span><span class="n">s</span><span class="p">))</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;carbotrans&quot;</span><span class="p">][</span><span class="n">reac</span><span class="p">][</span><span class="s2">&quot;left&quot;</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">m</span><span class="o">==</span><span class="n">metab</span><span class="p">):</span>
            <span class="c1"># get all input cumomer in this reaction for this cstr</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">iin_metab</span><span class="p">,</span> <span class="p">(</span><span class="n">in_metab</span><span class="p">,</span><span class="n">in_str</span><span class="p">))</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;carbotrans&quot;</span><span class="p">][</span><span class="n">reac</span><span class="p">][</span><span class="s2">&quot;right&quot;</span><span class="p">]):</span>
                <span class="n">in_icumo</span><span class="o">=</span><span class="n">src_ind</span><span class="p">(</span><span class="n">in_str</span><span class="p">,</span> <span class="n">cstr</span><span class="p">,</span> <span class="n">icumo</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">in_icumo</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">in_cumo</span><span class="o">=</span><span class="n">in_metab</span><span class="o">+</span><span class="s2">&quot;:&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">in_icumo</span><span class="p">)</span>
                    <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">in_cumo</span><span class="p">,</span> <span class="s2">&quot;rev.&quot;</span><span class="o">+</span><span class="n">reac</span><span class="p">,</span> <span class="n">imetab</span><span class="p">,</span> <span class="n">iin_metab</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="infl">
<a class="viewcode-back" href="../progdoc.html#C13_ftbl.infl">[docs]</a>
<span class="k">def</span> <span class="nf">infl</span><span class="p">(</span><span class="n">metab</span><span class="p">,</span> <span class="n">netan</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;infl(metab, netan)-&gt;oset(fluxes)</span>
<span class="sd">    List incoming fluxes for this metabolite (fwd.reac, rev.reac, ...)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># run through input forward fluxes of this metab</span>
    <span class="n">res</span><span class="o">=</span><span class="n">oset</span><span class="p">(</span><span class="s2">&quot;fwd.&quot;</span><span class="o">+</span><span class="n">reac</span> <span class="k">for</span> <span class="n">reac</span><span class="p">,</span><span class="n">_</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;sto_m_r&quot;</span><span class="p">][</span><span class="n">metab</span><span class="p">][</span><span class="s2">&quot;right&quot;</span><span class="p">])</span>
    <span class="c1"># run through input reverse fluxes of this metab</span>
    <span class="n">res</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="s2">&quot;rev.&quot;</span><span class="o">+</span><span class="n">reac</span> <span class="k">for</span> <span class="n">reac</span> <span class="ow">in</span>
        <span class="n">oset</span><span class="p">(</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span><span class="p">,</span><span class="n">_</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;sto_m_r&quot;</span><span class="p">][</span><span class="n">metab</span><span class="p">][</span><span class="s2">&quot;left&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;flux_inout&quot;</span><span class="p">]))</span>
<span class="c1">#        oset(netan[&quot;sto_m_r&quot;][metab][&quot;left&quot;]).difference(netan[&quot;notrev&quot;]))</span>
    <span class="k">return</span><span class="p">(</span><span class="n">res</span><span class="p">)</span></div>


<div class="viewcode-block" id="t_iso2m">
<a class="viewcode-back" href="../progdoc.html#C13_ftbl.t_iso2m">[docs]</a>
<span class="k">def</span> <span class="nf">t_iso2m</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;t_iso2m(n) return transition matrix from isotopomers fractions to MID vector</span>
<span class="sd">    n - carbon number</span>
<span class="sd">    return numpy array of size (n+1,2**n)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># isotopomer number</span>
    <span class="n">ni</span><span class="o">=</span><span class="mi">2</span><span class="o">**</span><span class="n">n</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[[</span><span class="mf">1.</span> <span class="k">if</span> <span class="n">sumbit</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span><span class="o">==</span><span class="n">im</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ni</span><span class="p">)]</span> <span class="k">for</span> <span class="n">im</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="t_iso2cumo">
<a class="viewcode-back" href="../progdoc.html#C13_ftbl.t_iso2cumo">[docs]</a>
<span class="k">def</span> <span class="nf">t_iso2cumo</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;t_iso2cumo(n) return transition matrix from isotopomers fractions to cumomer vector</span>
<span class="sd">    n - carbon number</span>
<span class="sd">    return numpy array of size (2**n,2**n)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="c1"># recursive call</span>
    <span class="n">m_1</span><span class="o">=</span><span class="n">t_iso2cumo</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">nc1</span><span class="p">,</span><span class="n">nc1</span><span class="o">=</span><span class="n">m_1</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">nc</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">nc1</span>
    <span class="n">m</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nc</span><span class="p">,</span><span class="n">nc</span><span class="p">))</span>
    <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">nc1</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">nc1</span><span class="p">],</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">nc1</span><span class="p">,</span><span class="n">nc1</span><span class="p">:],</span><span class="n">m</span><span class="p">[</span><span class="n">nc1</span><span class="p">:,</span><span class="n">nc1</span><span class="p">:]</span><span class="o">=</span><span class="n">m_1</span><span class="p">,</span><span class="n">m_1</span><span class="p">,</span><span class="n">m_1</span>
    <span class="k">return</span> <span class="n">m</span></div>


<div class="viewcode-block" id="t_iso2pos">
<a class="viewcode-back" href="../progdoc.html#C13_ftbl.t_iso2pos">[docs]</a>
<span class="k">def</span> <span class="nf">t_iso2pos</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;t_iso2pos(n) return transition matrix from isotopomers fractions to positional</span>
<span class="sd">    labelling vector (cumomers of weight 1)</span>
<span class="sd">    n - carbon number</span>
<span class="sd">    return numpy array of size (n,2**n)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">m</span><span class="o">=</span><span class="n">t_iso2cumo</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">m</span><span class="p">[[</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)],:]</span></div>


<div class="viewcode-block" id="conv_mid">
<a class="viewcode-back" href="../progdoc.html#C13_ftbl.conv_mid">[docs]</a>
<span class="k">def</span> <span class="nf">conv_mid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;conv_mid(x,y)-&gt;z</span>
<span class="sd">    convolute two mid vectors (numpy arrays)</span>
<span class="sd">    and return the result as numpy array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nx</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">ny</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="n">z</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nx</span><span class="o">+</span><span class="n">ny</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ny</span><span class="p">):</span>
        <span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">nx</span><span class="p">]</span><span class="o">+=</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">return</span><span class="p">(</span><span class="n">z</span><span class="p">)</span></div>


<div class="viewcode-block" id="ms_frag_gath">
<a class="viewcode-back" href="../progdoc.html#C13_ftbl.ms_frag_gath">[docs]</a>
<span class="k">def</span> <span class="nf">ms_frag_gath</span><span class="p">(</span><span class="n">netan</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;gather metabolite fragments necessary to obtain a given set of data</span>
<span class="sd">    observed in MS measurements.</span>
<span class="sd">    The fragment mask is encoded in the same way as cumomers, Met:7 &lt;=&gt; Met#(0)111</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">frags</span><span class="o">=</span><span class="n">oset</span><span class="p">()</span>
    <span class="n">to_visit</span><span class="o">=</span><span class="n">oset</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">di</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;mass_meas&quot;</span><span class="p">]:</span>
        <span class="k">for</span> <span class="n">m_id</span> <span class="ow">in</span> <span class="n">di</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">mask</span> <span class="ow">in</span> <span class="n">di</span><span class="p">[</span><span class="n">m_id</span><span class="p">]:</span>
                <span class="c1"># just the first weight item is sufficient</span>
                <span class="n">item</span><span class="o">=</span><span class="p">[</span><span class="o">*</span><span class="n">di</span><span class="p">[</span><span class="n">m_id</span><span class="p">][</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">to_visit</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">met</span><span class="o">+</span><span class="s2">&quot;:&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="k">for</span> <span class="n">met</span> <span class="ow">in</span> <span class="n">item</span><span class="p">[</span><span class="s2">&quot;pooled&quot;</span><span class="p">])</span>
    <span class="k">while</span> <span class="n">to_visit</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">frag</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">to_visit</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">frag</span> <span class="ow">in</span> <span class="n">frags</span><span class="p">:</span>
                <span class="c1"># already accounted</span>
                <span class="n">to_visit</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">frag</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="n">frags</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">frag</span><span class="p">)</span>
            <span class="n">to_visit</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">frag</span><span class="p">)</span>
            <span class="c1"># add its contributors for visiting</span>
            <span class="n">to_visit</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">incumo</span> <span class="k">for</span> <span class="p">(</span><span class="n">incumo</span><span class="p">,</span><span class="n">fl</span><span class="p">,</span><span class="n">imetab</span><span class="p">,</span><span class="n">iinmetab</span><span class="p">)</span> <span class="ow">in</span> <span class="n">cumo_infl</span><span class="p">(</span><span class="n">netan</span><span class="p">,</span> <span class="n">frag</span><span class="p">))</span>
            <span class="k">break</span>
    <span class="k">return</span><span class="p">(</span><span class="n">frags</span><span class="p">)</span></div>

<div class="viewcode-block" id="ntimes">
<a class="viewcode-back" href="../progdoc.html#C13_ftbl.ntimes">[docs]</a>
<span class="k">def</span> <span class="nf">ntimes</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return charcater string &#39;once&#39; for n=1, &#39;twice&#39; for n=2 and &#39;n times&#39; for other n&quot;&quot;&quot;</span>
    <span class="k">return</span><span class="p">(</span><span class="s2">&quot;once&quot;</span> <span class="k">if</span> <span class="n">n</span><span class="o">==</span><span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;twice&quot;</span> <span class="k">if</span> <span class="n">n</span><span class="o">==</span><span class="mi">2</span> <span class="k">else</span> <span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> times&quot;</span><span class="o">%</span><span class="n">n</span><span class="p">)</span></div>

<div class="viewcode-block" id="proc_label_input">
<a class="viewcode-back" href="../progdoc.html#C13_ftbl.proc_label_input">[docs]</a>
<span class="k">def</span> <span class="nf">proc_label_input</span><span class="p">(</span><span class="n">ftbl</span><span class="p">,</span> <span class="n">netan</span><span class="p">,</span> <span class="n">case_i</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Proceed LABEL_INPUT section in ftbl and add result to the list netan[&quot;iso_input&quot;] and netan[&quot;funlab&quot;] (case_i)</span>
<span class="sd">    List item is a dict {metab;{isotop_int_index:fraction}}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ili</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;iso_input&quot;</span><span class="p">])</span> <span class="c1"># label_input list index</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;iso_input&quot;</span><span class="p">]</span><span class="o">+=</span><span class="p">[{}]</span>
    <span class="k">if</span> <span class="n">case_i</span><span class="p">:</span>
        <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;funlab&quot;</span><span class="p">]</span><span class="o">+=</span><span class="p">[{}]</span>
        <span class="n">resf</span><span class="o">=</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;funlab&quot;</span><span class="p">][</span><span class="n">ili</span><span class="p">]</span>
    <span class="n">res</span><span class="o">=</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;iso_input&quot;</span><span class="p">][</span><span class="n">ili</span><span class="p">]</span>
    <span class="c1"># input isotopomers</span>
    <span class="c1">#import pdb; pdb.set_trace()</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">ftbl</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;LABEL_INPUT&quot;</span><span class="p">,[]):</span>
        <span class="n">metab</span><span class="o">=</span><span class="n">row</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;META_NAME&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">metab</span>
        <span class="k">if</span> <span class="n">metab</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;Clen&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Label input metabolite `</span><span class="si">%s</span><span class="s2">` is not defined in NETWORK (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">).&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">metab</span><span class="p">,</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
        <span class="n">ilen</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ISOTOPOMER&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">))</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1"># -1 for &#39;#&#39; sign</span>
        <span class="k">if</span> <span class="n">ilen</span> <span class="o">!=</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;Clen&quot;</span><span class="p">][</span><span class="n">metab</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Input isotopomer `</span><span class="si">%s</span><span class="s2">` is of bad length (</span><span class="si">%d</span><span class="s2">). A length of </span><span class="si">%d</span><span class="s2"> is expected (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">).&quot;</span><span class="o">%</span>
                <span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;META_NAME&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">+</span><span class="n">row</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ISOTOPOMER&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">),</span> <span class="n">ilen</span><span class="p">,</span>  <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;Clen&quot;</span><span class="p">][</span><span class="n">metab</span><span class="p">],</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
        <span class="n">iiso</span><span class="o">=</span><span class="n">strbit2int</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;ISOTOPOMER&quot;</span><span class="p">])</span>
        <span class="n">res</span><span class="p">[</span><span class="n">metab</span><span class="p">]</span><span class="o">=</span><span class="n">res</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">metab</span><span class="p">,</span> <span class="p">{})</span>
        <span class="k">if</span> <span class="n">case_i</span><span class="p">:</span>
            <span class="n">resf</span><span class="p">[</span><span class="n">metab</span><span class="p">]</span><span class="o">=</span><span class="n">resf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">metab</span><span class="p">,</span> <span class="p">{})</span>
            <span class="n">resf</span><span class="p">[</span><span class="n">metab</span><span class="p">][</span><span class="n">iiso</span><span class="p">]</span><span class="o">=</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span>
            <span class="n">res</span><span class="p">[</span><span class="n">metab</span><span class="p">][</span><span class="n">iiso</span><span class="p">]</span><span class="o">=</span><span class="n">NA</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">val</span><span class="o">=</span><span class="n">eval_expr</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">val</span><span class="o">=</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="mf">0.</span> <span class="ow">and</span> <span class="n">val</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="n">tol</span><span class="p">:</span>
                    <span class="n">val</span><span class="o">=</span><span class="mf">0.</span>
                <span class="k">if</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="mf">1.</span> <span class="ow">and</span> <span class="n">val</span> <span class="o">&lt;=</span> <span class="mf">1.</span><span class="o">+</span><span class="n">tol</span><span class="p">:</span>
                    <span class="n">val</span><span class="o">=</span><span class="mf">1.</span>
                <span class="k">if</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input isotopomer `</span><span class="si">%s</span><span class="s2">` has a value (</span><span class="si">%g</span><span class="s2">) out of range [0; 1] (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;META_NAME&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">+</span><span class="n">row</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ISOTOPOMER&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">),</span> <span class="n">val</span><span class="p">,</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
            <span class="n">res</span><span class="p">[</span><span class="n">metab</span><span class="p">][</span><span class="n">iiso</span><span class="p">]</span><span class="o">=</span><span class="n">val</span>
    <span class="c1"># check that all isoforms sum up to 1 for all inputs for influx_s</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">case_i</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">metab</span> <span class="ow">in</span> <span class="n">res</span><span class="p">:</span>
            <span class="n">le</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="n">metab</span><span class="p">])</span>
            <span class="n">nfo</span><span class="o">=</span><span class="mi">2</span><span class="o">**</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;Clen&quot;</span><span class="p">][</span><span class="n">metab</span><span class="p">]</span>
            <span class="n">su</span><span class="o">=</span><span class="nb">sum</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="n">metab</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">su</span> <span class="o">&gt;</span> <span class="mf">1.</span><span class="o">+</span><span class="mf">1.e-10</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Input metabolite `</span><span class="si">%s</span><span class="s2">` has label summing up to </span><span class="si">%g</span><span class="s2"> which is greater than 1 (</span><span class="si">%s</span><span class="s2">).&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">metab</span><span class="p">,</span> <span class="n">su</span><span class="p">,</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]))</span>
            <span class="k">if</span> <span class="n">le</span> <span class="o">==</span> <span class="n">nfo</span><span class="p">:</span>
                <span class="c1"># all forms are given =&gt; must sum up to 1</span>
                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">su</span><span class="o">-</span><span class="mf">1.</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1.e-10</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Input metabolite `</span><span class="si">%s</span><span class="s2">` has label summing up to </span><span class="si">%g</span><span class="s2"> instead of 1 (</span><span class="si">%s</span><span class="s2">).&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">metab</span><span class="p">,</span> <span class="n">su</span><span class="p">,</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]))</span>
            <span class="k">elif</span> <span class="n">le</span> <span class="o">&lt;</span> <span class="n">nfo</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="c1"># many forms are lacking (not just one)</span>
                <span class="c1"># if fully unlabeled is lacking, use it to complete to 1</span>
                <span class="c1"># otherwise raise an error</span>
                <span class="k">if</span> <span class="mi">0</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">res</span><span class="p">[</span><span class="n">metab</span><span class="p">]:</span>
                    <span class="n">res</span><span class="p">[</span><span class="n">metab</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mf">1.</span><span class="o">-</span><span class="n">su</span>
                <span class="k">elif</span> <span class="nb">abs</span><span class="p">(</span><span class="n">su</span><span class="o">-</span><span class="mf">1.</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1.e-10</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Input metabolite `</span><span class="si">%s</span><span class="s2">` has lacking labels to sum up to 1 (we get sum=</span><span class="si">%g</span><span class="s2"> instead) (</span><span class="si">%s</span><span class="s2">).&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">metab</span><span class="p">,</span> <span class="n">su</span><span class="p">,</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]))</span>
            <span class="k">elif</span> <span class="n">le</span> <span class="o">==</span> <span class="n">nfo</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="c1"># just one form is lacking</span>
                <span class="k">if</span> <span class="n">su</span> <span class="o">!=</span> <span class="mf">1.</span><span class="p">:</span>
                    <span class="c1"># add it to complete to 1</span>
                    <span class="n">la</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">oset</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nfo</span><span class="p">))</span><span class="o">-</span><span class="n">oset</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="n">metab</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">res</span><span class="p">[</span><span class="n">metab</span><span class="p">][</span><span class="n">la</span><span class="p">]</span><span class="o">=</span><span class="mf">1.</span><span class="o">-</span><span class="n">su</span>
    <span class="k">if</span> <span class="n">ili</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># complete absent inputs by their values from the first ftbl</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">oset</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;iso_input&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="n">oset</span><span class="p">(</span><span class="n">res</span><span class="p">):</span>
            <span class="n">res</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">=</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;iso_input&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="n">m</span><span class="p">];</span>
        <span class="k">if</span> <span class="n">case_i</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">oset</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;funlab&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="n">oset</span><span class="p">(</span><span class="n">resf</span><span class="p">):</span>
                <span class="n">resf</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">=</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;funlab&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="n">m</span><span class="p">];</span>
    <span class="n">zeroc</span><span class="o">=</span><span class="n">oset</span><span class="p">(</span><span class="n">m</span> <span class="k">for</span> <span class="n">m</span><span class="p">,</span><span class="n">n</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;Clen&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">lmi</span><span class="o">=</span><span class="n">oset</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">-</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">]</span> <span class="c1"># label input - input</span>
    <span class="n">iml</span><span class="o">=</span><span class="n">oset</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">])</span><span class="o">-</span><span class="n">zeroc</span><span class="o">-</span><span class="n">oset</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="c1"># input - label input</span>
    <span class="k">if</span> <span class="n">lmi</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;LABEL_INPUT section contains metabolite(s) that are not network input(s): &#39;</span><span class="si">%s</span><span class="s2">&#39; (</span><span class="si">%s</span><span class="s2">)</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lmi</span><span class="p">),</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]))</span>
    <span class="k">if</span> <span class="n">iml</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;LABEL_INPUT section lacks certain metabolite(s) that are network input(s): &#39;</span><span class="si">%s</span><span class="s2">&#39; (</span><span class="si">%s</span><span class="s2">)</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">iml</span><span class="p">),</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]))</span></div>


<div class="viewcode-block" id="proc_label_meas">
<a class="viewcode-back" href="../progdoc.html#C13_ftbl.proc_label_meas">[docs]</a>
<span class="k">def</span> <span class="nf">proc_label_meas</span><span class="p">(</span><span class="n">ftbl</span><span class="p">,</span> <span class="n">netan</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Proceed LABEL_MEASUREMENT section of ftbl file, add the result to a list of dicts</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># label measurements</span>
    <span class="c1"># [ili]][metab][group]-&gt;list of {val:x, dev:y, bcumos:list of #bcumo}</span>
    <span class="n">ili</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;label_meas&quot;</span><span class="p">])</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;label_meas&quot;</span><span class="p">]</span><span class="o">+=</span><span class="p">[{}]</span>
    <span class="n">res</span><span class="o">=</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;label_meas&quot;</span><span class="p">][</span><span class="n">ili</span><span class="p">]</span>
    
    <span class="n">metabs</span><span class="o">=</span><span class="s2">&quot;&quot;</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">ftbl</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;LABEL_MEASUREMENTS&quot;</span><span class="p">,</span> <span class="p">[]):</span>
        <span class="c1">#print row;##</span>
        <span class="c1"># test the cumomer pattern validity</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;#[01x]+(\+#[01x]+)*&quot;</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;CUM_CONSTRAINTS&quot;</span><span class="p">])):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Not valid cumomer&#39;s pattern in &#39;&quot;</span><span class="o">+</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;CUM_CONSTRAINTS&quot;</span><span class="p">]</span><span class="o">+</span><span class="s2">&quot;&#39; (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
        <span class="n">metabs</span><span class="o">=</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;META_NAME&quot;</span><span class="p">]</span> <span class="ow">or</span> <span class="n">metabs</span>
        <span class="n">group</span><span class="o">=</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;CUM_GROUP&quot;</span><span class="p">]</span> <span class="ow">or</span> <span class="n">group</span>
        <span class="c1"># metabs can be metab1[+metab2[+...]]</span>
        <span class="n">metabl</span><span class="o">=</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">metabs</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;+&quot;</span><span class="p">)]</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">metabl</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># pooling metabolites will need their concentraions</span>
            <span class="n">mdif</span><span class="o">=</span><span class="n">oset</span><span class="p">(</span><span class="n">metabl</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;met_pools&quot;</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">mdif</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Pooled metabolite(s) &#39;</span><span class="si">%s</span><span class="s2">&#39; are absent in METABOLITE_POOLS section (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">).&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="n">mdif</span><span class="p">),</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>

        <span class="c1"># check that all metabs are unique</span>
        <span class="n">count</span><span class="o">=</span><span class="nb">dict</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">metabl</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">oset</span><span class="p">(</span><span class="n">metabl</span><span class="p">))</span>
        <span class="n">notuniq</span><span class="o">=</span><span class="n">oset</span><span class="p">((</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">count</span> <span class="k">if</span> <span class="n">count</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">notuniq</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Metabolite(s) &#39;</span><span class="si">%s</span><span class="s2">&#39; is present twice or more (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="n">notuniq</span><span class="p">),</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>

        <span class="n">metab0</span><span class="o">=</span><span class="n">metabl</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">metabl</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">metab0</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;metabs&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Unknown metabolite name &#39;</span><span class="si">%s</span><span class="s2">&#39; in LABEL_MEASUREMENTS (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">metab0</span><span class="p">,</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
        <span class="n">clen0</span><span class="o">=</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;Clen&quot;</span><span class="p">][</span><span class="n">metab0</span><span class="p">]</span> <span class="k">if</span> <span class="n">metab0</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">metab</span> <span class="ow">in</span> <span class="n">metabl</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">metab</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;metabs&quot;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Unknown metabolite name &#39;</span><span class="si">%s</span><span class="s2">&#39; in LABEL_MEASUREMENTS (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">metab</span><span class="p">,</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
            <span class="k">if</span> <span class="n">metab</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;output&quot;</span><span class="p">]</span> <span class="ow">or</span> <span class="n">metab</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;Measured metabolites have to be internal to network (found in input or output metabolites of &#39;</span><span class="si">%s</span><span class="s2">&#39;).</span>
<span class="s2">In case of output, you can add a fictitious metabolite in your network immediatly after &#39;&quot;&quot;&quot;</span><span class="o">%</span><span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="o">+</span><span class="n">metab</span><span class="o">+</span><span class="s2">&quot;&#39; (seen in LABEL_MEASUREMENTS).&quot;</span><span class="p">)</span>
            <span class="n">mlen</span><span class="o">=</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;Clen&quot;</span><span class="p">][</span><span class="n">metab</span><span class="p">]</span>
            <span class="n">clen</span><span class="o">=</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;Clen&quot;</span><span class="p">][</span><span class="n">metab</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">clen</span><span class="o">!=</span><span class="n">clen0</span> <span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Carbon length of &#39;</span><span class="si">%s</span><span class="s2">&#39; (</span><span class="si">%d</span><span class="s2">) is different from the length of &#39;</span><span class="si">%s</span><span class="s2">&#39; (</span><span class="si">%d</span><span class="s2">) (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">metab</span><span class="p">,</span> <span class="n">clen</span><span class="p">,</span> <span class="n">metab0</span><span class="p">,</span> <span class="n">clen0</span><span class="p">,</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">metabs</span> <span class="ow">in</span> <span class="n">res</span><span class="p">:</span>
            <span class="n">res</span><span class="p">[</span><span class="n">metabs</span><span class="p">]</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">res</span><span class="p">[</span><span class="n">metabs</span><span class="p">]:</span>
            <span class="n">res</span><span class="p">[</span><span class="n">metabs</span><span class="p">][</span><span class="n">group</span><span class="p">]</span><span class="o">=</span><span class="p">[]</span>
        <span class="c1"># prepare cumos list</span>
        <span class="c1"># if bcumos is not empty use it</span>
        <span class="c1"># else use group name as carbon number (starting from # character)</span>
        <span class="k">if</span> <span class="n">row</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;CUM_CONSTRAINTS&quot;</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
            <span class="n">bcumos</span><span class="o">=</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;#&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;CUM_CONSTRAINTS&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;+&quot;</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># just put &quot;1&quot; in group-th place</span>
                <span class="n">i</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
                <span class="n">bcumos</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="o">*</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;Clen&quot;</span><span class="p">][</span><span class="n">metabl</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="n">bcumos</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="s2">&quot;1&quot;</span>
                <span class="n">bcumos</span><span class="o">=</span><span class="p">[</span><span class="n">bcumos</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Expected integer CUM_GROUP in LABEL_MEASUREMENTS on row &quot;</span><span class="o">+</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The field VALUE is empty (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;DEVIATION&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The field DEVIATION is empty (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">val</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">eval_expr</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]))</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">val</span><span class="o">=</span><span class="n">NaN</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">sdev</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">eval_expr</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;DEVIATION&quot;</span><span class="p">]))</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;DEVIATION must evaluate to a real positive number (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">).&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">sdev</span> <span class="o">&lt;=</span> <span class="mf">0.</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;DEVIATION must be positive (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">).&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
        <span class="n">res</span><span class="p">[</span><span class="n">metabs</span><span class="p">][</span><span class="n">group</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                <span class="s2">&quot;val&quot;</span><span class="p">:</span><span class="n">val</span><span class="p">,</span>
                <span class="s2">&quot;dev&quot;</span><span class="p">:</span><span class="n">sdev</span><span class="p">,</span>
                <span class="s2">&quot;bcumos&quot;</span><span class="p">:</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;CUM_CONSTRAINTS&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;+&quot;</span><span class="p">),</span>
                <span class="s2">&quot;id&quot;</span><span class="p">:</span><span class="s2">&quot;:&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;l&quot;</span><span class="p">,</span> <span class="n">metabs</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;CUM_CONSTRAINTS&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;#&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">])]),</span>
                <span class="s2">&quot;pooled&quot;</span><span class="p">:</span><span class="n">metabl</span><span class="p">,</span>
        <span class="p">})</span>
        <span class="c1"># test the icumomer lengths</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ic</span><span class="p">)</span><span class="o">==</span><span class="n">mlen</span><span class="o">+</span><span class="mi">1</span> <span class="k">for</span> <span class="n">ic</span> <span class="ow">in</span> 
                <span class="n">res</span><span class="p">[</span><span class="n">metabs</span><span class="p">][</span><span class="n">group</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;bcumos&quot;</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Wrong cumomer length for </span><span class="si">%s</span><span class="s2"> in </span><span class="si">%s</span><span class="s2"> (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">metab</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;CUM_CONSTRAINTS&quot;</span><span class="p">],</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span></div>

<div class="viewcode-block" id="proc_peak_meas">
<a class="viewcode-back" href="../progdoc.html#C13_ftbl.proc_peak_meas">[docs]</a>
<span class="k">def</span> <span class="nf">proc_peak_meas</span><span class="p">(</span><span class="n">ftbl</span><span class="p">,</span> <span class="n">netan</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Proceed PEAK_MEASUREMENT section of ftbl file, add the result to a list of dicts</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># peak measurements</span>
    <span class="c1"># [ili]][metab][c_no][peak_type in (S,D-,D+,(DD|T))]={val:x, dev:y}</span>
    <span class="n">ili</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;peak_meas&quot;</span><span class="p">])</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;peak_meas&quot;</span><span class="p">]</span><span class="o">+=</span><span class="p">[{}]</span>
    <span class="n">res</span><span class="o">=</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;peak_meas&quot;</span><span class="p">][</span><span class="n">ili</span><span class="p">]</span>
    <span class="c1"># peak measurements</span>
    <span class="n">metabs</span><span class="o">=</span><span class="s2">&quot;&quot;</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">ftbl</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;PEAK_MEASUREMENTS&quot;</span><span class="p">,[]):</span>
        <span class="c1">#print row;##</span>
        <span class="c1"># test the pattern validity</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;VALUE_DD&quot;</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">row</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;VALUE_T&quot;</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Not valid value combination. Only one of DD and T has to be in row &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">row</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
        <span class="n">metabs</span><span class="o">=</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;META_NAME&quot;</span><span class="p">]</span> <span class="ow">or</span> <span class="n">metabs</span>
        <span class="n">metabl</span><span class="o">=</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">metabs</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;+&quot;</span><span class="p">)]</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">metabl</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># pooling metabolites will need their concentraions</span>
            <span class="n">mdif</span><span class="o">=</span><span class="n">oset</span><span class="p">(</span><span class="n">metabl</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;met_pools&quot;</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">mdif</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Pooled metabolite(s) &#39;</span><span class="si">%s</span><span class="s2">&#39; are absent in METABOLITE_POOLS section (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="n">mdif</span><span class="p">),</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>

        <span class="c1"># check that all metabs are unique</span>
        <span class="n">count</span><span class="o">=</span><span class="nb">dict</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">metabl</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">oset</span><span class="p">(</span><span class="n">metabl</span><span class="p">))</span>
        <span class="n">notuniq</span><span class="o">=</span><span class="n">oset</span><span class="p">((</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">count</span> <span class="k">if</span> <span class="n">count</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">notuniq</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Metabolite(s) &#39;</span><span class="si">%s</span><span class="s2">&#39; is present twice or more (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="n">notuniq</span><span class="p">),</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>

        <span class="n">metab0</span><span class="o">=</span><span class="n">metabl</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">metabl</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">metab0</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;metabs&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Unknown metabolite name &#39;</span><span class="si">%s</span><span class="s2">&#39; in PEAK_MEASUREMENTS (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">metab0</span><span class="p">,</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
        <span class="n">clen0</span><span class="o">=</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;Clen&quot;</span><span class="p">][</span><span class="n">metab0</span><span class="p">]</span> <span class="k">if</span> <span class="n">metab0</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">metab</span> <span class="ow">in</span> <span class="n">metabl</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">metab</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;metabs&quot;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Unknown metabolite name &#39;</span><span class="si">%s</span><span class="s2">&#39; in PEAK_MEASUREMENTS (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">metab</span><span class="p">,</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
            <span class="k">if</span> <span class="n">metab</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;output&quot;</span><span class="p">]</span> <span class="ow">or</span> <span class="n">metab</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;Measured metabolites have to be internal to network (seen in input or output metabolites (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%d</span><span class="s2">) ).</span>
<span class="s2">In case of output, you can add a fictitious metabolite in your network immediatly after &#39;&quot;&quot;&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">])</span><span class="o">+</span><span class="n">metab</span><span class="o">+</span><span class="s2">&quot;&#39; (seen in PEAK_MEASUREMENTS).&quot;</span><span class="p">)</span>
            <span class="n">clen</span><span class="o">=</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;Clen&quot;</span><span class="p">][</span><span class="n">metab</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">clen</span><span class="o">!=</span><span class="n">clen0</span> <span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Carbon length of &#39;</span><span class="si">%s</span><span class="s2">&#39; (</span><span class="si">%d</span><span class="s2">) is different from the length of &#39;</span><span class="si">%s</span><span class="s2">&#39; (</span><span class="si">%d</span><span class="s2">) (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">metab</span><span class="p">,</span> <span class="n">clen</span><span class="p">,</span> <span class="n">metab0</span><span class="p">,</span> <span class="n">clen0</span><span class="p">,</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
        <span class="n">res</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">metabs</span><span class="p">,</span> <span class="nb">dict</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">suff</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;D-&quot;</span><span class="p">,</span> <span class="s2">&quot;D+&quot;</span><span class="p">,</span> <span class="s2">&quot;DD&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">):</span>
            <span class="c1"># get val and dev for this type of peak</span>
            <span class="n">val</span><span class="o">=</span><span class="n">row</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;VALUE_&quot;</span><span class="o">+</span><span class="n">suff</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">val</span> <span class="ow">or</span> <span class="n">val</span><span class="o">==</span><span class="s2">&quot;-&quot;</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="n">dev</span><span class="o">=</span><span class="n">row</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;DEVIATION_&quot;</span><span class="o">+</span><span class="n">suff</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">row</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;DEVIATION_S&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">suff</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;DD&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">):</span>
               <span class="n">dev</span><span class="o">=</span><span class="n">row</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;DEVIATION_DD/T&quot;</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">row</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;DEVIATION_S&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">dev</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The field DEVIATION_</span><span class="si">%s</span><span class="s2"> is empty (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">suff</span><span class="p">,</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">val</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">eval_expr</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="n">val</span><span class="o">=</span><span class="n">NaN</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">dev</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">eval_expr</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="c1"># test validity</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">dev</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Deviation is not valid for VALUE_&quot;</span><span class="o">+</span><span class="n">suff</span><span class="o">+</span><span class="s2">&quot; (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">)</span><span class="o">%</span><span class="p">(</span><span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">])</span>
            <span class="n">c_no</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;PEAK_NO&quot;</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">c_no</span> <span class="o">&gt;</span> <span class="n">clen0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Carbon number &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">c_no</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; is greater than carbon length &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">clen0</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; for metabolite &#39;&quot;</span><span class="o">+</span><span class="n">metab0</span><span class="o">+</span><span class="s2">&quot;&#39; (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
            <span class="k">if</span> <span class="n">suff</span> <span class="o">==</span> <span class="s2">&quot;D-&quot;</span> <span class="ow">and</span> <span class="n">c_no</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Peak D- cannot be set for metabolite &quot;</span><span class="o">+</span><span class="n">metab0</span><span class="o">+</span><span class="s2">&quot;, c_no=1 (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
            <span class="k">if</span> <span class="n">suff</span> <span class="o">==</span> <span class="s2">&quot;D+&quot;</span> <span class="ow">and</span> <span class="n">c_no</span> <span class="o">==</span> <span class="n">clen</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Peak D+ cannot be set for metabolite &quot;</span><span class="o">+</span><span class="n">metab</span><span class="o">+</span><span class="s2">&quot;, c_no=&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">c_no</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">suff</span> <span class="o">==</span> <span class="s2">&quot;DD&quot;</span> <span class="ow">or</span> <span class="n">suff</span> <span class="o">==</span> <span class="s2">&quot;T&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">c_no</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">c_no</span> <span class="o">==</span> <span class="n">clen</span> <span class="ow">or</span> <span class="n">clen</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Peak DD (or T) cannot be set for metabolite &quot;</span><span class="o">+</span><span class="n">metab</span><span class="o">+</span><span class="s2">&quot;, c_no=&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">c_no</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;, len=&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">clen</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
            <span class="n">res</span><span class="p">[</span><span class="n">metabs</span><span class="p">]</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">],</span> <span class="nb">dict</span><span class="p">())</span>
            <span class="n">res</span><span class="p">[</span><span class="n">metabs</span><span class="p">][</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]][</span><span class="n">suff</span><span class="p">]</span><span class="o">=</span><span class="p">{</span>
               <span class="s2">&quot;val&quot;</span><span class="p">:</span> <span class="n">val</span><span class="p">,</span>
               <span class="s2">&quot;dev&quot;</span><span class="p">:</span> <span class="n">dev</span><span class="p">,</span>
               <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="s2">&quot;:&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;p&quot;</span><span class="p">,</span> <span class="n">metabs</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;PEAK_NO&quot;</span><span class="p">],</span> <span class="n">suff</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">])]),</span>
               <span class="s2">&quot;irow&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]),</span>
               <span class="s2">&quot;c_no&quot;</span><span class="p">:</span> <span class="n">c_no</span><span class="p">,</span>
               <span class="s2">&quot;pooled&quot;</span><span class="p">:</span><span class="n">metabl</span><span class="p">,</span>
            <span class="p">}</span></div>

<div class="viewcode-block" id="proc_mass_meas">
<a class="viewcode-back" href="../progdoc.html#C13_ftbl.proc_mass_meas">[docs]</a>
<span class="k">def</span> <span class="nf">proc_mass_meas</span><span class="p">(</span><span class="n">ftbl</span><span class="p">,</span> <span class="n">netan</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Proceed PEAK_MEASUREMENT section of ftbl file, add the result to a list of dicts</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ili</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;mass_meas&quot;</span><span class="p">])</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;mass_meas&quot;</span><span class="p">]</span><span class="o">+=</span><span class="p">[{}]</span>
    <span class="n">res</span><span class="o">=</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;mass_meas&quot;</span><span class="p">][</span><span class="n">ili</span><span class="p">]</span>
    <span class="c1"># mass measurements</span>
    <span class="c1"># [ili]][metab][frag_mask][weight]={val:x, dev:y}</span>
    <span class="n">metabs</span><span class="o">=</span><span class="s2">&quot;&quot;</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">ftbl</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;MASS_SPECTROMETRY&quot;</span><span class="p">,[]):</span>
        <span class="c1">#print row;##</span>
        <span class="n">metabs</span><span class="o">=</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;META_NAME&quot;</span><span class="p">]</span> <span class="ow">or</span> <span class="n">metabs</span>
        <span class="c1"># metabs can be metab1[+metab2[+...]]</span>
        <span class="n">metabl</span><span class="o">=</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">metabs</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;+&quot;</span><span class="p">)]</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">metabl</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># pooling metabolites will need their concentraions</span>
            <span class="n">mdif</span><span class="o">=</span><span class="n">oset</span><span class="p">(</span><span class="n">metabl</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;met_pools&quot;</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">mdif</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Pooled metabolite(s) &#39;</span><span class="si">%s</span><span class="s2">&#39; are absent in METABOLITE_POOLS section (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="n">mdif</span><span class="p">),</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>

        <span class="c1"># check that all metabs are unique</span>
        <span class="n">count</span><span class="o">=</span><span class="nb">dict</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">metabl</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">oset</span><span class="p">(</span><span class="n">metabl</span><span class="p">))</span>
        <span class="c1">#print(count)</span>
        <span class="n">notuniq</span><span class="o">=</span><span class="n">oset</span><span class="p">((</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">count</span> <span class="k">if</span> <span class="n">count</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">notuniq</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Metabolite(s) &#39;</span><span class="si">%s</span><span class="s2">&#39; is present twice or more (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="n">notuniq</span><span class="p">),</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>

        <span class="n">metab0</span><span class="o">=</span><span class="n">metabl</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">metabl</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">metab0</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;metabs&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Unknown metabolite name &#39;</span><span class="si">%s</span><span class="s2">&#39; in MASS_MEASUREMENTS (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">metab0</span><span class="p">,</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
        <span class="n">clen0</span><span class="o">=</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;Clen&quot;</span><span class="p">][</span><span class="n">metab0</span><span class="p">]</span> <span class="k">if</span> <span class="n">metab0</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;META_NAME&quot;</span><span class="p">]:</span>
            <span class="n">irow</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">])</span>
            <span class="n">frag</span><span class="o">=</span><span class="s2">&quot;&quot;</span>
            <span class="c1">#frag=&quot;,&quot;.join(str(i+1) for i in range(clen0))</span>
            <span class="n">mask</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">clen0</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">frag</span><span class="o">=</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;FRAGMENT&quot;</span><span class="p">]</span> <span class="ow">or</span> <span class="n">frag</span>
        <span class="k">for</span> <span class="n">metab</span> <span class="ow">in</span> <span class="n">metabl</span><span class="p">:</span>
            <span class="n">clen</span><span class="o">=</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;Clen&quot;</span><span class="p">][</span><span class="n">metab</span><span class="p">]</span>
            <span class="c1"># test the validity</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">metab</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;metabs&quot;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Unknown metabolite name &#39;</span><span class="si">%s</span><span class="s2">&#39; in MASS_SPECTROMETRY (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">).&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">metab</span><span class="p">,</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
            <span class="k">if</span> <span class="n">metab</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;output&quot;</span><span class="p">]</span> <span class="ow">or</span> <span class="n">metab</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;Measured metabolites have to be internal to network.</span>
<span class="s2">In case of output, you can add a fictitious metabolite following to &#39;&quot;&quot;&quot;</span><span class="o">+</span><span class="n">metab</span><span class="o">+</span><span class="s2">&quot;&#39; (seen in MASS_MEASUREMENTS).&quot;</span><span class="p">)</span>
            <span class="n">clen</span><span class="o">=</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;Clen&quot;</span><span class="p">][</span><span class="n">metab</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">clen</span><span class="o">!=</span><span class="n">clen0</span> <span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Carbon length of &#39;</span><span class="si">%s</span><span class="s2">&#39; (</span><span class="si">%d</span><span class="s2">) is different from the length of &#39;</span><span class="si">%s</span><span class="s2">&#39; (</span><span class="si">%d</span><span class="s2">) (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">metab</span><span class="p">,</span> <span class="n">clen</span><span class="p">,</span> <span class="n">metab0</span><span class="p">,</span> <span class="n">clen0</span><span class="p">,</span> <span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;FRAGMENT&quot;</span><span class="p">]:</span>
            <span class="c1"># recalculate fragment mask</span>
            <span class="n">mask</span><span class="o">=</span><span class="mi">0</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">frag</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">i</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">clen0</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;An item &#39;&quot;</span><span class="o">+</span><span class="n">item</span><span class="o">+</span><span class="s2">&quot;&#39; of carbon fragment is higher than metabolite &#39;&quot;</span><span class="o">+</span><span class="n">metab0</span><span class="o">+</span><span class="s2">&quot;&#39; length &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">clen0</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%d</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">irow</span><span class="p">))</span>
                    <span class="c1"># add this simple item to the mask</span>
                    <span class="n">mask</span><span class="o">|=</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">clen0</span><span class="o">-</span><span class="n">i</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="c1"># try the interval</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="p">(</span><span class="n">start</span><span class="p">,</span><span class="n">end</span><span class="p">)</span><span class="o">=</span><span class="n">item</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;~&quot;</span><span class="p">)</span>
                        <span class="c1">#print &quot;start,end=%s,%s&quot; % (start,end);##</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">start</span><span class="p">),</span><span class="nb">int</span><span class="p">(</span><span class="n">end</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                                <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">clen0</span><span class="p">:</span>
                                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;End of interval &#39;&quot;</span><span class="o">+</span><span class="n">item</span><span class="o">+</span><span class="s2">&quot;&#39; is higher than metabolite &#39;&quot;</span><span class="o">+</span><span class="n">metab0</span><span class="o">+</span><span class="s2">&quot;&#39; length &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">clen0</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%d</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">irow</span><span class="p">))</span>
                                <span class="n">mask</span><span class="o">|=</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">clen0</span><span class="o">-</span><span class="n">i</span><span class="p">)</span>
                        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Badly formed fragment interval &#39;&quot;</span><span class="o">+</span><span class="n">item</span><span class="o">+</span><span class="s2">&quot;&#39; (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%d</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">irow</span><span class="p">))</span>
                    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Badly formed fragment interval &#39;&quot;</span><span class="o">+</span><span class="n">item</span><span class="o">+</span><span class="s2">&quot;&#39; (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%d</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">irow</span><span class="p">))</span>
        <span class="n">m_id</span><span class="o">=</span><span class="s2">&quot;:&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;m&quot;</span><span class="p">,</span> <span class="n">metabs</span><span class="p">,</span> <span class="n">frag</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">irow</span><span class="p">)])</span>
        <span class="n">weight</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;WEIGHT&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">sumbit</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">weight</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Weight &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; is higher than fragment length &quot;</span><span class="o">+</span><span class="n">frag</span><span class="o">+</span><span class="s2">&quot; (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%d</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">irow</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">clen</span> <span class="o">&lt;</span> <span class="n">sumbit</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Fragment &quot;</span><span class="o">+</span><span class="n">frag</span><span class="o">+</span><span class="s2">&quot; is longer than metabolite length &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">clen</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%d</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">irow</span><span class="p">))</span>
        <span class="n">res</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">m_id</span><span class="p">,</span> <span class="nb">dict</span><span class="p">())</span>
        <span class="n">res</span><span class="p">[</span><span class="n">m_id</span><span class="p">]</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="nb">dict</span><span class="p">())</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The field VALUE is empty (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;DEVIATION&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The field DEVIATION is empty (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">val</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">eval_expr</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]))</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">val</span><span class="o">=</span><span class="n">NaN</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">sdev</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">eval_expr</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;DEVIATION&quot;</span><span class="p">]))</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;DEVIATION must evaluate to a real positive number (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">).&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">sdev</span> <span class="o">&lt;=</span> <span class="mf">0.</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;DEVIATION must be positive (</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">).&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">ftbl</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]))</span>
        <span class="n">res</span><span class="p">[</span><span class="n">m_id</span><span class="p">][</span><span class="n">mask</span><span class="p">][</span><span class="n">weight</span><span class="p">]</span><span class="o">=</span><span class="p">{</span>
                <span class="s2">&quot;val&quot;</span><span class="p">:</span><span class="n">val</span><span class="p">,</span>
                <span class="s2">&quot;dev&quot;</span><span class="p">:</span><span class="n">sdev</span><span class="p">,</span>
                <span class="s2">&quot;id&quot;</span><span class="p">:</span><span class="s2">&quot;:&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;m&quot;</span><span class="p">,</span> <span class="n">metabs</span><span class="p">,</span> <span class="n">frag</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;WEIGHT&quot;</span><span class="p">],</span> <span class="nb">str</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">])]),</span>
                <span class="s2">&quot;irow&quot;</span><span class="p">:</span><span class="nb">str</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;irow&quot;</span><span class="p">]),</span>
                <span class="s2">&quot;pooled&quot;</span><span class="p">:</span><span class="n">metabl</span><span class="p">,</span>
        <span class="p">}</span></div>


<div class="viewcode-block" id="proc_kinopt">
<a class="viewcode-back" href="../progdoc.html#C13_ftbl.proc_kinopt">[docs]</a>
<span class="k">def</span> <span class="nf">proc_kinopt</span><span class="p">(</span><span class="n">ftbl</span><span class="p">,</span> <span class="n">netan</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Proceed label kinetics options from OPTIONS section: file_labcin, dt, tmax, nsubdiv_dt, funlab</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># default values (used when absent in ftbl)</span>
    <span class="n">de</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;file_labcin&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;dt&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;tmax&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">),</span> <span class="s2">&quot;nsubdiv_dt&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;funlabR&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">}</span>
    <span class="k">if</span> <span class="s2">&quot;opt&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">:</span>
        <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;opt&quot;</span><span class="p">]</span><span class="o">=</span><span class="nb">dict</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="p">[])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">de</span><span class="p">)</span>
    <span class="c1"># get ftbl OPTIONS -&gt; d</span>
    <span class="n">d</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">ftbl</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;OPTIONS&quot;</span><span class="p">,[]):</span>
        <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;OPT_NAME&quot;</span><span class="p">][:</span><span class="mi">7</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;funlab:&quot;</span><span class="p">:</span>
            <span class="n">d</span><span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;OPT_NAME&quot;</span><span class="p">]]</span><span class="o">=</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;OPT_VALUE&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">val</span><span class="o">=</span><span class="n">eval_expr</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;OPT_VALUE&quot;</span><span class="p">],</span> <span class="n">werr</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
            <span class="n">d</span><span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;OPT_NAME&quot;</span><span class="p">]]</span><span class="o">=</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;OPT_VALUE&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">val</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">de</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;opt&quot;</span><span class="p">]:</span>
            <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;opt&quot;</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;opt&quot;</span><span class="p">][</span><span class="n">k</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">:</span>
            <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;opt&quot;</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="p">[]</span> <span class="c1"># if already set to a value, reset to a list</span>
        <span class="n">ili</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;opt&quot;</span><span class="p">][</span><span class="n">k</span><span class="p">])</span>
        <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;opt&quot;</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="o">+=</span><span class="p">[{}]</span>
        <span class="n">res</span><span class="o">=</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;opt&quot;</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>
        <span class="n">res</span><span class="p">[</span><span class="n">ili</span><span class="p">]</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">de</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
    <span class="c1"># append funval entries</span>
    <span class="k">if</span> <span class="s2">&quot;funlab&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;opt&quot;</span><span class="p">]:</span>
        <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;opt&quot;</span><span class="p">][</span><span class="s2">&quot;funlab&quot;</span><span class="p">]</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">ili</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">netan</span><span class="p">[</span><span class="s2">&quot;opt&quot;</span><span class="p">][</span><span class="s2">&quot;funlab&quot;</span><span class="p">])</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;opt&quot;</span><span class="p">][</span><span class="s2">&quot;funlab&quot;</span><span class="p">]</span><span class="o">+=</span><span class="p">[{}]</span>
    <span class="n">netan</span><span class="p">[</span><span class="s2">&quot;opt&quot;</span><span class="p">][</span><span class="s2">&quot;funlab&quot;</span><span class="p">][</span><span class="n">ili</span><span class="p">]</span><span class="o">=</span><span class="nb">dict</span><span class="p">((</span><span class="n">k</span><span class="p">[</span><span class="mi">7</span><span class="p">:],</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span><span class="p">[:</span><span class="mi">7</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;funlab:&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="mkfunlabli">
<a class="viewcode-back" href="../progdoc.html#C13_ftbl.mkfunlabli">[docs]</a>
<span class="k">def</span> <span class="nf">mkfunlabli</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
    <span class="s2">&quot;transform &#39;d&#39; dict to a string representing a body of an R function calculating labeling dependent on time &#39;t&#39;&quot;</span>
    <span class="c1"># d is like {&#39;Gluc_1:{32: &#39;{T=0; if (t &gt;= T) 1 else NA}&#39;}}</span>
    <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%(li)s</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">{</span><span class="s2">&quot;li&quot;</span><span class="p">:</span> <span class="s2">&quot;list(&quot;</span><span class="o">+</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;`</span><span class="si">%(m)s</span><span class="s2">`=list(</span><span class="si">%(i2f)s</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">{</span><span class="s2">&quot;m&quot;</span><span class="p">:</span> <span class="n">m</span><span class="p">,</span> <span class="s2">&quot;i2f&quot;</span><span class="p">:</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;`</span><span class="si">{</span><span class="n">iso</span><span class="si">}</span><span class="s2">`=&#39;</span><span class="si">{</span><span class="n">f</span><span class="si">}</span><span class="s2">&#39;&quot;</span> <span class="k">for</span> <span class="n">iso</span><span class="p">,</span><span class="n">f</span> <span class="ow">in</span> <span class="n">idi</span><span class="o">.</span><span class="n">items</span><span class="p">())}</span> <span class="k">for</span> <span class="n">m</span><span class="p">,</span><span class="n">idi</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">())</span><span class="o">+</span><span class="s2">&quot;)&quot;</span><span class="p">}</span></div>

    
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">influx_si 7.2 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">C13_ftbl</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2012-2024, INRAE/INSA/CNRS.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>